(ns scanner-test
  (require kapok_scanner io)
  (use kunit))

(defn scan [string]
  (let [{^ok, tokens, _locations} (kapok_scanner.scan string 1 [])]
    tokens))

(defn scan-1 [string]
  (let [tokens (scan string)]
    (case tokens
      ([token] token)
      (erlang.throw "expect only one token"))))

(defn main []
  (test "test unquote keyword"
    (let [chars [;; upper cases
                 "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O"
                 "P" "Q" "R" "S" "T" "U" "V" "W" "X" "Y" "Z"
                 ;; lower cases
                 "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o"
                 "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z"
                 ;; digits
                 "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "10"
                 ;; punctuation chars and special chars
                 "!" "$" "%" "*" "+" "-" "/" "<" "=" ">" "?" "@" "_" "|"
                 ;; special chars for other data types, keywords, etc.
                 "~" "&" "#" "^"
                 ]]
       (lists.map (fn [e]
                    (let [c (erlang.binary_to_list e)
                          l (lists.append #":" c)
                          a (erlang.list_to_atom c)]
                      (assert (== {^keyword [{^line 1} {^column 1}] a}
                                  (scan-1 l)))))
                  chars)))

  (test "test quote keyword"
    (assert (== {^keyword_unsafe [{^line 1} {^column 1}] <<"foo bar">>}
                (scan-1 #":\"foo bar\""))))

  (test "test keyword"
    (assert (== {^keyword [{^line 1} {^column 1}] ^f0_1} (scan-1 #":f0_1"))))

  (test "test char"
    (let [cases [;; simple escape char
                 {97 "\\a"}
                 {99 "\\c"}
                 ;; special escape chars
                 {32 "\\space"}
                 {9 "\\tab"}
                 {12 "\\formfeed"}
                 {8 "\\backspace"}
                 {10 "\\newline"}
                 {13 "\\return"}
                 {92 "\\\\"}
                 ;; hex char notation
                 {0 "\\x0"}
                 {7 "\\x7"}
                 {10 "\\xa"}
                 {12 "\\xc"}
                 ;; utf-8 char notation
                 {10 "\\x{a}"}
                 {171 "\\x{ab}"}
                 {2748 "\\x{abc}"}
                 {43981 "\\x{abcd}"}
                 {703710 "\\x{abcde}"}
                 {1092557 "\\x{10abcd}"}]]
      (lists.map (fn [{n b}]
                   (let [l (erlang.binary_to_list b)]
                     (assert (== {^char_number [{^line 1} {^column 1}] n}
                                 (scan-1 l)))))
                 cases)))

  (test "test integer"
    (let [cases [;; naive notation
                 {123 "123"}
                 ]]
      (lists.map (fn [{n b}]
                   (let [l (erlang.binary_to_list b)]
                     (assert (== {^integer [{^line 1} {^column 1}] n}
                                 (scan-1 l)))))
                 cases))
    (let [cases [{[{^integer [{^line 1} {^column 1}] 123} {^',' [{^line 1} {^column 4}]}]
                  "123,"}
                 {[{^integer [{^line 1} {^column 3}] 123} {^integer [{^line 1} {^column 8}] 456}]
                  "  123  456  "}
                 {[{^integer [{^line 2} {^column 1}] 123}] "\n123\n"}
                 ;; hex, octal and n base notation
                 {[{^hex_number [{^line 1} {^column 1}] 255}]
                  "0xFF"}
                 {[{^octal_number [{^line 1} {^column 1}] 63}]
                  "077"}
                 {[{^n_base_number [{^line 1} {^column 1}] 3}]
                  "2r11"}
                 {[{^n_base_number [{^line 1} {^column 1}] 20}]
                  "10r20"}
                 {[{^n_base_number [{^line 1} {^column 1}] 72}]
                  "36r20"}
                 ]]
      (lists.map (fn [{expected b}]
                   (let [l (erlang.binary_to_list b)]
                     (assert (== expected
                                 (scan l)))))
                 cases)))

  )
