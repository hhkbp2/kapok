(defprotocol kapok.inspect
  """The `inspect` protocol is responsible for converting any Kapok
  data structure into an algebra document. This document is then
  formetted, either in pretty printing format or a regular one.

  The `(inspect 2)` function receives the entity to be inspected
  followed by the inspecting options, represented by the struct
  `inspect.opts`.

  Inspection is done using the functions available in `Elixir.Inspect.Algebra`.

  ## Examples

  Many times, inspecting a structure can be implemented in function
  of existing entities. For example, here is `hashset`'s `inspect`
  implementation:

      (defimpl inspect HashSet
        (use Elixir.Inspect.Algebra)
        (defn inspect [dict opts]
          (concat ["#HashSet<" (to_doc (hashset.to-list dict) opts) ">"])))

  The `concat` function comes from `Elixir.Inspect.Algebra` and it
  concatenates algebra documents together. In the example above,
  it is concatenating the string `"HashSet<"` (all strings are
  valid algebra documents that keep their) formatting when pretty
  printed), the document returned by `(inspect.algebra.to-doc 2)` and the
  other string `">"`.

  Since regular strings are valid entities in an algebra document,
  an implementation of inspect may simply return a string,
  although that will devoid it of any pretty-printing.

  # Error handling

  In case there is an error while you structure is being inspected,
  Kapok will automatically fall back to a raw representation.

  You can however access the underlying error by invoking the inspect
  implementation directly. For example, to test inspect.hashset above,
  you can invoke it as:

      (inspect.hashset.inspect (hashset.new) (inspect.opts.new))

  """

  (inspect [thing opts])
  )

(defimpl kapok.inspect Integer
  (require (Elixir.Inspect.Algebra :as alg))

  (defn inspect [term #{:base base} &as opts]
    (-> (Elixir.Integer.to_string term (base-to-value base))
        (prepend-prefix base)
        (alg.color #number opts)))

  (defn- base-to-value [base]
    (case base
      (#binary 2)
      (#decimal 10)
      (#octal 8)
      (#hex 16)))

  (defn- prepend-prefix [value #decimal]
    value)
  (defn- prepend-prefix [<< $- (value :binary) >> base]
    << $- ((prepend-prefix value base)) >>)
  (defn- prepend-prefix [value base]
    (let [prefix (case base
                   (#binary "2r")
                   (#octal "0")
                   (#hex "0x"))]
      << (prefix :binary) (value :binary) >>))
  )

(defimpl kapok.inspect Float
  (require io_lib_format
           (Elixir.IO :as io))

  (defn inspect [term _opts]
    (io.iodata_to_binary (io_lib_format.fwrite_g term)))
  )

(defimpl kapok.inspect BitString
  (require lists
           (Elixir.Integer :as integer)
           (Elixir.Map :as map)
           (Elixir.Inspect.Algebra :as alg)
           (Elixir.IO :as io)
           (kapok (inspect.Integer)))

  (defn inspect [term opts] (&when (binary? term))
    (let [#{:binaries bins
            :base base
            :printable_limit printable-limit} opts]
      (if (and (== base #decimal)
               (or (== bins #as_strings)
                   (and (== bins #infer)
                        (Elixir.String.printable? term printable-limit))))
          (let [inspected (case (escape term $" printable-limit)
                            ({escaped ""} [$" escaped $"])
                            ({escaped _} [$" escaped " ..." $"]))]
            (alg.color (io.iodata_to_binary inspected) #string opts))
        (inspect-bitstring term opts))))

  (defn inspect [term opts]
    (inspect-bitstring term opts))

  (defn- inspect-bitstring ["" opts]
    (alg.color "<< >>" #binary opts))

  (defn- inspect-bitstring [bitstring opts]
    (let [left (alg.color "<< " #binary opts)
          right (alg.color " >>" #binary opts)
          inner (each-bit bitstring (map.get opts #limit) opts)]
      (alg.group (alg.concat (alg.concat left (alg.nest inner 2)) right))))

  (defn- each-bit [_ 0 _]
    " ...")

  (defn- each-bit [<< >> _counter _opts]
    #doc_nil)

  (defn- each-bit [<<(h (:size 8))>> _counter opts]
    (inspect.Integer.inspect h opts))

  (defn- each-bit [<< h (t :bitstring)>> counter opts]
    (alg.flex_glue
      (alg.concat (inspect.Integer.inspect h opts)
                  (alg.break))
      (each-bit t (decrement counter) opts)))

  (defn- each-bit [bitstring _counter opts]
    (let [size (bit-size bitstring)
          <<(h (:size size))>> bitstring]
      << "(" ((inspect.Integer.inspect h opts) :binary)
         " (:size " ((integer.to_string size) :binary) "))" >>))

  (defn- decrement [#infinity]
    #infinity)
  (defn- decrement [counter]
    (dec counter))

  ;; Escaping

  (defn- escape-map [$\a] << $\\ $a >>)
  (defn- escape-map [$\b] << $\\ $b >>)
  (defn- escape-map [$\d] << $\\ $d >>)
  (defn- escape-map [$\e] << $\\ $e >>)
  (defn- escape-map [$\f] << $\\ $f >>)
  (defn- escape-map [$\n] << $\\ $n >>)
  (defn- escape-map [$\r] << $\\ $r >>)
  (defn- escape-map [$\t] << $\\ $t >>)
  (defn- escape-map [$\v] << $\\ $v >>)
  (defn- escape-map [$\\] << $\\ $\\ >>)
  (defn- escape-map [_] :false)

  (defn escape [other char &optional (count #infinity) (fun (fn escape-map 1))]
    (escape other char count [] fun))

  (defn- escape [binary _char 0 acc _fun]
    {(lists.reverse acc) binary})

  (defn- escape [<< char (t :binary) >> char count acc fun]
    (escape t char (decrement count) [<< $\\ char >> & acc] fun))

  (defn- escape [<< (h :utf8) (t :binary) >> char count acc fun]
    (let [value (fun h)
          escaped (or value (escape-char h))]
      (escape t char (decrement count) [escaped & acc] fun)))

  (defn- escape [<< (a (:size 4)) (b (:size 4)) (t :binary) >> char count acc fun]
    (escape t char (decrement count) [<< $\\ $x ((to-hex a)) ((to-hex b)) >> & acc] fun))

  (defn- escape [<< >> _char _count acc _fun]
    {(lists.reverse acc) << >>})

  (defn- escape-char [0] "\\0")

  (defn- escape-char [65279] "\\uFEFF")

  (defn- escape-char [char] (&when (&or (&and (>= char 0x20) (<= char 0x7E))
                                        (&and (>= char 0xA0) (<= char 0xD7FF))
                                        (&and (>= char 0xE000) (<= char 0xFFFD))
                                        (&and (>= char 0x10000) (<= char 0x10FFFF))))
    << (char :utf8) >>)

  (defn- escape-char [char] (&when (< char 0x100))
    (let [<<(a (:size 4)) (b (:size 4))>> <<(char (:size 8))>>]
     << $\\ $x ((to-hex a)) ((to-hex b)) >>))

  (defn- escape-char [char] (&when (< char 0x10000))
    (let [<<(a (:size 4))
            (b (:size 4))
            (c (:size 4))
            (d (:size 4))>> <<(char (:size 16))>>]
     << $\\ $x ${ ((to-hex a)) ((to-hex b)) ((to-hex c)) ((to-hex d)) $} >>))

  (defn- escape-char [char] (&when (< char 0x1000000))
    (let [<<(a (:size 4))
            (b (:size 4))
            (c (:size 4))
            (d (:size 4))
            (e (:size 4))
            (f (:size 4))>> <<(char (:size 24))>>]
     << $\\ $x ${ ((to-hex a))
                  ((to-hex b))
                  ((to-hex c))
                  ((to-hex d))
                  ((to-hex e))
                  ((to-hex f)) $} >>))

  (defn- to-hex [c] (&when (&and (>= c 0) (<= c 9)))
    (+ c $0))
  (defn- to-hex [c] (&when (&and (>= c 10) (<= c 15)))
    (+ (- c 10) $A))

  )

(defimpl kapok.inspect Atom
  (require (Elixir.Inspect.Algebra :as alg)
           (Elixir.IO :as io)
           (kapok (char
                   (inspect.BitString :as bs))))
  (use (kapok ((core :exclude (inspect)))))

  (defn inspect [atom opts]
    (let [{doc key}
          (case atom
            (:false {":false" #boolean})
            (:true {":true" #boolean})
            (:nil {":nil" #boolean})
            (#'' {"#''" #atom})
            (_ (let [b (Elixir.Atom.to_string atom)
                     d (if (valid-atom-identifier? b)
                           << "#" (b :binary) >>
                         (let [{escaped _} (bs.escape b $')
                               eb (io.iodata_to_binary escaped)]
                           << $# $' (eb :binary) $' >>))]
                 {d #atom})))]
      (alg.color doc key opts)))

  ;; Detect if atom is an simple atom which consists of identifier characters
  ;; (no need to quote).
  (defn- valid-atom-identifier? [<<>>]
    :true)

  (defn- valid-atom-identifier? [<< h (t :binary) >>]
      (&when (char.identifier-char? h))
    (valid-atom-identifier? t))

  (defn- valid-atom-identifier? [_]
    :false)
  )

(defimpl kapok.inspect List
  (require (Elixir.IO :as io)
           (kapok (atom
                   inspect.Atom
                   inspect.BitString)))
  (use (Elixir.Inspect.Algebra :only (concat
                                      surround_many
                                      to_doc)))

  (defn inspect [[] _opts]
    "[]")

  (defn inspect [thing #{:char_lists lists} &as opts]
    (cond
      (or (== lists #as_char_lists)
          (and (== lists #infer)
               (printable? thing)))
        << $' ((inspect.BitString.escape (io.chardata_to_string thing) $') :binary) $' >>
      (keyword? thing)
        (surround_many "[" thing "]" opts (fn keyword 2))
      :true
        ;; TODO add alias checking for names in `(fn remote fun arity)` syntax.
        (surround_many "[" thing "]" opts (fn Elixir.Inspect.Algebra to_doc 2))))

  (defn keyword [{key value} opts]
    (concat <<((key-to-binary key opts)) ": " >> (to_doc value opts)))

  (defn keyword? [[{key _value} & rest]] (&when (atom? key))
    (case (Elixir.Atom.to_char_list key)
      ((op-++ #"kapok." _) :false)
      (_ (keyword? rest))))

  (defn keyword? [[]]
    :true)
  (defn keyword? [_other]
    :false)

  ;; private

  (defn- key-to-binary [key opts]
    (case (inspect.Atom.inspect key opts)
      (<< "#" right >> right)
      (other other)))

  (defn- printable? [[c & cs]] (&when (&and (integer? c)
                                            (op-and (>= c 32)
                                                    (<= c 126))))
    (printable? cs))
  (defn- printable? [[$\n & cs]] (printable? cs))
  (defn- printable? [[$\r & cs]] (printable? cs))
  (defn- printable? [[$\t & cs]] (printable? cs))
  (defn- printable? [[$\v & cs]] (printable? cs))
  (defn- printable? [[$\b & cs]] (printable? cs))
  (defn- printable? [[$\f & cs]] (printable? cs))
  (defn- printable? [[$\e & cs]] (printable? cs))
  (defn- printable? [[$\a & cs]] (printable? cs))
  (defn- printable? [[]] :true)
  (defn- printable? [_] :false)

  )

(defimpl kapok.inspect Tuple
  (use (Elixir.Inspect.Algebra :only (surround_many)))
  (defn inspect [{} _opts]
    "{}")

  (defn inspect [tuple opts]
    (surround_many "{" (Elixir.Tuple.to_list tuple) "}" opts
                   (fn Elixir.Inspect.Algebra to_doc 2)))
  )

(defimpl kapok.inspect Map
  (require maps
           (kapok (inspect.List)))
  (use (Elixir.Inspect.Algebra :only (concat
                                      nest
                                      surround_many
                                      to_doc)))

  (defn inspect [map opts]
    (nest (inspect map "" opts) 1))

  (defn inspect [map name opts]
    (let [map1 (maps.to_list map)]
      (surround_many << "#" name "{" >>
                     map1
                     "}"
                     opts
                     (traverse-fun map))))

  (defn- traverse-fun [list]
    (if (inspect.List.keyword? list)
        (fn inspect.List keyword 2)
      (fn to-map 2)))

  (defn- to-map [{key value} opts]
    (concat
     (concat (to_doc key opts) " => ")
     (to_doc value opts)))
  )

(defimpl kapok.inspect PID
  (require erlang
           (Elixir.IO :as io))

  (defn inspect [pid _opts]
    << "#PID" ((io.iodata_to_binary (erlang.pid_to_list pid))) >>)
  )

(defimpl kapok.inspect Port
  (require erlang
           (Elixir.IO :as io))

  (defn inspect [port _opts]
    (io.iodata_to_binary (erlang.port_to_list port)))
  )

(defimpl kapok.inspect Reference
  (require erlang
           (Elixir.IO :as io))

  (defn inspect [ref _opts]
    (let [(op-++ #"#ref" rest) (erlang.ref_to_list ref)]
      << "#Reference" ((io.iodata_to_binary rest)) >>))
  )

(defimpl kapok.inspect Any
  (require maps
           (kapok (inspect.Atom
                   inspect.Map)))

  (defn inspect [#{:__struct__ struct} &as map opts]
    (try (struct.__struct__)
      ((dunder (if (== (maps.keys dunder) (maps.keys map))
                   (let [pruned (maps.remove #__exception__
                                             (maps.remove #__struct__ map))]
                     (inspect.Map.inspect pruned
                                          (inspect.Atom.inspect struct opts)
                                          opts)))))
      (catch
          (_ (inspect.Map.inspect map opts)))))
  )
