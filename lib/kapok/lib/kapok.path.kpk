(ns kapok.path
  """This module provides conveniences for manipulating or
  retrieving file system paths.

  The functions in this module may receive a char data as
  argument (i.e. a string or a list of characters / string)
  and will always returns a string (encoded in UTF-8).

  The majority of the functions in this module do not
  interact with the file system, except for a few functions
  that require it (like `wildcard/1` and `expand/1`).
  """

  (require binary
           file
           filelib
           (filename :as flnm)
           io_lib
           lists
           os
           unicode
           (kapok (alist
                   io
                   seq
                   system))))

;; defined at the beginning of this module because the module needs
;; to be compiled to call the macro `slash?` in `win32-pathtype`.
(defmacro slash? [c]
  `(in ~c [\/ \\]))

(defn- win32-pathtype [[list & rest]] (&when (list? list))
  (win32-pathtype (lists.append list rest)))
(defn- win32-pathtype [[char, list & rest]] (&when (list? list))
  (win32-pathtype [char & (lists.append list rest)]))
(defn- win32-pathtype [<<(c1) (c2) (relative :binary)>>]
  (&when (&and (slash? c1) (slash? c2)))
  {#absolute relative})
(defn- win32-pathtype [<<(c) (relative :binary)>>] (&when (slash? c))
  {#volumerelative relative})
(defn- win32-pathtype [<<(_letter) (\:) (c) (relative :binary)>>]
  (&when (slash? c))
  {#absolute relative})
(defn- win32-pathtype [<<(_letter) (\:) (relative :binary)>>]
  {#volumerelative relative})

(defn- win32-pathtype [[c1 c2 & relative]] (&when (&and (slash? c1) (slash? c2)))
  {#absolute relative})
(defn- win32-pathtype [[c & relative]] (&when (slash? c))
  {#volumerelative relative})
(defn- win32-pathtype [[c1 c2 list & rest]] (&when (list? list))
  (win32-pathtype [c1 c2 & (lists.append list rest)]))
(defn- win32-pathtype [[_letter \: c & relative]] (&when (slash? c))
  {#absolute relative})
(defn- win32-pathtype [[_letter \: & relative]]
  {#volumerelative relative})
(defn- win32-pathtype [relative]
  {#relative relative})

(defn absname [path]
  """Converts the given path to an absolute one. Unlike
  `expand/1`, no attempt is made to resolve `..`, `.` or `~`.

  ## Unix examples

      (path.absname "foo")
      ;;=> "/usr/local/foo"

      (path.absname "../x")
      ;;=> "/usr/local/../x"

  ## Windows

      (path.absname "foo")
      "D:/usr/local/foo"

      (path.absname "../x")
      "D:/usr/local/../x"

  """
  (absname path (system.cwd!)))

(defn absname [path relative-to]
  """Builds a path from `relative-to` to `path`. If `path` is already
  an absolute path, `relative-to` is ignored. See also `(relative-to 2)`.

  Unlike `(expand 2)`, no attempt is made to resolve `..`, `.` or `~`.

  ## Examples

      kapok> (path.absname "foo" "bar")
      "bar/foo"

      kapok> (path.absname "../x" "bar")
      "bar/../x"

  """
  (let [p (io.chardata-to-string path)]
    (case (type p)
      (:relative
       (absname-join relative-to p))
      (:absolute
       (absname-join [p]))
      (:volumerelative
       (let [new-relative-to (io.chardata-to-string relative-to)]
         (absname-vr (split p)
                     (split new-relative-to)
                     relative-to))))))

;; Absolute path on current drive
(defn- absname-vr [["/" & rest] [volume & _] _relative]
  (absname-join [volume & rest]))

;; Relative to current directory on current drive.
(defn- absname-vr [[<<(x) (\:)>> & rest] [<<(x) (_ :binary)>> & _] relative]
  (absname (absname-join rest) relative))

;; Relative to current directory on another drive.
(defn- absname-vr [[<<(x) (\:)>> & name] _ _relative]
  (let [cwd (case (file.get_cwd [x \:])
              ({#ok dir}
               (io.chardata-to-string dir))
              ({#error _}
               <<(x) (\:) (\/)>>))]
    (absname (absname-join name) cwd)))

;; Joins a list
(defn- absname-join [[name1 name2 & rest]]
  (absname-join [(absname-join name1 name2) & rest]))
(defn- absname-join [[name]]
  (do-absname-join (io.chardata-to-string name)
                   << >>
                   []
                   (major-os-type)))

;; Joins two paths
(defn- absname-join [left right]
  (do-absname-join (io.chardata-to-string left)
                   (relative right)
                   []
                   (major-os-type)))

;; (defn- do-absname-join [_ _ _ _]
;;   #ok)

(defn- do-absname-join [<<(uc-letter) (\:) (rest :binary)>> relativename [] #win32]
  (&when (&and (>= uc-letter \A) (<= uc-letter \Z)))
  (do-absname-join rest relativename [\: (- (+ uc-letter \a) \A)]  #win32))
(defn- do-absname-join [<<(\\) (rest :binary)>> relativename result #win32]
  (do-absname-join <<(\/) (rest :binary)>> relativename result #win32))
(defn- do-absname-join [<<(\/) (rest :binary)>> relativename [\. \/ & result] os-type]
  ;; TODO add impl
  (do-absname-join rest relativename [\/ & result] os-type))
(defn- do-absname-join [<<(\/) (rest :binary)>> relativename [\/ & result] os-type]
  (do-absname-join rest relativename [\/ & result] os-type))
(defn- do-absname-join [<<>> <<>> result os-type]
  (io.iodata-to-binary (reverse-maybe-remove-dirsep result os-type)))
(defn- do-absname-join [<<>> relativename [\/ & rest] #win32]
  (do-absname-join relativename <<>> [\: & rest] #win32))
(defn- do-absname-join [<<>> relativename [\/ & result] os-type]
  (do-absname-join relativename <<>> [\/ & result] os-type))
(defn- do-absname-join [<<>> relativename result os-type]
  (do-absname-join relativename <<>> [\/ & result] os-type))
(defn- do-absname-join [<<(char) (rest :binary)>> relativename result os-type]
  (do-absname-join rest relativename [char & result] os-type))

(defn- reverse-maybe-remove-dirsep [[\/ \: letter] #win32]
  [letter \: \/])
(defn- reverse-maybe-remove-dirsep [[\/] _]
  [\/])
(defn- reverse-maybe-remove-dirsep [[\/ & name] _]
  (lists.reverse name))
(defn- reverse-maybe-remove-dirsep [name _]
  (lists.reverse name))

(defn expand [path]
  """Converts the path to an absolute one and expands
  any `.` and `..` characters and a leading `~`.

  ## Examples

      kapok> (path.expand "/foo/bar/../bar")
      "/foo/bar"

  """
  (expand-dot (absname (expand-home path) (system.cwd!))))

(defn expand [path relative-to]
  """Expands the path relative to the path given as the second argument
  expanding any `.` and `..` characters. If the path is already an
  absolute path, `relative-to` ignored.

  Note, that this function treats `path` with a leading `~` as
  an absolute one.

  The second argument is first expanded to an absolute path.

  ## Examples

      # Assuming that the absolute path to baz is /quux/baz
      (path.expand "foo/bar/../bar" "baz")
      ;;=> "/quux/baz/foo/bar"

      (path.expand "foo/bar/../bar" "baz")
      "/baz/foo/bar"
      (path.expand "/foo/bar/../bar" "/baz")
      "/foo/bar"

  """
  (expand-dot (absname (absname (expand-home path) (expand-home relative-to))
                       (system.cwd!))))

(defn type [name] (&when (&or (list? name)
                              (binary? name)))
  """Returns the path type.

  ## Unix examples

      (path.type "/")                ;;=> #absolute
      (path.type "/usr/local/bin")   ;;=> #absolute
      (path.type "usr/local/bin")    ;;=> #relative
      (path.type "../usr/local/bin") ;;=> #relative
      (path.type "~/file")           ;;=> #relative

  ## Windows examples

      (path.type "D:/usr/local/bin") ;;=> #absolute
      (path.type "usr/local/bin")    ;;=> #relative
      (path.type "D:bar.kpk")        ;;=> #volumerelative
      (path.type "/bar/foo.kpk")     ;;=> #volumerelative

  """
  (-> (pathtype name (major-os-type))
      (elem 0)))

(defn relative [name]
  """Forces the path to be a relative path.

  ## Unix examples

      (path.relative "/usr/local/bin")   ;;=> "usr/local/bin"
      (path.relative "usr/local/bin")    ;;=> "usr/local/bin"
      (path.relative "../usr/local/bin") ;;=> "../usr/local/bin"

  ## Windows examples

      (path.relative "D:/usr/local/bin") ;;=> "usr/local/bin"
      (path.relative "usr/local/bin")    ;;=> "usr/local/bin"
      (path.relative "D:bar.kpk")        ;;=> "bar.kpk"
      (path.relative "/bar/foo.kpk")     ;;=> "bar/foo.kpk"

  """
  (relative name (major-os-type)))

(defn- relative [name os-type]
  (-> (pathtype name os-type)
      (elem 1)
      (io.chardata-to-string)))

(defn- pathtype [name os-type]
  (case os-type
    (#win32
     (win32-pathtype name))
    (_
     (unix-pathtype name))))

(defn- unix-pathtype [<< (\/) (relative :binary)>>]
  {#absolute relative})
(defn- unix-pathtype [[\/ & relative]]
  {#absolute relative})
(defn- unix-pathtype [[list & rest]] (&when (list? list))
  (unix-pathtype (lists.append list rest)))
(defn- unix-pathtype [relative]
  {#relative relative})

(defn relative-to [path from]
  """Returns the given `path` relative to the given `from` path.
  In other words, it tries to strip the `from` prefix from `path`.

  This function does not query the file system, so it assumes
  no symlinks between the paths.

  In case a direct relative path cannot be found, it returns
  the original path.

  ## Examples

      kapok> (path.relative-to "/usr/local/foo", "/usr/local")
      "foo"

      kapok> (path.relative-to "/usr/local/foo" "/")
      "usr/local/bin"

      kapok> (path.relative-to "/usr/local/foo" "/etc")
      "/usr/local/foo"

  """

  (let [p (io.chardata-to-string path)]
    (relative-to (split p) (split from) p)))

(defn- relative-to [[h & t1] [h & t2] original]
  (relative-to t1 t2 original))

(defn- relative-to [[_ & _] &as l1 [] _original]
  (join l1))

(defn- relative-to [_ _ original]
  original)

(defn relative-to-cwd [path]
  """Convenience to get the path relative to the current working
  directory. If for some reason, the current working directory
  cannot be retrieved, returns the full path.
  """
  (case (file.get_cwd)
    ({#ok base}
     (relative-to path (io.chardata-to-string base)))
    (_
     path)))

(defn basename [path]
  """Returns the last component of the path or the path
  itself if it does not contain any directory separators.

  ## Examples

      kapok> (path.basename "foo")
      "foo"

      kapok> (path.basename "foo/bar")
      "bar"

      kapok> (path.basename "/")
      ""

  """
  (flnm.basename (io.chardata-to-string path)))

(defn basename [path extension]
  """Returns the last component of `path` with the `extension`
  stripped. This function should be used to remove a specific
  extension which may, or may not, be there.

  ## Examples

      kapok> (path.basename "~/foo/bar.kpk" ".kpk")
      "bar"

      kapok> (path.basename "~/foo/bar.kpk" ".k")
      "bar.kpk"

      kapok> (path.basename "~/foo/bar.old.kpk" ".kpk")
      "bar.old"

  """
  (flnm.basename (io.chardata-to-string path)
                 (io.chardata-to-string extension)))

(defn dirname [path]
  """Returns the directory component of `path`.

  ## Examples

      (path.dirname "/foo/bar.kpk")
      ;;=> "/foo"
      (path.dirname "/foo/bar/baz.kpk")
      ;;=> "/foo/bar"

  """
  (flnm.dirname (io.chardata-to-string path)))

(defn extname [path]
  """Returns the extension of the last component of `path`.

  ## Examples

      kapok> (path.extname "foo.erl")
      ".erl"

      kapok> (path.extname "~/foo/bar")
      ""

  """
  (flnm.extension (io.chardata-to-string path)))

(defn rootname [path]
  """Returns the `path` with the extension stripped.

  ## Examples

      kapok> (path.rootname "/foo/bar")
      "/foo/bar"

      kapok> (path.rootname "/foo/bar.kpk")
      "/foo/bar"

  """
  (flnm.rootname (io.chardata-to-string path)))

(defn rootname [path extension]
  """Returns the `path` with the `extension` stripped.
  This function should be used to remove a specific extension
  which might, or might not, be there.

  ## Examples

      kapok> (path.rootname "/foo/bar.erl" ".erl")
      "/foo/bar"

      kapok> (path.rootname "/foo/bar.erl" ".kpk")
      "/foo/bar.erl"

  """
  (flnm.rootname (io.chardata-to-string path)
                 (io.chardata-to-string extension)))

(defn join
  """Joins a list of strings.

  This function should be used to convert a list of strings to a path.
  Note that any trailing slash is removed on join.

  ## Examples

      kapok> (path.join ["~" "foo"])
      "~/foo"

      kapok> (path.join ["foo"])
      "foo"

      kapok> (path.join ["/" "foo" "bar"])
      "/foo/bar"

  """
  ([[name1 name2 & rest]]
   (join [(join name1 name2) & rest]))

  ([name]
   name)
  )

(defn join [left right]
  """Joins two paths.

  The right path will always be expanded to its relative format
  and any trailing slash is removed on join.

  ## Examples

      kapok> (path.join "foo" "bar")
      "foo/bar"

  """
  (let [l (io.chardata-to-string left)
        os-type (major-os-type)]
    (-> (do-join l right os-type)
        (remove-dirsep os-type))))

(defn- do-join ["" right os-type]
  (relative right os-type))
(defn- do-join [left "" _os-type]
  (left))
(defn- do-join [left right os-type]
  (io_lib.format "~s/~s" [(remove-dirsep left os-type)
                          (relative right os-type)]))

(defn- remove-dirsep ["" _os-type]
  "")
(defn- remove-dirsep [bin os-type]
  (let [last (binary.last bin)]
    (if (or (== last \/)
            (and (== last \\)
                 (== os-type #win32)))
        (binary-part bin 0 (dec (byte-size bin)))
      bin)))

(defn split
  """Splits the path into a list at the path separator.

  If an empty string is given, returns an empty list.

  On Windows, path is split on both "\" and "/" separators
  and the driver letter, if there is one, is always returned
  in lowercase.

  ## Examples

     kapok> (path.split "")
     []

     kapok> (path.split "foo")
     ["foo"]

     kapok> (path.split "/foo/bar")
     ["/" "foo" "bar"]

  """

  ;; Work around a bug in Erlang on UNIX
  ([""]
   [])

  ([path]
   (flnm.split (io.chardata-to-string path))))

(defns kapok.path.wildcard
  ((require erlang
            gen_server
            (kapok (seq))))

  (defn read-link-info [file]
    (call {#read_link_info file}))

  ;; for compatibility with buggy Erlang 17.1.
  (defn read-file-info [file]
    (call {#read_link_info file}))

  (defn list-dir [dir]
    (case (call {#list_dir dir})
      ({#ok files}
       (let [r (seq.filter files (fn [f] (!= (head f) \.)))]
         {#ok r}))
      (other
       other)))

  (defn- call [tuple]
    (let [x (erlang.dt_spread_tag :true)
          y (gen_server.call #file_server_2 tuple)]
      (erlang.dt_restore_tag x)
      y))
  )

(defn wildcard [glob &optional (opts [])]
  """Traverses paths according to the given `glob` expression, and returns
  a list of matches.

  The wildcard looks like an ordinary path, except that certain
  "wildcard characters"  are interpreted in a special way. The following
  characters are special:

    * `?` - matches one character

    * `*` - matches any number of characters up to the end of the filename,
      the next dot, or the next slash

    * `**` - two adjacent `*`'s used as a single pattern will match all
      files and zero or more directories and subdirectories

    * `[char1 char2 ...]` - matches any of the characters listed; two
      characters separated by a hyphen will match a range of characters

    * `{item1 item2 ...}` - matches one of the alternatives

  Other characters represent themselves. Only paths that have
  exactly the same character in the same position will match. Note
  that matching is case-sensitive; i.e. "a" will not match "A".

  By default, the patterns `*` and `?` do not match files starting
  with a dot `.` unless `{#match_dot :true}` is given in `opts`.

  ## Examples

  Imagine you have a directory called `projects` with three Kapok projects
  inside of it: `kapok`, `kapok-doc` and `kunit`. You can find all `.beam` files
  inside the `ebin` directory of each project as follows:

      (path.wildcard "projects/*/ebin/**/*.beam")

  If you want to search for both `.beam` and `.app` files, you could do

      (path.wildcard "projects/*/ebin/**/*.{beam,app}")

  """

  (let [mod (if (alist.get opts #match_dot)
                #file
                #'kapok.path.wildcard')]
    (-> glob
        chardata-to-list
        (filelib.wildcard mod)
        (seq.map (fn io chardata-to-list 1)))))


;; expand-dot the given path by expanding "..", "." and "~"

(defn- chardata-to-list [chardata]
  (case (unicode.characters_to_list chardata)
    (result (&when (list? result))
     result)
    ({#error _encoded _rest}
     ;; TODO revise to use exception
     (throw "unicode conversion error"))
    ({#incomplete _encoded _rest}
     ;; TODO revise to use exception
     (throw "unicode conversion incomplete error"))))

(defn- expand-home [type]
  (case (io.chardata-to-string type)
    (<<("~") (rest)>>
       (resolve-home rest))
    (rest
     rest)))

(defn- resolve-home [""]
  (system.user-home!))

(defn- resolve-home [rest]
  (case {rest (major-os-type)}
    ({<<("\\") (_)>> #win32}
     <<((system.user-home!)) (rest)>>)
    ({<<("/") (_)>> _}
     <<((system.user-home!)) (rest)>>)
    (_
     rest)))

(defn- expand-dot [<<("/../") (rest :binary)>>]
  (expand-dot <<("/") (rest)>>))
(defn- expand-dot [<<(letter) (":/../") (rest :binary)>>]
    (&when (&and (>= letter \a) (<= letter \z)))
  (expand-dot <<(letter) (":/") (rest :binary)>>))
(defn- expand-dot ["/.."]
  "/")
(defn- expand-dot [<<(letter) (":/..")>>] (&when (&and (>= letter \a)
                                                       (<= letter \z)))
  (expand-dot <<(letter) (":/")>>))
(defn- expand-dot [path]
  (expand-dot (binary.split path "/" [#global]) []))

(defn- expand-dot [[".." & t] [_ _ & acc]]
  (expand-dot t acc))
(defn- expand-dot [["." & t] acc]
  (expand-dot t acc))
(defn- expand-dot [[h & t] acc]
  (expand-dot t ["/" h & acc]))
(defn- expand-dot [[] ["/" & acc]]
  (io.iodata-to-binary (lists.reverse acc)))

(defn- major-os-type []
  (-> (os.type)
      (elem 0)))
