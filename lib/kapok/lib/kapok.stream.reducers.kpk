;; Collection of reducers shared by seq and stream.
(ns kapok.stream.reducers
  (require gb_sets))

(defmacro chunk [n step limit &optional f]
  `(fn [entry (acc h {b c} t)]
     (let [buffer [entry & b]
           count (inc c)
           new (if (>= count ~limit)
                   (do
                    (let [left (- count ~step)]
                      {(kapok.seq.#take buffer left) left}))
                 {buffer count})]
       (if (=== count ~n)
           (next-with-acc ~f (#lists.#reverse buffer) h new t)
           (skip (acc h new t))))))

(defmacro chunk-by [callback &optional f]
  `(fn
     ([entry (acc h {buffer value} t)]
      (let [new-value (~callback entry)]
        (if (== new-value value)
            (skip (acc h {[entry & buffer] value} t))
          (next-with-acc ~f (#lists.#reverse buffer) h {[entry] new-value} t))))
     ([entry (acc h :nil t)]
      (skip (acc h {[entry] (~callback entry)} t))))
  )

(defmacro dedup [callback &optional f]
  `(fn [entry (acc h prev t) &as acc]
     (let [value (~callback entry)]
       (case prev
         ({#value value} (skip acc))
         (_ (next-with-acc ~f entry h {#value value} t))))))


(defmacro drop [&optional (f :nil)]
  `(fn
     ([_entry (acc h n0 t)] (&when (> n0 0))
      (skip (acc h (dec n0) t)))
     ([entry (acc h n0 t)]
      (next-with-acc ~f entry h n0 t))))

(defmacro drop-while [callback &optional f]
  `(fn [entry (acc h bool t) &as orig]
     (if (and bool
              (~callback entry))
         (skip orig)
         (next-with-acc ~f entry h :false t))))

(defmacro filter [callback &optional f]
  `(fn [entry acc]
     (if (~callback entry)
         (next ~f entry acc)
       (skip acc))))

(defmacro filter-map [filter mapper &optional f]
  `(fn [entry acc]
     (if (~filter entry)
         (next ~f (~mapper entry) acc)
       (skip acc))))

(defmacro map [callback &optional f]
  `(fn [entry acc]
     (next ~f (~callback entry) acc)))

(defmacro reject [callback &optional f]
  `(fn [entry acc]
     (if-not (~callback entry)
             (next ~f entry acc)
       (skip acc))))

(defmacro scan-2 [callback &optional f]
  `(fn
     ([entry (acc h #first t)]
      (next-with-acc ~f entry h {#ok entry} t))
     ([entry (acc h {#ok acc} t)]
      (let [value (~callback entry acc)]
        (next-with-acc ~f value h {#ok value} t)))))

(defmacro scan-3 [callback &optional f]
  `(fn [entry (acc h acc0 t)]
     (let [value (~callback entry acc0)]
       (next-with-acc ~f value h value t))))

(defmacro take [&optional f]
  `(fn [entry (acc h n0 t) &as orig]
     (if (>= n0 1)
         (next-with-acc ~f entry h (dec n0) t)
       {#halt orig})))

(defmacro take-every [nth &optional f]
  `(fn
     ([entry (acc h n0 t)] (&when (&or (=== n0 #first)
                                      (=== n0 ~nth)))
      (next-with-acc ~f entry h 1 t))
     ([_entry (acc h n0 t)]
      (skip (acc h (inc n0) t)))))

(defmacro take-while [callback &optional f]
  `(fn [entry acc]
     (if (~callback entry)
         (next ~f entry acc)
       {#halt acc})))

(defmacro uniq [callback &optional f]
  `(fn [entry (acc h prev t) &as acc]
     (let [value (~callback entry)]
       ;; TODO revise to use hash set
       (if (#gb_sets.#is_member value prev)
           (skip acc)
         (next-with-acc ~f entry h (#gb_sets.#add value prev) t)))))

(defmacro with-index [&optional f]
  `(fn [entry (acc h counter t)]
     (next-with-acc ~f {entry counter} h (inc counter) t)))
