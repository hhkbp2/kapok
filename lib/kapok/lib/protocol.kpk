;;; Functions and macros for protocol.
;; -*- Kapok -*-

(ns protocol
  ;; need to use `core' explicitly since core libs
  ;; are not automatically imported or used when compiled.
  (use core)
  (require kapok_error maps erlang lists))

(defmacro string? [category]
  `(&or (=== ~category ^list_string)
        (=== ~category ^binary_string)))

(defmacro struct-field? [category]
  `(&or (=== ~category ^keyword)
        (=== ~category ^atom)))

(defmacro def? [id]
  `(&or (=== ~id ^defn)
        (=== ~id ^defn-)
        (=== ~id ^defmacro)
        (=== ~id ^defalias)
        (=== ~id ^defalias-)))

(defn- handle-defstruct-fields [file args]
  (lists.map (fn
               ([{c id-meta id-name}] (&when (struct-field? c))
                {{^keyword id-meta id-name} {^atom id-meta ^nil}})
               ([{^list _ [{c id-meta id-name} expr]}] (&when (struct-field? c))
                {{^keyword id-meta id-name} expr})
               ([{_ meta _}]
                (kapok_error.compile_error meta file "invalid field arg for defstruct")))
             args))

(defn- handle-defstruct [file meta _doc args]
  (let [fields (handle-defstruct-fields file args)
        fields-list (lists.reverse (lists.foldl (fn [{k, v} acc]
                                                  [v k & acc])
                                                []
                                                fields))]
    {^list meta [{^identifier meta ^defn}
                 {^identifier meta ^'__struct__'}
                 {^literal_list meta []}
                 {^map meta fields-list}]}))

(defmacro defstruct [&rest args]
  """Define a struct."""
  (let [meta (maps.get ^meta _&ctx)
        file (maps.get ^file _&ctx)]
    (case args
      ([] (kapok_error.compile_error meta file "not enough arguments to define struct"))
      ([{c _ _} &as doc & t] (&when (string? c))
       (handle-defstruct file meta doc t))
      (t (handle-defstruct file meta (empty-doc) t)))))

(defn- handle-defprotocol-clause [meta
                          {_ protocol-meta protocol-name}
                          {_ id-meta id-name} &as id
                          {_ _ args-list} &as args]
  {^list meta [{^identifier id-meta ^defn} id args
               {^list meta [{^dot meta {^protocol ^protocol-impl}}
                            {^atom protocol-meta protocol-name}
                            {^atom id-meta id-name}
                            & args-list]}]})

(defn- handle-defprotocol-clause [{file meta} protocol clause]
  (case clause
    ([{^identifier _ _} &as id {^literal_list _ _} &as args {c _ _}]
     (&when (string? c))
     ;; TODO add doc
     (handle-defprotocol-clause meta protocol id args))
    ([{^identifier _ _} &as id {^literal_list _ _} &as args]
     (handle-defprotocol-clause meta protocol id args))
    (_ (kapok_error.compile_error meta file "invalid clause args for defprotocol"))))

(defn- handle-defprotocol [file meta id doc clauses acc]
  (case clauses
    ([]
     (let [defs (lists.reverse acc)]
       {^list meta [{^identifier meta ^defns}
                    id
                    doc
                    {^list meta []} & defs]}))
    ([{^list clause-meta clause} & t]
     (let [handled (handle-defprotocol-clause {file clause-meta} id clause)]
       (handle-defprotocol file meta id doc t [handled & acc])))
    ([{_c clause-meta _} & _t]
     (kapok_error.compile_error clause-meta file "invalid clause for defprotocol"))))

(defn- handle-defprotocol [file meta id doc clauses]
  (handle-defprotocol file meta id doc clauses []))

(defmacro defprotocol [id &rest args]
  """Define a protocol."""
  (let [meta (maps.get ^meta _&ctx)
        file (maps.get ^file _&ctx)]
    (case id
      ({c _ _} (&when (=== c ^identifier))
       (case args
         ([] (kapok_error.compile_error meta file "not enough arguments to define protocol"))
         ([{c1 _ _} &as doc & t] (&when (&or (=== c1 ^list_string)
                                             (=== c1 ^binary_string)))
          (handle-defprotocol file meta id doc t))
         (t (handle-defprotocol file meta id (empty-doc) t))))
      (_ (kapok_error.compile_error meta file "invalid id for defprotocol: ~p" [id])))))

(defn- handle-defimpl-clause [{file meta} clause]
  (case clause
    ([{^identifier _ id} & _t] (&when (&or (=== id ^require)
                                           (=== id ^use)))
     {^ns {^list meta clause}})
    ([{^identifier _ id} {^identifier _ _} {^literal_list _ _} & _t] (&when (def? id))
     ;; TODO check the impl defn matches the defprotocol declaration
     {^def {^list meta clause}})
    (_ (kapok_error.compile_error meta file "invalid clause for defimpl: ~p" [clause]))))

(defn- handle-defimpl [file meta protocol type doc defs {ns-acc defn-acc}]
  (let [{_ protocol-meta protocol-name} protocol
        {_ _ type-name} type]
    (case defs
      ([]
       (let [ns-all (lists.reverse ns-acc)
             defn-all (lists.reverse defn-acc)
             p-name (erlang.atom_to_list protocol-name)
             t-name (erlang.atom_to_list type-name)
             module-name (erlang.list_to_atom
                          (lists.append p-name (lists.append #"." t-name)))]
         {^list meta [{^identifier meta ^defns}
                      {^identifier protocol-meta module-name}
                      doc
                      {^list protocol-meta ns-all} & defn-all]}))
      ([{^list clause-meta clause} & t]
       (case (handle-defimpl-clause {file clause-meta} clause)
         ({^ns handled-ns}
          (handle-defimpl file meta protocol type doc t {[handled-ns & ns-acc] defn-acc}))
         ({^def handled-def}
          (handle-defimpl file meta protocol type doc t {ns-acc [handled-def & defn-acc]}))))
      ([{_c clause-meta _} &as def & _t]
       (kapok_error.compile_error clause-meta file "invalid clause for defimpl: ~p" [def])))))

(defn- handle-defimpl [file meta protocol type doc defs]
  (handle-defimpl file meta protocol type doc defs {[], []}))

(defmacro defimpl [protocol type &rest args]
  """Implement a protocol for the specified type."""
  ;; TODO check type is valid
  (let [meta (maps.get ^meta _&ctx)
        file (maps.get ^file _&ctx)]
    (case protocol
      ({c _ _} (&when (=== c ^identifier))
       (case args
         ([] (kapok_error.compile_error meta file "not enough arguments to implement protocol"))
         ([{c _ _} &as doc & t] (&when (&or (=== c ^list_string)
                                            (=== c ^binary_string)))
          (handle-defimpl file meta protocol type doc t))
         (t (handle-defimpl file meta protocol type (empty-doc) t)))
       )
      (_ (kapok_error.compile_error meta file "invalid protocol for defimpl: ~p" [protocol])))))

(defn- type-of [self] (&when (atom? self))
  ^atom)
(defn- type-of [self] (&when (bitstring? self))
  ^bitstring)
(defn- type-of [self] (&when (float? self))
  ^float)
(defn- type-of [self] (&when (integer? self))
  ^integer)
(defn- type-of [self] (&when (list? self))
  ^list)
(defn- type-of [self] (&when (map? self))
  ^map)
(defn- type-of [self] (&when (tuple? self))
  ^tuple)
;; TODO add clause for struct

(defn protocol-impl [protocol f self &rest args]
  (let [type (type-of self)
        protocol-name (erlang.atom_to_list protocol)
        type-name (erlang.atom_to_list type)
        module (erlang.list_to_atom (lists.append protocol-name (lists.append #"." type-name)))]
    (erlang.apply module f [self & args]))
  )
