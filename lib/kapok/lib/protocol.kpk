;;; Functions and macros for protocol.
;; -*- Kapok -*-

(ns protocol
  ;; need to use `core' explicitly since core libs
  ;; are not automatically imported or used when compiled.
  (use core)
  (require kapok_error
           kapok_parser
           erlang
           maps
           lists))

(defmacro string? [category]
  `(&or (=== ~category #list_string)
        (=== ~category #binary_string)))

(defmacro dot-id? [category]
  `(&or (=== ~category #dot)
        (=== ~category #identifier)))

(defmacro struct-field? [category]
  `(&or (=== ~category #keyword)
        (=== ~category #atom)))

(defmacro def? [id]
  `(&or (=== ~id #defn)
        (=== ~id #defn-)
        (=== ~id #defmacro)
        (=== ~id #defalias)
        (=== ~id #defalias-)))

(defn- validate-field-name [file meta name]
  (case name
    (#__struct__
     (kapok_error.compile_error meta file "invalid field name \"__struct__\""))
    (_
     name)))

(defn- handle-defstruct-fields [file meta args]
  (let [handler (fn
                  ([{c id-meta id-name}] (&when (struct-field? c))
                   (let [name (validate-field-name file id-meta id-name)]
                     {{#keyword id-meta name} {#atom id-meta #nil}}))
                  ([{#list _ [{c id-meta id-name} expr]}] (&when (struct-field? c))
                   (let [name (validate-field-name file id-meta id-name)]
                     {{#keyword id-meta name} expr}))
                  ([{_ ast-meta _}]
                   (kapok_error.compile_error ast-meta file "invalid field arg for defstruct")))
        fields (lists.map handler args)
        tag {{#keyword meta #__struct__}
             {#list meta [{#identifier meta #__MODULE__}]}}]
    [tag & fields]))

(defn- elixir-struct-constructor [meta name fields-list]
  {#list meta [{#identifier meta #defn}
               {#identifier meta name}
               {#literal_list meta []}
               {#map meta fields-list}]}
  )

(defn- struct-constructor [meta name no-tag-fields]
  (let [{list1 list2} (lists.foldl
                       (fn [{{_ k-meta k-name} &as k v} {args-acc vars-acc}]
                         (let [var {#identifier k-meta k-name}
                               arg-pair {#list k-meta [var v]}]
                           {[arg-pair & args-acc]
                            [var k & vars-acc]}))
                       {[] []}
                       no-tag-fields)
        key-args (lists.reverse list1)
        map-fields (lists.reverse list2)
        arguments [{#keyword_key meta #'&key'} & key-args]]
    {#list meta [{#identifier meta #defn}
                 {#identifier meta name}
                 {#literal_list meta arguments}
                 {#map meta map-fields}]}))

(defn- struct-get []
  '(defn get [self key &optional (default :nil)]
     (maps.get key self default)))

(defn- struct-is-key []
  '(defn is-key [self key]
     (maps.is_key key self)))

(defn- struct-keys []
  '(defn keys [self]
     (maps.keys self)))

(defn- struct-put []
  '(defn get [self key value]
     (maps.put key value self)))

(defn- struct-to-list []
  '(defn to-list [self]
     (maps.to-list self)))

(defn- struct-values []
  '(defn values [self]
     (maps.values self)))

(defn- struct-accessors [_meta _no-tag-fields]
  [(struct-get)
   (struct-is-key)
   (struct-keys)
   (struct-put)
   (struct-to-list)
   (struct-values)
   ])

(defn- handle-defstruct [file meta _doc args]
  (let [fields (handle-defstruct-fields file meta args)
        fields-list (lists.reverse (lists.foldl (fn [{k v} acc]
                                                  [v k & acc])
                                                []
                                                fields))]
    ;; Returns a list of asts since we need two duplicate functions,
    ;; 1. '__struct__' is for being compactible with elixir protocol
    ;; 2. 'new' is for the kapok struct constructor
    [(elixir-struct-constructor meta #'__struct__' fields-list)
     (struct-constructor meta #'new' (next fields)) &
     (struct-accessors meta (next fields))]))

(defmacro defstruct [&rest args]
  """Define a struct."""
  (let [meta (maps.get #meta _&ctx)
        file (maps.get #file _&ctx)]
    (case args
      ([] (kapok_error.compile_error meta file "not enough arguments to define struct"))
      ([{c _ _} &as doc & t] (&when (string? c))
       (handle-defstruct file meta doc t))
      (t (handle-defstruct file meta (empty-doc) t)))))

(defn- handle-defprotocol-clause [meta
                          {_ protocol-meta protocol-name}
                          {_ id-meta id-name} &as id
                          {_ _ args-list} &as args]
  {#list meta [{#identifier id-meta #defn} id args
               {#list meta [{#dot meta {#protocol #protocol-impl}}
                            {#atom protocol-meta protocol-name}
                            {#atom id-meta id-name}
                            & args-list]}]})

(defn- handle-defprotocol-clause [{file meta} protocol clause]
  (case clause
    ([{#identifier _ _} &as id {#literal_list _ _} &as args {c _ _}]
     (&when (string? c))
     ;; TODO add doc
     (handle-defprotocol-clause meta protocol id args))
    ([{#identifier _ _} &as id {#literal_list _ _} &as args]
     (handle-defprotocol-clause meta protocol id args))
    (_ (kapok_error.compile_error meta file "invalid clause args for defprotocol: ~p" [clause]))))

(defn- handle-defprotocol [file meta id doc clauses acc]
  (case clauses
    ([]
     (let [defs (lists.reverse acc)]
       {#list meta [{#identifier meta #defns}
                    id
                    doc
                    {#list meta []} & defs]}))
    ([{#list clause-meta clause} & t]
     (let [handled (handle-defprotocol-clause {file clause-meta} id clause)]
       (handle-defprotocol file meta id doc t [handled & acc])))
    ([{_c clause-meta _} & _t]
     (kapok_error.compile_error clause-meta file "invalid clause for defprotocol: ~p" [clauses]))))

(defn- handle-defprotocol [file meta id doc clauses]
  (handle-defprotocol file meta id doc clauses []))

(defmacro defprotocol [id &rest args]
  """Define a protocol."""
  (let [meta (maps.get #meta _&ctx)
        file (maps.get #file _&ctx)]
    (case id
      ({c _ _} (&when (dot-id? c))
       (case args
         ([] (kapok_error.compile_error meta file "not enough arguments to define protocol"))
         ([{c1 _ _} &as doc & t] (&when (&or (=== c1 #list_string)
                                             (=== c1 #binary_string)))
          (handle-defprotocol file meta id doc t))
         (t (handle-defprotocol file meta id (empty-doc) t))))
      (_ (kapok_error.compile_error meta file "invalid id for defprotocol: ~p" [id])))))

(defn- handle-defimpl-clause [{file meta} clause]
  (case clause
    ([{#identifier _ id} & _t] (&when (&or (=== id #require)
                                           (=== id #use)))
     {#ns {#list meta clause}})
    ([{#identifier _ id} {#identifier _ _} {#literal_list _ _} & _t] (&when (def? id))
     ;; TODO check the impl defn matches the defprotocol declaration
     {#def {#list meta clause}})
    (_ (kapok_error.compile_error meta file "invalid clause for defimpl: ~p" [clause]))))

(defn- handle-defimpl [file meta protocol type doc defs {ns-acc defn-acc}]
  (let [{_ protocol-meta _} protocol
        {_ _ type-name} type]
    (case defs
      ([]
       (let [ns-all (lists.reverse ns-acc)
             defn-all (lists.reverse defn-acc)
             p-name (erlang.atom_to_list (kapok_parser.dot_id_name protocol))
             t-name (erlang.atom_to_list type-name)
             module-name (erlang.list_to_atom
                          (lists.append p-name (lists.append #"." t-name)))]
         {#list meta [{#identifier meta #defns}
                      {#identifier protocol-meta module-name}
                      doc
                      {#list protocol-meta ns-all} & defn-all]}))
      ([{#list clause-meta clause} & t]
       (case (handle-defimpl-clause {file clause-meta} clause)
         ({#ns handled-ns}
          (handle-defimpl file meta protocol type doc t {[handled-ns & ns-acc] defn-acc}))
         ({#def handled-def}
          (handle-defimpl file meta protocol type doc t {ns-acc [handled-def & defn-acc]}))))
      ([{_c clause-meta _} &as def & _t]
       (kapok_error.compile_error clause-meta file "invalid clause for defimpl: ~p" [def])))))

(defn- handle-defimpl [file meta protocol type doc defs]
  (handle-defimpl file meta protocol type doc defs {[] []}))

(defmacro defimpl [protocol type &rest args]
  """Implement a protocol for the specified type."""
  ;; TODO check type is valid
  (let [meta (maps.get #meta _&ctx)
        file (maps.get #file _&ctx)]
    (case protocol
      ({c _ _} (&when (dot-id? c))
       (case args
         ([] (kapok_error.compile_error meta file "not enough arguments to implement protocol"))
         ([{c _ _} &as doc & t] (&when (&or (=== c #list_string)
                                            (=== c #binary_string)))
          (handle-defimpl file meta protocol type doc t))
         (t (handle-defimpl file meta protocol type (empty-doc) t)))
       )
      (_ (kapok_error.compile_error meta file "invalid protocol for defimpl: ~p" [protocol])))))

(defn- type-of [self] (&when (atom? self))
  #atom)
(defn- type-of [self] (&when (bitstring? self))
  #bitstring)
(defn- type-of [self] (&when (float? self))
  #float)
(defn- type-of [self] (&when (integer? self))
  #integer)
(defn- type-of [self] (&when (list? self))
  #list)
(defn- type-of [self] (&when (map? self))
  #map)
(defn- type-of [self] (&when (tuple? self))
  #tuple)
;; TODO add clause for struct

(defn protocol-impl [protocol f self &rest args]
  (let [type (type-of self)
        protocol-name (erlang.atom_to_list protocol)
        type-name (erlang.atom_to_list type)
        module (erlang.list_to_atom (lists.append protocol-name (lists.append #"." type-name)))]
    (erlang.apply module f [self & args]))
  )
