(ns kapok.record.extractor

  (require code
           filename
           epp
           io_lib
           lists
           (kapok (list
                   seq
                   string)))
  )

;; Retrieve a record definition from an Erlang file using
;; the same lookup as the *include* attribute from Erlang modules.
(defn extract [name [{#from file}]] (&when (binary? file))
  (extract-record name (from-file file)))

;; Retrieve a record definition from an Erlang file using
;; the same lookup as the *include_lib* attribute from Erlang modules.
(defn extract [name [{#from_lib file}]] (&when (binary? file))
      (extract-record name (from-lib-file file)))

;; Retrieve all records definitions from an Erlang file using
;; the same lookup as the *include* attribute from Erlang modules.
(defn extract-all [[{#from file}]] (&when (binary? file))
  (extract-all-records (from-file file)))

;; Retrieve all records definitions from an Erlang file using
;; the same lookup as the *include_lib* attribute from Erlang modules.
(defn extract-all [{#from_lib file}] (&when (binary? file))
  (extract-all-records (from-lib-file file)))

;; Find file using the same lookup as the *include* attribute from
;; Erlang modules.
(defn- from-file [file]
  (let [file1 (string.to-char-list file)]
    (case (code.where_is_file file1)
      (#non_existing
       file1)
      (realfile
       realfile))))

;; Find file using the same lookup as the *include_lib* attribute from
;; Erlang modules.
(defn- from-lib-file [file]
  (let [[app & path] (filename.split (string.to-char-list file))]
    (case (code.lib_dir (list.to-atom app))
      ({#error _}
       (let [message (io_lib.format "lib file ~p could not be found" [file])]
         (raise kapok.argument-error message)))
      (libpath
       (filename.join [libpath & path])))))

;; Retrieve the record with the given name from the given file
(defn- extract-record [name file]
  (let [form (read-file file)
        records (extract-records form)
        record (list.keyfind records name 0)]
    (if record
        (parse-record record form)
      (let [message (io_lib.format "no record ~p found at ~p" [name file])]
        (raise kapok.argument-error message)))))

;; Retrieve all records from the given file
(defn- extract-all-records [file]
  (let [form (read-file file)
        records (extract-records form)]
    (seq.map records
             (fn [{name _fields} &as rec]
               {name (parse-record rec form)}))))

;; Parse the given file and extract all existent records.
(defn- extract-records [form]
  (seq.map form
           (fn [{#attribute _ #record record}]
             record)))

;; Read a file and return its abstract syntax form also
;; includes record but with macros and other attributes expanded,
;; such as `-include(...)` and `-include_lib(...)`. This is done
;; by using Erlang's epp.
(defn- read-file [file]
  (case (epp.parse_file file [])
    ({#ok form}
     form)
    (other
     (let [message (io_lib.format "error parsing file ~p, got: ~p"
                                  [file other])]
       (raise message)))))

;; Parse a tuple with name and fields and returns a
;; list of tuples where the first element is the field
;; and the second is its default value.
(defn- parse-record [{_name fields} form]
  (let [cons (list.foldr fields
                         {:nil 0}
                         (fn [f acc]
                           {#cons 0 (parse-field f) acc}))]
    (eval-record cons form)))

(defn- parse-field [{#typed_record_field record-field _type}]
  (parse-field record-field))

(defn- parse-field [{#record_field _ key value}]
  {#tuple 0 [key, value]})

(defn- eval-record [cons form]
  (let [form1 (lists.append form
                            [{#function 0 #hello 0
                              [{#clause 0 [] [] [cons]}]}])
        {#function 0 #hello 0
         [{#clause 0 [] [] [record-ast]}]} (-> (erl_expand_records.module form1 [])
                                               list.last)
        {#value record _} (erl_eval.expr record-ast [])]
    record))
