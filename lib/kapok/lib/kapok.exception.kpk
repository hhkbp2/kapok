(defns kapok.exception
  """Functions to format throw/catch/exit and exceptions.

  Note that stacktraces in Kapok are updated on throw,
  errors and exits. For example, at any given moment,
  `(Elixir.System.stackstrace 0)` will return the stacktrace for
  the last throw/error/exit that occurred in the current process.

  Do not rely on the particular format returned by the `format`
  functions in this module. They may be changed in future releases
  in order to better suit Kapok's tool chain. In other words,
  by using the functions in this module it is guaranteed you will
  format exceptions as in the current Kapok version being used.
  """

  ((require application
            code
            maps
            (Elixir.Symstem :as system)
            (Elixir.Process :as process)
            (Elixir.IO :as io)
            (Elixir.Enum :as seq)
            (Elixir.Keyword :as alist))
   (require (kapok (access)))
   (use (io_lib :only (format))))

  ;; behaviour definition

  (defn behaviour_info [#callbacks]
    [{#exception 1}
     {#message 1}])
  (defn behaviour_info [_]
    #undefined)

;; functions

  (defn exception?
    "Returns `:true` if the given argument is an exception."

    ([#{:__struct__ struct
        :__exception__ :true}] (&when (atom? struct))
     :true)

    ([_]
     :false))

  (defn
      #{:check_remote_call :false}
      message [#{#__struct__ module
                 #__exception__ :true} &as exception] (&when (atom? module))
    "Gets the message for an exception."
    (try (module.message exception)
      ((x (&when (binary? x))
        x)
       (x
        (format "got ~s while retrieving (exception.message 1) for ~s (expected a string)"
                [(inspect x) (inspect exception)])))
      (catch
        (e (format
            "got ~s with message ~s while retrieving (exception.message 1) for ~s"
            [(inspect (access.get e #__struct__))
             (message e)
             (inspect exception)])))))

  (defn
      #{:check_remote_call :false}
      normalize
    """Normalizes an exception, converting Erlang exceptions
    to Kapok exceptions.

    It takes the `kind` spilled by `catch` as an argument and
    normalizes only `#error`, returning the untouched payload
    for others.

    The third argument, a stacktrace, is optional. If it is
    not supplied `(Elixir.System.stacktrace 0)` will sometimes be used
    to get additional information for the `kind` `#error`. If
    the stacktrace is unknown and `(Elixir.system.stacktrace 0)` would
    not return the stacktrace corresponding to the exception
    an empty stacktrace, `[]`, must be used.
    """

    ([kind payload]
     ;; Generating a stacktrace is expensive, default to nil
     ;; to only fetch it when needed.
     (normalize kind payload :nil))

    ([#error exception stacktrace]
     (if (exception? exception)
         exception
       (kapok.erlang-error.normalize exception stacktrace)))

    ([_kind payload _stacktrace]
     payload))


  (defn
      #{:check_remote_call :false}
      format-banner
    """Normalizes and formats any throw, error and exit.

    The message is formatted and displayed in the same
    format as used by Kapok's CLI.

    The third argument, a stacktrace, is optional. If it is
    not supplied `(Elixir.system.stacktrace 0)` will sometimes be used
    to get additional information for the `kind` `#error`. If
    the stacktrace is unknown and `(Elixir.system.stacktrace 0)` would
    not return the stacktrace corresponding to the exception
    an empty stacktrace, `[]`, must be used.
    """

    ([kind exception]
     (format-banner kind exception :nil))

    ([#error exception stacktrace]
     (let [e (normalize #error exception stacktrace)]
       (format "** (~s) ~s" [(inspect (access.get exception #__struct__))
                             (message e)])))

    ([#throw reason _stacktrace]
     (format "** (throw) ~s" [(inspect reason)]))

    ([#exit reason _stacktrace]
     (format "** (exit) ~s" [(format-exit reason "\n    ")]))

    ([{#EXIT pid} reason _stacktrace]
     (format "** (EXIT from ~s) ~s" [(inspect pid)
                                     (format-exit reason "\n    ")])))

  (defn
      #{:check_remote_call :false}
      format
    """Normalizes and formats throw/errors/exits and stacktrace.

    It relies on `(format-banner 3)` and `(format-stacktrace 1)`
    to generate the final format.

    Note that `{#EXIT pid}` do not generate a stacktrace though
    (as they are retrieved as messages without stacktrace).
    """

    ([kind payload]
     (format kind payload :nil))

    ([{#EXIT _} &as kind any _]
     (format-banner kind any))

    ([kind payload stacktrace]
     (let [st (or stacktrace (system.#stacktrace))
           message (format-banner kind payload stacktrace)]
       (case st
         ([]
          message)
         (_
          (format "~s\n~s" [message (format-stacktrace st)]))))))

  (defn format-exit [reason]
    """Format an exit, returns a string.

    Often there are errors/exceptions inside exits. Exits are often
    wrapped by the caller and provide stacktraces too. This function
    formats exits in a way to nicely show the exit reason, caller
    and stacktrace.
    """

    (format-exit reason "\n    "))

  ;; 2-Tuple could be caused by an error if the second element is a stacktrace.
  (defn-
      #{:check_remote_call :false}
      format-exit [{exception maybe-stacktrace} &as reason
                   joiner] (&when (&and (list? maybe-stacktrace)
                                        (!== maybe-stacktrace [])))
    (try (seq.map maybe-stacktrace (fn format-stacktrace-entry 1))
      ((formatted-stacktrace
        ;; Assume a non-empty list formattable as stacktrace is a
        ;; stacktrace, so exit was caused by an error.
        (let [message (format "an exception was raised:~s~s"
                        [joiner
                         (format-banner #error exception maybe-stacktrace)])]
          (seq.join [message & formatted-stacktrace]
                    (format "~s    " [joiner])))))
      (catch
        ((#error _)
         ;; Not a stacktrace, was an exit.
         (format-exit-reason reason)))))

  ;; supervisor.start_link returns this error reason when it fails to init
  ;; because a child's start_link raises.
  (defn- format-exit [{#shutdown
                       {#failed_to_start_child, child, {#EXIT, reason}}}
                      joiner]
    (format-start-child child reason joiner))

  ;; supervisor.start_link returns this error reason when it fails to init
  ;; because a child's start_link returns {#error reason}.
  (defn- format-exit [{#shutdown
                       {#failed_to_start_child, child, reason}}
                      joiner]
    (format-start-child child reason joiner))

  ;; 2-Tuple could be an exit caused by mfa if second element is mfa, args
  ;; must be a list of arguments - max length 255 due to max arity.
  (defn- format-exit [{reason2 {mod fun args}} &as reason
                      joiner] (&when (< (length args) 256))
    (try (format-mfa mod fun args)
      ((mfa
        ;; assume tuple formattable as an mfa is an mfa, so exit was caused by
        ;; failed mfa.
        (format "exited in: ~s~s** (EXIT) ~s"
                [mfa
                 joiner
                 (format-exit reason2 (format "~s    " [joiner]))])))
      (catch
        ((#error _)
         ;; Not an mfa, was an exit.
         (format-exit-reason reason)))))

  (defn- format-exit [reason _joiner]
    (format-exit-reason reason))

  (defn- format-exit-reason [#normal]
    "normal")
  (defn- format-exit-reason [#shutdown]
    "shutdown")

  (defn- format-exit-reason [{#shutdown reason}]
    (format "shutdown: ~s" [(inspect reason)]))

  (defn- format-exit-reason [#timeout]
    "time out")
  (defn- format-exit-reason [#killed]
    "killed")
  (defn- format-exit-reason [#noconnection]
    "no connection")

  (defn- format-exit-reason [#noproc]
    "no process")

  (defn- format-exit-reason [{#nodedown node-name}] (&when (atom? node-name))
         (format "no connection to ~s" [node-name]))

  ;; gen_server exit reasons

  (defn- format-exit-reason [{#already_started pid}]
    (format "already started: ~s" [(inspect pid)]))

  (defn- format-exit-reason [{#bad_return_value value}]
    (format "bad return value: ~s" [(inspect value)]))

  (defn- format-exit-reason [{#bad_call request}]
    (format "bad call: ~s" [(inspect request)]))

  (defn- format-exit-reason [{#bad_cast request}]
    (format "bad cast: ~s" [(inspect request)]))

  ;; supervisor.start_link error reasons

  ;; If value is a list will be formatted by mfa exit in (format-exit 1)
  (defn- format-exit-reason [{#bad_return {mod #init value}}] (&when (atom? mod))
    ;; TODO add impl
    (format "~s returned a bad value: ~s" [(format-mfa mod #init 1)
                                           (inspect value)]))

  (defn- format-exit-reason [{#bad_start_spec start-spec}]
    (format "bad start spec: invalid children: ~s" [(inspect start-spec)]))

  (defn- format-exit-reason [{#start_spec start-spec}]
    (format "bad start spec: ~s" [(format-sup-spec start-spec)]))

  (defn- format-exit-reason [{#supervisor_data data}]
    (format "bad supervisor data: ~s" [(format-sup-data data)]))

  (defn- format-exit-reason [reason]
    (inspect reason))

  (defn- format-start-child [child reason joiner]
    (format "shutdown: failed to start child: ~s~s**(EXIT) ~s"
            [(inspect child)
             joiner
             (format-exit reason (format "~s    " [joiner]))]))

  (defn- format-sup-data [{#invalid_type type}]
    (format "invalid type: ~s" [(inspect type)]))

  (defn- format-sup-data [{#invalid_strategy strategy}]
    (format "invalid strategy: ~s" [(inspect strategy)]))

  (defn- format-sup-data [{#invalid_intensity intensity}]
    (format "invalid intensity: ~s" [(inspect intensity)]))

  (defn- format-sup-data [{#invalid_period period}]
    (format "invalid period: ~s" [(inspect period)]))

  (defn- format-sup-data [other]
    (inspect other))

  (defn- format-sup-spec [{#invalid_child_spec child-spec}]
    (format "invalid child spec: ~s" [(inspect child-spec)]))

  (defn- format-sup-spec [{#invalid_child_type type}]
    (format "invalid child type: ~s" [(inspect type)]))

  (defn- format-sup-spec [{#invalid_mfa mfa}]
    (format "invalid mfa: ~s" [(inspect mfa)]))

  (defn- format-sup-spec [{#invalid_restart_type restart}]
    (format "invalid restart type: ~s" [(inspect restart)]))

  (defn- format-sup-spec [{#invalid_shutdown shutdown}]
    (format "invalid shutdown: ~s" [(inspect shutdown)]))

  (defn- format-sup-spec [{#invalid_module mod}]
    (format "invalid module: ~s" [(inspect mod)]))

  (defn- format-sup-spec [{#invalid_modules modules}]
    (format "invalid modules: ~s" [(inspect modules)]))

  (defn- format-sup-spec [other]
    (inspect other))

  (defn
      #{:check_remote_call :false}
      format-stacktrace-entry
    """Receives a stacktrace entry and formats it into a string."""

    ;; TODO add clauses for other cases

    ([{module fun arity location}]
     (format "~s~s~s" [(format-application module)
                       (format-location location)
                       (format-mfa module fun arity)]))
    ([{fun arity location}]
     (format "~s~s" [(format-location location)
                     (format-fa fun arity)])))

  (defn
      #{:check_remote_call :false}
      format-application [module]
    (case (application.get_application module)
      ({#ok app} (format "(~s)" [(Elixir.Atom.to_string app)]))
      (#undefined "")))

  (defn
      #{:check_remote_call :false}
      format-stacktrace [&optional (trace :nil)]
    """Format the stacktrace.

    A stacktrace must be given as an argument. If not, the stacktrace
    is retrieved from `(Elixir.Process.info 2)`.
    """
    (let [tr (or trace
               (case (process.info (self)
                                   #current_stacktrace)
                 ({#current_stacktrace t} (seq.drop t 3))))]
      (case tr
        ([] "\n")
        (s (format "    ~s"
                   [(seq.map_join
                     s
                     "\n    "
                     (fn [x]
                       (format "~s\n" [(format-stacktrace-entry x)])))])))))

  (defn format-fa [fun arity] (&when (function? fun))
    """Receives an anonymous function and arity and formats it as
    shown in stacktrace. The arity may also be a list of arguments.

    ## Examples

        (exception.format-fa (fn [] #ok) 1)
        ;;=> "#Function<...>/1"

    """
    ;; TODO revise the format to be Kapok style
    (format "~s~s" [(inspect fun) (format-arity arity)]))


  (defn format-mfa [module fun arity] (&when (&and (atom? module)
                                                   (atom? fun)))
    ;; TODO add doc
    ;; TODO add impl
    (format "~s.~s~s" [(inspect module) fun (format-arity arity)]))

  (defn
      #{:check_remote_call :false}
      format-arity [arity] (&when (list? arity))
    (let [inspected (seq.map arity (fn kapok.core inspect 1))]
      (format "(~s)" [(seq.join inspected ", ")])))

  (defn
      #{:check_remote_call :false}
      format-arity [arity] (&when (integer? arity))
    (format "/~d" [(Elixir.Integer.to_string arity)]))

  (defn format-file-line [file line]
    """Formats the given file and line as shown in stacktraces.
    If any of the values are `:nil`, they are omitted.

    ## Examples

        kapok> (exception.format-file-line "foo" 1)
        "foo:1:"

        kapok> (exception.format-file-line "foo" :nil)
        "foo:"

        kapok> (exception.format-file-line :nil :nil)
        ""

    """
    (format-file-line file line ""))

  (defn format-file-line [file line suffix]
    (if file
        (if (and line
                 (!= line 0))
            (format "~s:~p:~s" [file line suffix])
          (format "~s:~p" [file line]))
      ""))

  (defn
      #{:check_remote_call :false}
      format-location [opts] (&when (list? opts))
    (format-file-line (alist.get opts #file)
                      (alist.get opts #line)
                      " "))

  )

(defns kapok.runtime-error
  (defexception [{#message "runtime error"}]))

(defns kapok.argument-error
  (defexception [{#message "argument error"}]))

(defns kapok.arithmetic-error
  (defexception [])

  (defn message [_]
    "bad argument in arithmetic expression")
  )

(defns kapok.system-limit-error
  (defexception [])

  (defn message [_]
    "A system limit has been reached")
  )


(defns kapok.syntax-error
  ((require (kapok (access
                    exception)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#file :nil}
                 {#line :nil}
                 {#description "syntax error"}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (fmt "~s ~s" [(exception.format-file-line (access.get e #file)
                                              (access.get e #line))
                  (access.get e #description)])))

(defns kapok.token-missing-error
  ((require (kapok (access
                    exception)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#file :nil}
                 {#line :nil}
                 {#description "expression is incomplete"}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (fmt "~s ~s" [(exception.format-file-line (access.get e #file)
                                              (access.get e #line))
                  (access.get e #description)])))

(defns kapok.compile-error
  ((require (kapok (access
                    exception)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#file :nil}
                 {#line :nil}
                 {#description "compile error"}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (fmt "~s ~s" [(exception.format-file-line (access.get e #file)
                                              (access.get e #line))
                  (access.get e #description)])))

(defns kapok.bad-function-error
  ((require (kapok (access)))
   (use (io_lib :only (format))))

  (defexception [{#term :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (format "expected a function, got: ~s" [(inspect (access.get e #term))])))

(defns kapok.bad-struct-error
  ((require (kapok (access)))
   (use (io_lib :only (format))))

  (defexception [{#struct :nil}
                 {#term :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (format "expected a struct named ~s, got: ~s"
            [(inspect (access.get e #struct))
             (inspect (access.get e #term))])))

(defns kapok.match-error
  ((require (kapok (access)))
   (use (io_lib :only (format))))

  (defexception [{#term :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (format "no match of right hand side value: ~s"
            [(inspect (access.get e #term))])))

(defns kapok.case-clause-error
  ((require (kapok (access)))
   (use (io_lib :only (format))))

  (defexception [{#term :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (format "no case clause matching: ~s" [(inspect (access.get e #term))])))

(defns kapok.cond-clause-error
  ((use (io_lib :only (format))))

  (defexception [])

  (defn message [_e]
    (format "no cond clause evaluated to a true value" [])))

(defns kapok.try-clause-error
  ((require (kapok (access)))
   (use (io_lib :only (format))))

  (defexception [{#term :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (format "no try clause matching: ~s" [(inspect (access.get e #term))])))

(defns kapok.bad-arity-error
  ((require (kapok (access
                    seq)))
   (use (io_lib :only (format))))

  (defexception [{#function :nil}
                 {#args :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (let [fun (access.get e #function)
          args (access.get e #args)
          insp (seq.map_join args
                             ", "
                             (fn kapok.core inspect 1))
          {#arity arity} (erlang.fun_info fun #arity)]
      (format "~s with arity ~B called with ~s"
              [(inspect fun)
               arity
               (count (length args) insp)])))

  (defn- count [0 _insp]
    "no arguments")

  (defn- count [1 insp]
    (format "1 argument ~s" [insp]))

  (defn- count [x insp]
    (format "~B arguments ~s" [x insp])))

(defns kapok.undefined-function-error
    ((require code
              maps
              (kapok (exception)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#module :nil}
                 {#function :nil}
                 {#arity :nil}
                 {#reason :nil}])

  (defn message [#{#reason :nil
                   #module module
                   #function function
                   #arity arity} &as e]
    (cond
      (or (nil? function) (nil? arity))
      "undefined function"

      (and (not (nil? module))
           (=== (code.is_loaded module) :false))
      (message (maps.put #reason "module could not be loaded" e))

      :true
      (message (maps.put #reason "function not exported" e))))

  (defn message [#{#reason "module could not be loaded"
                   #module module
                   #function function
                   #arity arity}]
    (fmt "undefined function: ~s (module ~s is not available)"
         [(exception.format-mfa module function arity)
          (inspect module)]))

  (defn message [#{#reason "function not exported"
                   #module module
                   #function function
                   #arity arity}]
    (fmt "undefined function: ~s" [(exception.format-mfa module function arity)]))

  (defn message [#{#reason "function not available"
                   #module module
                   #function function
                   #arity arity}]
    (let [<< "nil." fa >> (exception.format-mfa :nil function arity)]
      (fmt "undefined function: ~s (function ~s is not available)"
           [(exception.format-mfa module function arity)
            fa]))))

(defns kapok.function-clause-error
  ((require (kapok (access
                    exception)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#module :nil}
                 {#function :nil}
                 {#arity :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (if (access.get e #function)
        (let [formatted (exception.format-mfa (access.get e #module)
                                              (access.get e #function)
                                              (access.get e #arity))]
          (fmt "no function clause matching in ~s" [formatted]))
      "no function clause matches")))

(defns kapok.code.load-error
  ((require (kapok (alist)))
   (use (io_lib :only (format))))

  (defexception [{#file :nil}
                 {#message :nil}])

  (defn
      #{:check_remote_call :false}
      exception [opts]
    (let [file (alist.fetch! opts #file)
          message (format "could not load ~s" [file])]
      (new :message message :file file))))

(defns kapok.protocol.undefined-error
  ((require (kapok (access
                    exception)))
   (use (io_lib :only (format))))

  (defexception [{#protocol :nil}
                 {#value :nil}
                 {#description :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (let [msg (format "protocol ~s not implemented for ~s"
                [(inspect (access.get e #protocol))
                 (inspect (access.get e #value))])]
      (if (access.get e #description)
          (format "~s, ~s" [msg
                            (access.get e #description)])
        msg))))

(defns kapok.key-error
  ((require (kapok (access)))
   (use (io_lib :only (format))))

  (defexception [{#key :nil}
                 {#term :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (format "key ~s not found in ~s" [(inspect (access.get e #key))
                                      (inspect (access.get e #term))])))

(defns kapok.unicode-conversion-error
  ((require (kapok (alist)))
   (use (io_lib :only (format))))

  (defexception [{#encoded :nil}
                 {#message :nil}])

  (defn
      #{:check_remote_call :false}
      exception [opts]
    (let [message (format "~p ~s" [(alist.fetch! opts #kind)
                                   (detail (alist.fetch! opts #rest))])]
      (new :encoded (alist.fetch! opts #encoded)
           :message message)))

  (defn- detail [rest] (&when (binary? rest))
    (format "encoding starting at ~s" [(inspect rest)]))

  (defn- detail [[h & _]]
    (format "code point ~p" [h])))

(defns kapok.seq.out-out-bounds-error
  (defexception [])

  (defn message [_]
    "out of bounds error"))

(defns kapok.seq.empty-error
  (defexception [])

  (defn message [_]
    "empty error"))

(defns kapok.file.error
  ((require file
            (kapok (access
                    io)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#reason :nil}
                 {#action ""}
                 {#path :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (let [formatted (io.iodata_to_binary (file.format_error
                                          (access.get e #reason)))]
      (fmt "could not ~s ~s: ~s" [(access.get e #action)
                                  (access.get e #path)
                                  formatted]))))

(defns kapok.file.copy-error
  ((require file
            (kapok (access
                    io)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#reason :nil}
                 {#action :nil}
                 {#source :nil}
                 {#destination :nil}
                 {#on :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (let [formatted (io.iodata_to_binary (file.format_error (access.get e #reason)))
          location (if (access.get e #on)
                       (fmt ". ~s" [(access.get e #on)])
                     "")]
      (fmt "could not ~s from ~s to ~s~s: ~s" [(access.get e #action)
                                               (access.get e #source)
                                               (access.get e #destination)
                                               location
                                               formatted])))
  )

(defns kapok.erlang-error
  ((require (kapok (access
                    exception
                    argument-error
                    arithmetic-error
                    system-limit-error
                    cond-clause-error
                    bad-arity-error
                    bad-function-error
                    bad-struct-error
                    match-error
                    case-clause-error
                    try-clause-error
                    undefined-function-error
                    function-clause-error
                    argument-error)))
   (use (io_lib :only (format)
                :rename ((format fmt)))))

  (defexception [{#original :nil}])

  (defn
      #{:check_remote_call :false}
      message [e]
    (fmt "erlang error: ~s" [(inspect (access.get e #original))]))

  (defn normalize [#badarg _stacktrace]
    (argument-error.new))

  (defn normalize [#badarith _stacktrace]
    (arithmetic-error.new))

  (defn normalize [#system_limit _stacktrace]
    (system-limit-error.new))

  (defn normalize [#cond_clause _stacktrace]
    (cond-clause-error.new))

  (defn normalize [{#badarity {fun args}} _stacktrace]
    (bad-arity-error.new :function fun :args args))

  (defn normalize [{#badfun term} _stacktrace]
    (bad-function-error.new :term term))

  (defn normalize [{#badstruct struct term} _stacktrace]
    (bad-struct-error.new :struct struct :term term))

  (defn normalize [{#badmatch term} _stacktrace]
    (match-error.new :term term))

  (defn normalize [{#case_clause term} _stacktrace]
    (case-clause-error.new :term term))

  (defn normalize [{#try_clause term} _stacktrace]
    (try-clause-error.new :term term))

  (defn normalize [#undef stacktrace]
    (let [st (or stacktrace
               (erlang.get_stacktrace))
          {mod fun arity} (from-stacktrace st)]
      (undefined-function-error.new :module mod :function fun :arity arity)))

  (defn normalize [#function_clause stacktrace]
    (let [{mod fun arity} (from-stacktrace (or stacktrace (erlang.get_stacktrace)))]
      (function-clause-error.new :module mod :function fun :arity arity)))

  (defn normalize [{#badarg payload} _stacktrace]
    (argument-error.new :message (fmt "argument error: ~s" [(inspect payload)])))

  (defn normalize [other _stacktrace]
    (new :original other))

  (defn- from-stacktrace [[{module function args _} & _]] (&when (list? args))
    {module function (length args)})

  (defn- from-stacktrace [[{module function arity _} & _]]
    {module function arity})

  (defn- from-stacktrace [_]
    {:nil :nil :nil})
  )
