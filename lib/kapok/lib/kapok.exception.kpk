(ns kapok.exception
  """Functions to format throw/catch/exit and exceptions.

  Note that stacktraces in Kapok are updated on throw,
  errors and exits. For example, at any given moment,
  `(system.stackstrace 0)` will return the stacktrace for
  the last throw/error/exit that occurred in the current process.

  Do not rely on the particular format returned by the `format`
  functions in this module. They may be changed in future releases
  in order to better suit Kapok's tool chain. In other words,
  by using the functions in this module it is guaranteed you will
  format exceptions as in the current Kapok version being used.
  """
  )


(defmacro defexception [_args]
  """Defines an exception.

  Exceptions are structs backed by a module that implements
  the `exception` behaviour. The `exception` behaviour requires
  two functions to be implemented:

    * `(exception 1)` receives the arguments given to `(raise 2)`
      and returns the exception struct. The default implementation
      accepts either a set of alist arguments that is merged into
      the struct or a string to be used as the exception's message.

    * `(message 1)` receives the exception struct and must return its
      message. Most commonly exceptions have a message field which
      by default is accessed by this function. However, if an exception
      does not have a message field, this function must be explicitly
      implemented.

  Since exceptions are structs, the API supported by `(defstruct 1)`
  is also available in `(defexception 1)`.

  ## Raising exceptions

  The most common way to raise ain exception is via `(raise 2)`:

      (defns my-app-error
        (defexception [#message])
       )

      ...

      (let [value [#hello]
        (raise my-app-error
               [{#message (io_lib.format
                           "did not get what was expected, got: ~s"
                           [(inspect value)])}])])

  In many cases it is more convenient to pass the expected value to
  `(raise 2)` and generate the message in the `(exception 1)` callback:

       (defns my-app-error
         (defexception [#message])

         (defn exception [value]
           (let [msg (io_lib.format "did not get what was expected, got: ~s"
                                    [(inspect value)])]
             (my-app-error.new :message msg))))

       ...

       (raise my-app-error value)

  The example above shows the preferred strategy for customizing
  exception messages.
  """

  ;; (let [fields (if (list? args)
  ;;                  [{#__exception__ :true} & args]
  ;;                `(lists.append [{#__exception__ :true}] ~args))]
    [
     `(behaviour kapok.exception)

     `(defn exception [msg] (&when (binary? msg))
        (exception [{#message msg}]))

     `(defn exception [args] (&when (list? args))
        (kapok.core.struct (__MODULE__) args))

     ;; TODO add dummy impl for `message` if there is no #message field
     `(defn message [exception]
        (get exception #message))
      ]
    ;;)
  )


;; behaviour definition

(defn behaviour_info [#callbacks]
  [{#exception 1}
   {#message 1}])
(defn behaviour_info [_]
  #undefined)
