(ns kapok.alist
  """An alist (association list) is a list of tuples where
  the first element of the tuple is an atom and the second element
  can be any value.

  An alist may have duplicated keys so it is not strictly
  a dictionary. However most of the functions in this module
  behave exactly as a dictionary and mimic the API defined
  by the `dictionary` behaviour.

  For example, `(alist.get 3)` will get the first entry matching
  the given key, regardless if duplicated entries exist.
  Similarly, `(alist.put 3)` and `(alist.delete 3)` ensure all
  duplicated entries for a given key are removed when invoked.

  A handful of functions exist to handle duplicated keys, in
  particular, `(Elixir.Enum.into 2)` allows creating new alist without
  removing duplicated keys, `(get-values 2)` returns all values for
  a given key and `(delete-first 2)` deletes just one of the existing
  entries.

  The functions in `alist` do not guarantee any property when
  it comes to ordering. However, since an alist is simply a list,
  all the operations defined in `seq` and `list` can be applied too,
  specially when ordering is required."""

  (require lists))

(defn alist?
  "Returns `:true` if `term` is an alist; otherwise returns `:false`."

  ([[{key _value} & rest]] (&when (atom? key))
   (alist? rest))

  ([[]]
   :true)

  ([_other]
   :false))

(defn new []
  "Returns an empty alist, i.e. an empty list."

  [])

(defn new [pairs]
  """Creates an alist from a Elixir.Enumerable.

  Duplicated entries are removed, the latest one prevails.
  Unlike `(Elixir.Enum.into enumerable [])`, `(alist.new enumerable)`
  guarantees the keys are unique.

  ## Examples

      kapok> (alist.new [{#b 1} {#a 2}])
      [{#a 2} {#b 1}]

  """
  (new pairs (fn [pair] pair)))

(defn
    #{:check_remote_call :false}
    new [pairs transform] (&when (function? transform 1))
  """Creates an alist from an enumerable via the transformamtion function.

  Duplicated entries are removed, the latest one prevails.
  Unlike `(Elixir.Enum.into enumerable [] fun)`, `(alist.new enumerable fun)`
  guarantees the keys are unique.

  ## Examples

      kapok> (alist.new [#a #b] (fn [x] {x x}))
      [{#b #b} {#a #a}]

  """
  (let [fun (fn [el acc]
              (let [{k v} (transform el)]
                (put-new acc k v)))]
    (lists.foldr fun [] (Elixir.Enum.reverse pairs))))

(defn get [alist key &optional (default :nil)] (&when (&and (list? alist)
                                                            (atom? key)))
  """Gets the value for a specific `key`.

  If `key` does not exist, return the default value (`:nil` if no default value).

  If duplicated entries exist, the first one is returned.
  Use `(get-values 2)` to retrieve all entries.

  ## Examples

      kapok> (alist.get [{#a 1}] #a)
      1

      kapok> (alist.get [{#a 1}] #b)
      :nil

      kapok> (alist.get [{#a 1}] #b 3)
      3

  """
  (case (lists.keyfind key 1 alist)
    ({key value} value)
    (:false default)))

(defn get-lazy [alist key fun] (&when (&and (list? alist)
                                            (atom? key)
                                            (function? fun 0)))
  """Gets the value for a specific `key`.

  If `key` does not exist, lazily evaluates `fun` and returns its result.

  This is useful if the default value is very expensive to calculate or
  generally difficult to set-up and tear-down again.

  If duplicated entries exist, the first one is returned.
  Use `(get-values 2)` to retrieve all entries.

  ## Examples

      kapok> (let [l [{#a 1}]
                   fun (fn [] #result)]
               (alist.get-lazy l #a fun))
      1

      kapok> (let [l [{#a 1}]
                   fun (fn [] #result)]
               (alist.get-lazy l #a fun))
      #result

  """
  (case (lists.keyfind key 1 alist)
    ({key value} value)
    (:false (fun))))

(defn get-and-update [alist key fun] (&when (&and (list? alist)
                                                  (atom? key)))
  """Gets the value from `key` and updates it, all in one pass.

  This `fun` argument receives the value of `key` (or `:nil` if `key`
  is not present) and must return a two-element tuple: the "get" value
  (the retrieved value, which can be operated on before being returned) and
  new value to be stored under `key`.

  The returned value is a tuple with the "get" value returned by `fun` and
  a new alist with the updated value under `key`.

  ## Examples

      kapok> (alist.get-and-update [{#a 1}] #a (fn [current-value]
                                                 {current-value "new value!"}))
      {1 [{#a "new value!"}]}

  """

  (get-and-update alist [] key fun))

(defn- get-and-update

  ([[{key value} & t] acc key fun]
   (let [{get new-value} (fun value)]
     {get (lists.reverse acc [{key new-value} & t])}))

  ([[h & t] acc key fun]
   (get-and-update t [h & acc] key fun))

  ([[] acc key fun]
   (let [{get update} (fun :nil)]
     {get [{key update} & (lists.reverse acc)]})))

(defn fetch [alist key] (&when (&and (list? alist)
                                     (atom? key)))
  """Fetches the value for a specific `key` and returns it in a tuple.

  If the `key` does not exist, returns `#error`.

  ## Examples

      kapok> (alist.fetch [{#a 1}] #a)
      {#ok 1}

      kapok> (alist.fetch [{#a 1}] #b)
      #error

  """
  (case (lists.keyfind key 1 alist)
    ({key value} {#ok value})
    (:false #error)))

(defn fetch! [alist key] (&when (&and (list? alist)
                                      (atom? key)))
  """Fetches the value for specific `key`.

  If the `key` does not exist, a `key-error` is raised.

  ## Examples

      kapok> (alist.fetch! [{#a 1}] #a)
      1

      kapok> (alist.fetch! [{#a 1}] #b)
      ** (Error) key not found

  """
  (case (lists.keyfind key 1 alist)
    ({key value}
     value)
    (:false
     (raise kapok.key-error [{#key key}
                             {#term alist}]))))

(defn get-values [alist key] (&when (&and (list? alist)
                                          (atom? key)))
  """Gets all values for a specific `key`.

  ## Examples

      kapok> (alist.get-values [{#a 1} {#a 2}] #a)
      [1 2]

  """
  (let [fun (fn
              ([{k v}] (&when (=== k key))
               {:true v})
              ([{_ _}]
               :false))]
    (lists.filtermap fun alist)))

(defn keys [alist] (&when (list? alist))
  """Returns all keys from the alist.

  Duplicated keys appear duplicated in the final list of keys.

  ## Examples

      kapok> (alist.keys [{#a 1} {#b 2}])
      [#a #b]

      kapok> (alist.keys [{#a 1} {#b 2} {#a 3}])
      [#a #b #a]

  """
  (lists.map (fn [{k _}] k) alist))

(defn values [alist] (&when (list? alist))
  """Returns all values from the alist.

  ## Examples

      kapok> (alist.values [{#a 1} {#b 2}])
      [1 2]

  """
  (lists.map (fn [{_ v}] v) alist))

(defn delete [alist key value] (&when (&and (list? alist)
                                            (atom? key)))
  """Deletes the entries in the alist for a `key` with `value`.

  If no `key` with `value` exists, returns the alist unchanged.

  ## Examples

      kapok> (alist.delete [{#a 1} {#b 2}] #a 1)
      [{#b 2}]

      kapok> (alist.delete [{#a 1} {#b 2} {#a 3}] #a 3)
      [{#a 1} {#b 2}]

      kapok> (alist.delete [{#b 2}] #a 5)
      [{#b 2}]

  """
  (lists.filter (fn [{k v}]
                  (or (!== k key)
                      (!== v value)))
                alist))

(defn delete [alist key] (&when (&and (list? alist)
                                      (atom? key)))
  """Deletes the entries in the keyword list for a specific `key`.

  If the `key` does not exist, returns the alist unchanged.
  Use `(delete-first 2)` to delete just the first entry in case of
  duplicated keys.

  ## Examples

      kapok> (alist.delete [{#a 1} {#b 2}] #a)
      [{#b 2}]

      kapok> (alist.delete [{#a 1} {#b 2} {#a 3}] #a)
      [{#b 2}]

      kapok> (alist.delete [{#b 2}] #a)
      [{#b 2}]

  """
  (lists.filter (fn [{k _}]
                  (!== k key))
                alist))

(defn delete-first [alist key] (&when (&and (list? alist)
                                            (atom? key)))
  """Deletes the first entry in the alist for a specific `key`.

  If the `key` does not exist, returns the alist unchanged.

  ## Examples

      kapok> (alist.delete-first [{#a 1} {#b 2} {#a 3}] #a)
      [{#b 2} {#a 3}]

      kapok> (alist.delete-first [{#b 2}] #a)
      [{#b 2}]

  """
  (lists.keydelete key 1 alist))

(defn put [alist key value] (&when (&and (list? alist)
                                         (atom? key)))
  """Puts the given `value` under `key`.

  If a previous value is already stored, all entries are
  removed and the value is overridden.

  ## Examples

      kapok> (alist.put [{#a 1} {#b 2}] #a 3)
      [{#a 3} {#b 2}]

      kapok> (alist.put [{#a 1} {#b 2} {#a 4}] #a 3)
      [{#a 3} {#b 2}]

  """
  [{key value} & (delete alist key)])

(defn put-new-lazy [alist key fun] (&when (&and (list? alist)
                                                (atom? key)
                                                (function? fun 0)))
  """Evaluates `fun` and puts the result under `key`
  in alist unless `key` is already present.

  This is useful if the value is very expensive to calculate or
  generally difficult to set-up and tear-down again.

  ## Examples

      kapok> (let [l [{#a 1}]
                   fun (fn []
                         ;; some expensive operation here
                         3)]
               (alist.put-new-lazy l #a fun))
      [{#a 1}]

      kapok> (let [l [{#a 1}]
                   fun (fn []
                         ;; some expensive operation here
                         3)]
               (alist.put-new-lazy l #b fun))
      [{#b 3} {#a 1}]

  """
  (case (lists.keyfind key 1 alist)
    ({key _} alist)
    (:false [{key (fun)} & alist])))

(defn put-new [alist key value] (&when (&and (list? alist)
                                             (atom? key)))
  """Puts the given `value` under `key` unless the entry `key`
  already exists.

  ## Examples

      kapok> (alist.put-new [{#a 1}] #b 2)
      [{#b 2} {#a 1}]

      kapok> (alist.put-new [{#a 1} {#b 2}] #a 3)
      [{#a 1} {#b 2}]

  """
  (case (lists.keyfind key 1 alist)
    ({key _}  alist)
    (:false [{key value} & alist])))

(defn equal? [left right] (&when (&and (list? left)
                                       (list? right)))
  """Checks if two alists are equal.

  Two alists are considered to be equal if they contain
  the same keys and those keys contain the same values.

  ## Examples

      kapok> (alist.equal? [{#a 1} {#b 2}] [{#b 2} {#a 1}])
      :true

  """
  (== (lists.sort left)
      (lists.sort right)))

(defn merge [alist1 alist2] (&when (&and (list? alist1)
                                         (list? alist2)))
  """Merges two alists into one.

  If they have duplicated keys, the one given in the second argument wins.

  ## Examples

      kapok> (alist.merge [{#a 1} {#b 2}] [{#a 3} {#d 4}])
      [{#a 3} {#d 4} {#b 2}]

  """
  (let [fun (fn [{k _v}]
              (not (has-key? alist2 k)))]
    (lists.append alist2 (lists.filter fun alist1))))

(defn merge [alist1 alist2 fun] (&when (&and (list? alist1)
                                             (list? alist2)))
  """Merges two alists into one.

  If they have duplicated keys, the given function is invoked to solve conflicts.

  ## Examples

      kapok> (alist.merge [{#a 1} {#b 2}]
                          [{#a 3} {#b 4}]
                          (fn [_k v1 v2] (+ v1 v2)))
      [{#a 4} {#b 2} {#d 4}]

  """
  (do-merge alist2 alist1 fun))

(defn- do-merge [[{k v2} & t] acc fun]
  (do-merge t (update acc k v2 (fn [v1] (fun k v1 v2))) fun))

(defn- do-merge [[] acc _fun]
  acc)

(defn has-key? [alist key] (&when (&and (list? alist)
                                        (atom? key)))
  """Returns whether a given `key` exists in the given `alist`.

  ## Examples

      kapok> (alist.has-key? [{#a 1}] #a)
      :true

      kapok> (alist.has-key? [{#a 1}] #b)
      :false

  """
  (lists.keymember key 1 alist))

(defn update! [alist key fun]
  """Updates the `key` with the given function.

  If the `key` does not exist, raises `key-error`.

  If there are duplicated keys, they are all removed and only the first one
  is updated.

  ## Examples

      kapok> (alist.update! [{#a 1}] #a (fn [x] (* x 2)))
      [{#a 2}]

      kapok> (alist.update! [{#a 1}] #b (fn [x] (* x 2)))
      ** (Error) key not found

  """
  (update! alist key fun alist))

(defn- update! [alist key fun dict]
  (let [{acc tail} (update! alist key fun dict [])]
    (lists.reverse acc tail)))

(defn- update! [[{key value} & alist] key fun _dict acc]
  {acc [{key (fun value)} & (delete alist key)]})

(defn- update! [[{_ _} &as e & alist] key fun dict acc]
  (update! alist key fun dict [e & acc]))

(defn- update! [[] key _fun dict _acc]
  (raise kapok.key-error [{#key key}
                          {#term dict}]))

(defn update [alist key initial fun]
  """Updates the `key` in `keywords` with the given function.

  If the `key` does not exist, inserts the given `initial` value.

  If there are duplicated keys, they are all removed and only the first one
  is updated.

  ## Examples

      kapok> (alist.update [{#a 1}] #a 13 (fn [x] (* x 2)))
      [{#a 2}]

      kapok> (alist.update [{#a 1}] #b 11 (fn [x] (* x 2)))
      [{#a 1} {#b 11}]

  """
  (let [{acc tail} (update alist key initial fun [])]
    (lists.reverse acc tail)))

(defn- update [[{key value} & alist] key _initial fun acc]
  {acc [{key (fun value)} & (delete alist key)]})

(defn- update [[{_ _} &as e & alist] key initial fun acc]
  (update alist key initial fun [e & acc]))

(defn- update [[] key initial _fun acc]
  {acc [key initial]})

(defn split [alist keys] (&when (list? alist))
  """Takes all entries corresponding to the given keys and extracts them into
  a seperate alist.

  Returns a tuple with the new list and the old list with removed keys.

  Keys for which there are no entries in the alist are ignored.

  Entries with duplicated keys end up in the same alist.

  ## Examples

      kapok> (let [d [{#a 1} {#b 2} {#c 3} {#d 4}]]
               (alist.split d [#a #c #e]))
      {[{#a 1} {#c 3}] [{#b 2} {#d 4}]}

      kapok> (let [d [{#a 1} {#b 2} {#c 3} {#d 4} {#a 5}]]
               (alist.split d [#a #c #e]))
      {[{#a 1} {#c 3} {#a 5}] [{#b 2} {#d 4}]}

  """
  (let [fun (fn [{k v} {take drop}]
              (case (lists.member k keys)
                (:true
                 {[{k v} & take] drop})
                (:false
                 {take [{k v} & drop]})))
        acc {[] []}
        {take drop} (lists.foldl fun acc alist)]
    {(lists.reverse take) (lists.reverse drop)}))

(defn take [alist keys] (&when (list? alist))
  """Takes all entries corresponding to the given keys and returns them in
  a new keyword list.

  Duplicated keys are preserved in the new alist.

  ## Examples

      kapok> (let [d [{#a 1} {#b 2} {#c 3} {#d 4}]]
               (alist.take d [#a #c #e]))
      [{#a 1} {#c 3}]

      kapok> (let [d [{#a 1} {#b 2} {#c 3} {#d 4} {#a 5}]]
               (alist.take d [#a #c #e]))
      [{#a 1} {#c 3} {#a 5}]

  """
  (lists.filter (fn [{k _}]
                  (lists.member k keys))
                alist))

(defn drop [alist keys] (&when (list? alist))
  """Drops the given keys from the alist.

  Duplicated keys are preserved in the new alist.

  ## Examples

      kapok> (let [d [{#a 1} {#b 2} {#c 3} {#d 4}]]
               (alist.drop d [#b #d]))

      kapok> (let [d [{#a 1} {#b 2} {#c 3} {#d 4} {#a 5}]]
               (alist.drop d [#b #d]))
      [{#a 1} {#c 3} {#a 5}]

  """
  (lists.filter (fn [{k _}]
                  (not (lists.member k keys)))
                alist))

(defn pop [alist key &optional (default :nil)] (&when (list? alist))
  """Returns the first value associated with `key` in the alist
  as well as the alist without `key`.

  All duplicated keys are removed. See `(pop-first 3)` for
  removing only first entry.

  ## Examples

      kapok> (alist.pop [{#a 1}] #a)
      {1 []}

      kapok> (alist.pop [{#a 1}] #b)
      {:nil [{#a 1}]}

      kapok> (alist.pop [{#a 1}] #b 3)
      {3 [{#a 1}]}

      kapok> (alist.pop [{#a 1} {#a 2}] #a)
      {1 []}

  """
  (case (fetch alist key)
    ({#ok value}
     {value (delete alist key)})
    (#error
     {default alist})))

(defn pop-lazy [alist key fun] (&when (&and (list? alist)
                                            (function? fun 0)))
  """Returns the first value associated with `key` in the alist
  as well as the alist without `key`.

  This is useful if the default value is very expensive to calculate or
  generally difficult to set-up or tear-down again.

  All duplicated keys are removed. See `(pop-first 3)` for
  removing only the first entry.

  ## Examples

      kapok> (let [l [{#a 1}]
                   fun (fn []
                         ;; some expensive operations here
                         #result)]
               (alist.pop-lazy l #a fun))
      {1 []}

      kapok> (let [l [{#a 1}]
                   fun (fn []
                         ;; some expensive operations here
                         #result)]
               (alist.pop-lazy l #a fun))
      {#result [{#a 1}]}

  """
  (case (fetch alist key)
    ({#ok value}
     {value (delete alist key)})
    (#error
     {(fun) alist})))

(defn pop-first [alist key &optional (default :nil)] (&when (list? alist))
  """Returns the first value associated with `key` in the alist
  as well as the alist without that particular occurrence of `key`.

  Duplicated keys are not removed.

  ## Examples

      kapok> (alist.pop-first [{#a 1}] #a)
      {1 []}

      kapok> (alist.pop-first [{#a 1}] #b)
      {:nil [{#a 1}]}

      kapok> (alist.pop-first [{#a 1}] #b 3)
      {3 [{#a 1}]}

      kapok> (alist.pop-first [{#a 1} {#a 2}] #a)
      {1 [{#a 2}]}

  """
  (case (lists.keytake key 1 alist)
    ({#value {key value} rest}
     {value rest})
    (:false
     {default alist})))

(defn size [alist]
  (length alist))

(defn to-list [alist]
  alist)
