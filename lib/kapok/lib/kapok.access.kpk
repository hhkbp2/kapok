;;

(defprotocol kapok.access
  """Dictionary-like access to data structures via the `(get ds)` syntax.

  This module also empowers `core`'s nested update functions
  `(core.get-in 2)`, `(core.put-in 3)`, `(core.update-in 3)` and
  `(core.get-and-update-in 3)`.

  ## Examples

  Out of the box, `access` works all built-in dictionaries: `alist`,
  `map` and `hashdict`.

  """

  (get [collection key]
    "Gets the collection's value for the given key.")

  (get-and-update [collection key fun]
    """Gets and updates the collection's value for the given key,
    in a single pass.

    The argument function `fun` must receive the value for the given `key`
    (or `:nil` if the key doesn't exist in `collection`). It must return
    a tuple containing the `get` value and the new value to be stored
    in the `collection`.

    This function returns a two-element tuple.
    The first element is the `get` value, as returned by `fun`.
    The second element is the collection, updated with the value
    returned by `fun`.""")
  )


(defimpl kapok.access list
  (require io_lib
           lists)

  (defn get
    ([dict key] (&when (atom? key))
     (case (lists.keyfind key 1 dict)
       ({key value}
        value)
       (:false
        :nil)))

    ([_dict key]
     (let [message
           (io_lib.format
            "the access protocol for lists expect the key to be an atom, got ~p"
            [key])]
       (raise kapok.argument-error [{#message message}]))))

  (defn get-and-update [dict key fun] (&when (atom? key))
    (get-and-update dict [] key fun))

  (defn- get-and-update [[{key value} & t] acc key fun]
    (let [{get update} (fun value)]
      {get (lists.reverse acc [{key update} & t])}))

  (defn- get-and-update [[h & t] acc key fun]
    (get-and-update t [h & acc] key fun))

  (defn- get-and-update [[] acc key fun]
    (let [{get update} (fun :nil)]
      {get [{key update} & (lists.reverse acc)]}))
  )

(defimpl kapok.access map
  (require io_lib
           maps)

  (defn get [map key]
    (case (maps.find key map)
      ({#ok value}
       value)
      (#error
       :nil)))

  (defn get-and-update [map key fun]
    (let [v (case (maps.find key map)
                  ({#ok value}
                   value)
                  (#error
                   :nil))
          {get update} (fun v)]
      {get (maps.put key update map)}))

  (defn get! [map key] (&when (map? map))
    (case (maps.find key map)
      ({#ok value}
       value)
      (#error
       (raise kapok.key-error [{#key key} {#term map}]))))

  (defn get! [other key]
    (let [message (io_lib.format
                   "could not get key ~p. Expected map/struct, got ~p"
                   [key
                    other])]
      (raise kapok.argument-error [{#message message}])))

  (defn get-and-update! [map key fun] (&when (map? map))
    (case (maps.find key map)
      ({#ok value}
       (let [{get update} (fun value)]
         {get (maps.put key update map)}))
      (#error
       (raise kapok.key-error [{#key key} {#term map}]))))

  (defn get-and-update! [other key _fun]
    (let [message (io_lib.format
                   "could not put/update key ~p. Expected map/struct, got ~p"
                   [key
                    other])]
      (raise kapok.argument-error [{#message message}])))
  )

(defimpl kapok.access atom
  (require io_lib)

  (defn get [:nil _]
    :nil)

  (defn get [atom _]
    (undefined atom))

  (defn get-and-update [:nil key _fun]
    (let [message (io_lib.format
                   "could not put/update key ~p on a nil value"
                   [key])]
      (raise kapok.argument-error [{#message message}])))

  (defn get-and-update [atom _key _fun]
    (undefined atom))

  (defn- undefined [atom]
    (raise kapok.protocol.undefined-error
           [{#protocol #'kapok.access'
             #value atom
             #description "only the nil atom is supported"}]))
  )
