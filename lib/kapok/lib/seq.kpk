;;

(defprotocol sequential
  "Sequential protocol used by `seq` and `stream` modules."

  (reduce [collection acc fun]
    "Reduces the collection into a value.")

  (member? [collection value]
    "Checks if a value exists within the collection.")

  (count [collection]
    "Retrieves the collection's size."))

(defprotocol collection
  "A common protocol for built-in collections."

  (== [self &rest others]
    "Checks value equality of a collection compared to other colloctions.")

  (count [self]
    "Gets number of items in a collection.")

  (conj [self elem]
    "Adds an item to a collection.")

  (empty [self]
    "Obtains an empty instance of the same type as a provided collection.")

  (seq [self]
    "Gets a sequence of a collection.")
  )


;; TODO add more docs to seq functions

(ns seq
  """Provides a set of algorithms to obtain and traverse collections according to
  the `sequential` protocol."""
  (use core)
  (require erlang
           lists
           maps
           sequential))

(defn all?
  """Invoke the given `fun` for each item in the `collection` and returns
  `false` if at least one invocation returns `false` or `nil`. Otherwise
  returns `true`."""

  ([collection fun] (&when (list? collection))
   (do-all? collection fun))

  ([collection fun]
   (elem (sequential.reduce collection
                            {^cont :true}
                            (fn [entry _]
                              (if (fun entry)
                                  {^cont :true}
                                {^halt :false})))
         1))
  )

(defn all? [collection]
  (all? collection (fn [x] x)))

(defn any?
  """Invokes the given `fun` for each item in the `collection` and returns
  `true` if at least one invocation returns a truthy value. Returns `false`
  Otherwise."""

  ([collection fun] (&when (list? collection))
   (do-any? collection fun))

  ([collection fun]
   (elem (sequential.reduce collection
                            {^cont :false}
                            (fn [entry _]
                              (if (fun entry)
                                  {^halt :true}
                                {^cont :false})))
         1))
  )

(defn any? [collection]
  (any? collection (fn [x] x)))

(defn at [collection n &optional default]
  """Finds the element at the given index (zero-based).
  Returns `default` if index is out of bounds."""
  (case (fetch collection n)
    ({^ok e} e)
    (^error default)))

(defn chunk [collection n]
  "Shortcut to `(chunk collection n n)`."
  (chunk collection n n ^nil))

(defn chunk [_collection n step &optional _pad] (&when (&and (> n 0)
                                                             (> step 0)))
  """Returns a collection of lists containing `n` items each, where
  each new chunk starts `step` elements into the collection."""
  ;; TODO add impl
  ^todo
  )

(defn chunk_by [_collection _fun]
  "Splits `collection` on every element for which `fun` returns a new value."
  ;; TODO add impl
  ^todo
  )

(defn concat [sequentials]
  """Given a sequential of sequentials, concatenates the sequentials into
  a single list."""
  (do-concat sequentials))

(defn concat
  "Concatenates the enumerable on the right with the enumerable on the left."
  ([left right] (&when (&and (list? left)
                             (list? right)))
   (lists.append left right))

  ([left right]
   (do-concat [left right]))
  )

(defn count
  "Returns the collection's size."
  ([collection] (&when (list? collection))
   (erlang.length collection))

  ([collection]
   (case (sequential.count collection)
     ({^ok value} (&when (integer? value))
      value)
     ({^error module}
      (elem (module.reduce collection
                     {^cont 0}
                     (fn [_ acc]
                       {^cont (inc acc)}))
            1))))
  )

(defn fetch
  """Finds the element at the given index (zero-based)."""

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (>= n 0)))
   (do-fetch collection n))

  ([collection n] (&when (&and (integer? n)
                               (>= n 0)))
   (let [r (sequential.reduce collection
             {^cont 0}
             (fn [entry acc]
               (case acc
                 (n {^halt entry})
                 (_ {^cont (inc acc)}))))]
     (case r
       ({^halt entry} {^ok entry})
       ({^done _} ^error))))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (do-fetch (reverse collection) (abs (inc n))))
  )

(defn reduce
  """Invokes `fun` for each element in the collection passing that element and the
  accumulator `acc` as arguments."""

  ([collection acc fun] (&when (list? collection))
   (lists.foldl fun acc collection))

  ([collection acc fun] (&when (map? collection))
   (maps.fold (fn [k v acc0]
                (fun {k v} acc0))
              acc
              collection))

  ([collection acc fun]
   (elem (sequential.reduce collection
                            {^cont acc}
                            (fn [x acc0]
                              {^cont (fun x acc0)}))
         1))
  )

(defn reverse
  """Reverses the collection."""

  ([collection] (&when (list? collection))
   (lists.reverse collection))

  ([collection]
   (reverse collection [])))

(defn reverse
  """Reverses the collection and appends the tail."""

  ([collection tail] (&when (&and (list? collection)
                                  (list? tail)))
   (lists.reverse collection tail))

  ([collection tail]
   (reduce collection
           (to-list tail)
           (fn [entry acc]
             [entry & acc])))
  )

(defn to-list
  """Converts `collection` to a list."""

  ([collection] (&when (list? collection))
   collection)

  ([collection]
   (lists.reverse (reverse collection))))

;; Implementations

(defn- do-all? [[h & t] fun]
  (if (fun h)
      (do-all? t fun)
    :false))

(defn- do-all? [[] _]
  :true)

(defn- do-any? [[h & t] fun]
  (if (fun h)
      :true
    (do-any? t fun)))

(defn- do-any? [[] _]
  :false)

(defn- do-concat [sequential]
  (let [fun (fn [x l]
              [x & l])]
    (lists.reverse (reduce sequential
                           []
                           (fn [x acc]
                             (reduce x acc fun)))))
  )

(defn- do-fetch [[h & _] 0]
  {^ok h})

(defn- do-fetch [[_ & t] n]
  (do-fetch t (dec n)))

(defn- do-fetch [[] _]
  ^error)

;; Implementations of sequential for built-in collections.

(defimpl sequential list

  (defn reduce [_ {^halt acc} _fun]
    {^halted acc})
  (defn reduce [list {^suspend, acc} fun]
    {^suspended acc (fn [acc1] (reduce list acc1 fun))})
  (defn reduce [[] {^cont acc} _fun]
    {^done acc})
  (defn reduce [[h & t] {^cont acc} fun]
    (reduce t (fun h acc) fun))

  (defn member? [_list, _value]
    ;; TODO add macro `__MODULE__`
    {^error ^"sequential.list"})
  (defn count [_list]
    ;; TODO add macro `__MODULE__`
    {^error ^"sequential.list"})
  )

(defimpl sequential map
  (require maps)

  (defn reduce [map acc fun]
    (sequential.reduce (maps.to_list map)
                       acc
                       fun))

  (defn member? [map {key value}]
    {^ok (match? {^ok value}
                 (maps.find key map))})

  (defn member? [_map _other]
    {^ok :false})

  (defn count [map]
    {^ok (map-size map)}))

;; TODO

;; (defprotocol seq
;;   "A protocol for sequence."

;;   ;; clojure seq protocol

;;   (defn first [self]
;;     "Returns the first item in the collection.")

;;   (defn rest [self]
;;     "Returns a possibly empty seq of the items after the first.")

;;   (defn next [self]
;;     """Returns a seq of the items after the first.
;;     If there are no more items, returns nil.""")

;;   ;; elixir enum protocol

;;   )
