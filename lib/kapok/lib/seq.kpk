;;

(defprotocol sequential
  "Sequential protocol used by `seq` and `stream` modules."

  (reduce [collection acc fun]
    "Reduces the collection into a value.")

  (member? [collection value]
    "Checks if a value exists within the collection.")

  (count [collection]
    "Retrieves the collection's size."))

(defprotocol collection
  "A common protocol for built-in collections."

  (== [self &rest others]
    "Checks value equality of a collection compared to other colloctions.")

  (count [self]
    "Gets number of items in a collection.")

  (conj [self elem]
    "Adds an item to a collection.")

  (empty [self]
    "Obtains an empty instance of the same type as a provided collection.")

  (seq [self]
    "Gets a sequence of a collection.")
  )


;; TODO add more docs to seq functions

(ns seq
  """Provides a set of algorithms to obtain and traverse collections according to
  the `sequential` protocol."""
  (require erlang
           lists
           maps
           sequential
           (stream.reducers :as reducers)
           (collectable :as clt)
           (string.chars :as chars)
           (dictionary :as dict)))

(defmacro skip [acc]
  acc)

(defmacro next [_ entry acc]
  `[~entry & ~acc])

(defmacro acc [h n _]
  `{~h ~n})

(defmacro next-with-acc [_f entry h n _]
  `{[~entry & ~h] ~n})

(defn all?
  """Invoke the given `fun` for each item in the `collection` and returns
  `false` if at least one invocation returns `false` or `nil`. Otherwise
  returns `true`."""

  ([collection fun] (&when (list? collection))
   (do-all? collection fun))

  ([collection fun]
   (-> (sequential.reduce collection
                          {^cont :true}
                          (fn [entry _]
                            (if (fun entry)
                                {^cont :true}
                              {^halt :false})))
       (elem 1)))
  )

(defn all? [collection]
  (all? collection (fn [x] x)))

(defn any?
  """Invokes the given `fun` for each item in the `collection` and returns
  `true` if at least one invocation returns a truthy value. Returns `false`
  Otherwise."""

  ([collection fun] (&when (list? collection))
   (do-any? collection fun))

  ([collection fun]
   (-> (sequential.reduce collection
                          {^cont :false}
                          (fn [entry _]
                            (if (fun entry)
                                {^halt :true}
                              {^cont :false})))
       (elem 1)))
  )

(defn any? [collection]
  (any? collection (fn [x] x)))

(defn at [collection n &optional default]
  """Finds the element at the given index (zero-based).
  Returns `default` if index is out of bounds."""
  (case (fetch collection n)
    ({^ok e} e)
    (^error default)))

(defn chunk [collection n]
  "Shortcut to `(chunk collection n n)`."
  (chunk collection n n :nil))

(defn chunk [collection n step &optional pad] (&when (&and (> n 0)
                                                           (> step 0)))
  """Returns a collection of lists containing `n` items each, where
  each new chunk starts `step` elements into the collection.

  `step` is optional and, if not passed, defaults to `n`, i.e.
  chunks do not overlap. If the final chunk does not have `n`
  elements to fill the chunk, elements are taken as necssary
  from `pad` if it was passed. If `pad` is passed and does not
  have engouh elements to fill the chuck, then the chunk is
  returned anyway with less than `n` elements. If `pad` is not
  passed at all or is `:nil`, then the partial chunk is discarded
  from the result."""

  (let [limit (erlang.max n step)
        {acc {buf i}} (reduce collection
                                 {[] {[] 0}}
                                 (reducers.chunk n step limit))]
    (if (or (nil? pad)
            (=== i 0))
        (lists.reverse acc)
      (do
       (let [buffer (lists.reverse buf (take pad (- n i)))]
         (lists.reverse [buffer & acc]))))))

(defn chunk-by [collection fun]
  "Splits `collection` on every element for which `fun` returns a new value."

  (let [{acc res} (reduce collection
                          {[] :nil}
                          (reducers.chunk-by fun))]
    (case res
      ({buffer _}
       (lists.reverse [(lists.reverse buffer) & acc]))
      (:nil
       []))))

(defn concat [sequentials]
  """Given a sequential of sequentials, concatenates the sequentials into
  a single list."""
  (do-concat sequentials))

(defn concat
  "Concatenates the enumerable on the right with the enumerable on the left."
  ([left right] (&when (&and (list? left)
                             (list? right)))
   (lists.append left right))

  ([left right]
   (do-concat [left right]))
  )

(defn count
  "Returns the collection's size."
  ([collection] (&when (list? collection))
   (erlang.length collection))

  ([collection]
   (case (sequential.count collection)
     ({^ok value} (&when (integer? value))
      value)
     ({^error module}
      (-> (module.reduce collection
                         {^cont 0}
                         (fn [_ acc]
                           {^cont (inc acc)}))
          (elem 1)))))
  )

(defn dedup [collection]
  """Enumerate the collection, returning a list where all consecutive
  duplicated elements are collapsed to a single element."""
  (dedup-by collection (fn [x] x)))

(defn dedup-by [collection fun]
  """Enumerates the collection, returning a list where all consecutive
  duplicated elements are collapsed to a single element.

  The function `fun` maps every element to a term which is used to
  determine if two elements are duplicates."""
  (let [{list _} (reduce collection
                         {[] []}
                         (reducers.dedup fun))]
    (lists.reverse list)))

(defn drop
  """Drops the first `count` items from `collection`.

  If a negative value `count` is given, the last `count`
  values will be dropped. The collection is enumerated
  once to retrieve the proper index and the remaining
  calculation is performed from the end."""

  ([collection count] (&when (&and (list? collection)
                                   (>= count 0)))
   (do-drop collection count))

  ([collection count] (&when (>= count 0))
   (let [res (reduce collection
                     count
                     (fn
                       ([x acc] (&when (list? acc))
                        [x & acc])
                       ([x 0]
                        [x])
                       ([_ acc] (&when (> acc 0))
                        (dec acc))))]
     (if (list? res)
         (lists.reverse res)
       [])))

  ([collection count] (&when (< count 0))
   (-> (do-drop (reverse collection) (abs count))
       lists.reverse)))

(defn drop-while
  """Drops items at the beginning of `collection` while `fun` returns
  a truthy value."""

  ([collection fun] (&when (list? collection))
   (do-drop-while collection fun))

  ([collection fun]
   (let [{res _} (reduce collection
                         {[] :true}
                         (reducers.drop-while fun))]
     (lists.reverse res))))

(defn each
  """Invokes the given `fun` for each item in the `collection`.
  Returns `^ok`."""

  ([collection fun] (&when (list? collection))
   (lists.foreach fun collection)
   ^ok)

  ([collection fun]
   (reduce collection
           :nil
           (fn [entry :nil]
             (fun entry)
             :nil))
   ^ok))

(defn empty?
  """Returns `:true` if the collection is empty, otherwise `:false`."""

  ([collection] (&when (list? collection))
   (== collection []))

  ([collection]
   (-> (sequential.reduce collection
                          {^cont :true}
                          (fn [_ _]
                            {^halt :false}))
       (elem 1))))

(defn fetch
  """Finds the element at the given index (zero-based)."""

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (>= n 0)))
   (do-fetch collection n))

  ([collection n] (&when (&and (integer? n)
                               (>= n 0)))
   (let [r (sequential.reduce collection
             {^cont 0}
             (fn [entry acc]
               (case acc
                 (n {^halt entry})
                 (_ {^cont (inc acc)}))))]
     (case r
       ({^halt entry} {^ok entry})
       ({^done _} ^error))))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (do-fetch (reverse collection) (abs (inc n))))
  )

(defn filter
  """Filters the collection, i.e. returns only those elements
  for which `fun` returns a truthy value."""

  ([collection fun] (&when (list? collection))
   (lists.filter fun collection))

  ([collection fun]
   (-> (reduce collection [] (reducers.filter fun))
       lists.reverse)))

(defn filter-map
  """Filters the collection and maps its values in one pass."""

  ([collection filter mapper] (&when (list? collection))
   (lists.filtermap (fn [x]
                      (if (filter x)
                          {:true (mapper x)}
                        :false))
                    collection))

  ([collection filter mapper]
   (-> (reduce collection
               []
               (reducers.filter-map filter mapper))
       lists.reverse)))

(defn find
  """Returns the first item for which `fun` returns a truthy value. If no such
  item is found, returns `ifnone`."""

  ([collection fun]
   (find collection :nil fun))

  ([collection ifnone fun] (&when (list? collection))
   (do-find collection ifnone fun))

  ([collection ifnone fun]
   (-> (sequential.reduce collection
                          {^cont ifnone}
                          (fn [entry acc]
                            (if (fun entry)
                                {^halt entry}
                              {^cont acc})))
       (elem 1))))

(defn find-value
  """Similar to `find/3`, but returns the value of the function
  invocation instead of the element itself."""

  ([collection fun]
   (find-value collection :nil fun))

  ([collection ifnone fun] (&when (list? collection))
   (do-find-value collection ifnone fun))

  ([collection ifnone fun]
   (-> (sequential.reduce collection
                          {^cont ifnone}
                          (fn [entry acc]
                            (let [fun-entry (fun entry)]
                              (if fun-entry
                                  {^halt fun-entry}
                                {^cont acc}))))
       (elem 1))))

(defn find-index
  """Similar to `find/3`, but returns the index (zero-based)
  of the element instead of the element itself."""

  ([collection fun] (&when (list? collection))
   (do-find-index collection 0 fun))

  ([collection fun]
   (let [res (sequential.reduce collection
                                {^cont 0}
                                (fn [entry acc]
                                  (if (fun entry)
                                      {^halt acc}
                                    {^cont (inc acc)})))]
     (case res
       ({^halted entry} entry)
       ({^done _} :nil)))))

(defn flat-map [collection fun]
  """Returns a new collection appending the result of invoking `fun`
  on each corresponding item of `collection`."""

  (-> (reduce collection
              []
              (fn [entry acc]
                (reduce (fun entry)
                        acc
                        (fn [x y]
                          [x & y]))))
      lists.reverse))

(defn flat-map-reduce [collection acc fun]
  """Maps and reduces a collection, flattening the given results.

  It expects an accumulator and a function that receives each stream item
  and an accumulator, and must return a tuple containing a new stream
  (often a list) with the new accumulator or a tuple with `^halt` as first
  element and the accumulator as second."""

  (let [{_ {list acc2}} (sequential.reduce collection
                                           {^cont {[] acc}}
                                           (fn [entry {list0 acc0}]
                                             (case (fun entry acc0)
                                               ({^halt acc1}
                                                {^halt {list0 acc1}})
                                               ({[] acc1}
                                                {^cont {list0 acc1}})
                                               ({[entry] acc1}
                                                {^cont {[entry & list0] acc1}})
                                               ({entries acc1}
                                                {^cont {(reduce entries
                                                                list0
                                                                (fn [x y]
                                                                  [x & y]))
                                                        acc1}}))))]
    {(lists.reverse list) acc2}))

(defn intersperse [collection element]
  "Intersperses `element` between each element of the enumeration."
  (let [list (-> (reduce collection
                         []
                         (fn [x acc]
                           [x element & acc]))
               lists.reverse)]
    (case list
      ([] [])
      ([_ & t] t) ;; Head is a superfluous intersperser element
      )))

(defn into
  "Inserts the given sequential into a collectable."

  ([collection list] (&when (list? list))
   (lists.append list (to-list collection)))

  ([collection collectable] (&when (&and (map? collection)
                                         (map? collectable)))
   (maps.merge collectable collection))

  ([collection collectable] (&when (&and (list? collection)
                                         (map? collectable)))
   (maps.merge collectable (maps.from_list collection)))

  ([collection collectable] (&when (map? collectable))
   (reduce collection
           collectable
           (fn [{k v} acc]
             (maps.put k v acc))))

  ([collection collectable]
   (do-into collection collectable)))

(defn into
  """Inserts the given sequential into a collectable
  according to the transformation function."""

  ([collection list transform] (&when (&and (list? list)
                                            (function? transform 1)))
   (lists.append list (map collection transform)))

  ([collection collectable transform] (&when (function? transform 1))
   (let [{initial fun} (clt.into collectable)]
     (into collection
           initial
           fun
           (fn [x acc]
             (fun acc {^cont (transform x)}))))))

(defn join [collection &optional (joiner "")] (&when (binary? joiner))
  """Joins the given `collection` into a binary using `joiner` as a separator.
  If `joiner` is not passed at all, it defaults to the empty binary.

  All items in the collection must be convertible
  to a binary, otherwise an error is raised."""

  (let [reduced (reduce collection
                        ^first
                        (fn
                          ([entry ^first]
                           (seq-to-string entry))
                          ([entry acc]
                           [acc joiner & (seq-to-string entry)])))]
    (if (== reduced ^first)
        ""
      (erlang.iolist_to_binary reduced))))

(defn map
  """Returns a new collection, where each item is the result
  of invoking `fun` on each corresponding item of `collection`.

  For dicts, the function expects a key-value tuple."""

  ([collection fun] (&when (list? collection))
   (lists.map fun collection))

  ([collection fun]
   (-> (reduce collection
           []
           (reducers.map fun))
       lists.reverse)))

(defn map-join
  """Maps and joins the given `collection` in one pass.
  `joiner` can be either a binary or a list and the result
  will be of the same type as `joiner`. If `joiner` is no passed at all,
  it defaults to an empty binary.

  All items in the collection must be convertible to a binary,
  otherwise an error is raised."""

  ([collection mapper]
   (map-join collection "" mapper))

  ([collection joiner mapper] (&when (binary? joiner))
   (let [reduced (reduce collection
                   ^first
                   (fn
                     ([entry ^first]
                      (seq-to-string entry))
                     ([entry acc]
                      (acc joiner & (seq-to-string (mapper entry))))))]
     (if (== reduced ^first)
         ""
       (erlang.iolist_to_binary reduced)))))

(defn map-reduce
  """Invokes the given `fun` for each item in the `collection`
  while also keeping an accumulator. Returns a tuple where the first element
  is mapped collection and the second one is the final accumulator.

  For dicts, the first tuple element must be a `{key, value}` tuple."""
  ([collection acc fun] (&when (list? collection))
   (lists.mapfoldl fun acc collection))

  ([collection acc fun]
   (let [{list acc2} (reduce collection
                            {[] acc}
                            (fn [entry {list0 acc0}]
                              (let [{new-entry acc1} (fun entry acc0)]
                                {[new-entry & list0] acc1})))]
     {(lists.reverse list) acc2})))

(defn max [collection]
  """Returns the maximum value."""
  (reduce collection (fn [x acc] (core.max x acc))))

(defn max-by
  """Returns the maximum value as calculated by the given function."""

  ([[h & t] fun]
   (-> (reduce t
               {h (fun h)}
               (fn [entry {_ fun-max} &as old]
                 (let [fun-entry (fun entry)]
                   (if (> fun-entry fun-max)
                       {entry fun-entry}
                     old))))
       (elem 0)))

  ([[] _fun]
   ;; TODO revise to use exception
   (throw "empty error"))

  ([collection fun]
   (let [result (reduce collection
                        ^first
                        (fn
                          ([entry ^first]
                           {entry (fun entry)})
                          ([entry {_ fun-max} &as old]
                           (let [fun-entry (fun entry)]
                             (if (> fun-entry fun-max)
                                 {entry fun-entry}
                               old)))))]
     (case result
       (^first
        ;; TODO revise to use exception
        (throw "empty error"))
       ({entry _}
        entry)))))

(defn member?
  """Checks if `value` exists within the `collection`.

  Membership is tested with the match (`===`) operator."""

  ([collection value] (&when (list? collection))
   (lists.member value collection))

  ([collection value]
   (case (sequential.member? collection value)
     ({^ok value} (&when (boolean? value))
      value)
     ({^error module}
      (-> (module.reduce collection
                         {^cont :false}
                         (fn
                           ([v _] (&when (=== v value))
                            {^halt :true})
                           ([_ _]
                            {^cont :false})))
          (elem 1))))))

(defn min [collection]
  """Returns the minimum value as calculated by the given function."""
  (reduce collection (fn [x acc] (core.min x acc))))

(defn min-by
  """Returns the minimum value as calculated by the given function."""

  ([[h & t] fun]
   (-> (reduce t
               {h (fun h)}
               (fn [entry {_ fun-min} &as old]
                 (let [fun-entry (fun entry)]
                   (if (< fun-entry fun-min)
                       {entry fun-entry}
                     old))))
       (elem 0)))

  ([[] _fun]
   ;; TODO revise to use exception
   (throw "empty error"))

  ([collection fun]
   (let [result (reduce collection
                        ^first
                        (fn
                          ([entry ^first]
                           {entry (fun entry)})
                          ([entry {_ fun-min} &as old]
                           (let [fun-entry (fun entry)]
                             (if (< fun-entry fun-min)
                                 {entry fun-entry}
                                 old)))))]
     (case result
       (^first
        ;; TODO revise to use exception
        (throw "empty error"))
       ({entry _}
        entry)))))

(defn minmax [collection]
  """Returns a tuple with the minimum and maximum values."""

  (let [result (reduce collection
                       ^first
                       (fn
                         ([entry ^first]
                          {entry entry})
                         ([entry {min-value, max-value}]
                          {(core.min entry min-value)
                           (core.max entry max-value)})))]
    (case result
      (^first
       ;; TODO revise to use exception
       (throw "empty error"))
      (result
       result))))

(defn minmax-by [collection fun]
  """Returns a tuple with the minmum and maximum values as
  calculated by the given function."""

  (let [result (reduce collection
                 ^first
                 (fn
                   ([entry ^first]
                    (let [fun-entry (fun entry)]
                      {{entry fun-entry} {entry fun-entry}}))
                   ([entry {{_ fun-min} &as acc-min {_ fun-max} &as acc-max}]
                    (let [fun-entry (fun entry)
                          new-min (if (< fun-entry fun-min)
                                      {entry fun-entry}
                                    acc-min)
                          new-max (if (> fun-entry fun-max)
                                      {entry fun-entry}
                                    acc-max)]
                      {new-min new-max}))))]
    (case result
      (^first
       ;; TODO revise to use exception
       (throw "empty error"))
      ({{min-entry _} {max-entry _}}
       {min-entry max-entry}))))

(defn sum [collection]
  """Returns the sum of all values."""

  (reduce collection 0 (fn core + 2)))

(defn partition [collection fun]
  """Partitions `collcetion` into two collections, where the first one
  contains elements for which `fun` returns a truthy value, and
  the second one -- for which `fun` returns `:false` or `:nil`."""

  (let [{acc3 acc4} (reduce collection
                            {[] []}
                            (fn [entry {acc1 acc2}]
                              (if (fun entry)
                                  {[entry & acc1] acc2}
                                {acc1 [entry & acc2]})))]
    {(lists.reverse acc3) (lists.reverse acc4)}))

(defn group-by
  """Splits `collection` into groups based on `fun`.

  The result is a dict (by default a map) where each key is
  a group and each value is a list of elements from `collection`
  for which `fun` returned that group. Ordering is not necessarily
  preserved."""

  ([collection fun]
   (group-by collection #{} fun))

  ([collection dict fun]
   (reduce collection
           dict
           (fn [entry categories]
             (dict.update categories
                          (fun entry)
                          [entry]
                          (fn [v]
                            [entry & v]))))))

(defn reduce
  """Invokes `fun` for each element in the collection passing that element and the
  accumulator `acc` as arguments."""

  ([collection acc fun] (&when (list? collection))
   (lists.foldl fun acc collection))

  ([collection acc fun] (&when (map? collection))
   (maps.fold (fn [k v acc0]
                (fun {k v} acc0))
              acc
              collection))

  ([collection acc fun]
   (-> (sequential.reduce collection
                          {^cont acc}
                          (fn [x acc0]
                            {^cont (fun x acc0)}))
       (elem 1)))
  )

(defn reduce
  """Invokes `fun` for each element in the collection passing that element
  and the accumulator `acc` as arguments. `fun`'s return value is stored
  in `acc`. The first element of the collection is used as the initial value
  of `acc`. Returns the accumulator."""

  ([[h & t] fun]
   (reduce t h fun))

  ([[] _fun]
   ;; TODO revise to use exception
   (throw "empty list error"))

  ([collection fun]
   (let [result (-> (sequential.reduce collection
                                       {^cont ^first}
                                       (fn
                                         ([x ^first]
                                          {^cont {^acc x}})
                                         ([x {^acc acc}]
                                          {^cont {^acc (fun x acc)}})))
                    (elem 1))]
     (case result
       (^first
        ;; TODO revise to use exception
        (throw "empty error"))
       ({^acc acc}
        acc)))))

(defn reverse
  """Reverses the collection."""

  ([collection] (&when (list? collection))
   (lists.reverse collection))

  ([collection]
   (reverse collection [])))

(defn reverse
  """Reverses the collection and appends the tail."""

  ([collection tail] (&when (&and (list? collection)
                                  (list? tail)))
   (lists.reverse collection tail))

  ([collection tail]
   (reduce collection
           (to-list tail)
           (fn [entry acc]
             [entry & acc])))
  )

(defn take
  """Takes the first `count` items from the collection.

  `count` must be an integer. If a negative `count` is given, the last `count`
  values will be taken. For such, the collection is fully enumerated keeping up
  to `2 * count` elements in memery. Once the end of the collection is reached,
  the last `count` elements are returned."""
  ([_collection 0]
   [])

  ([[] _count]
   [])

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (> n 0)))
   (do-take collection n))

  ([collection n] (&when (&and (integer? n)
                               (> n 0)))
   (let [{_ {res _}} (sequential.reduce collection
                                        {:cont {[] n}}
                                        (fn [entry {list count}]
                                          (case count
                                            (0 {^halt {list count}})
                                            (1 {^halt {[entry & list] (dec count)}})
                                            (_ {^cont {[entry & list] (dec count)}}))))]
     (lists.reverse res)))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (let [m (abs n)
         {_ buf1 buf2} (reduce collection
                               {0 [] []}
                               (fn [entry {c b1 b2}]
                                 (let [buf1 [entry & b1]
                                       count (inc c)]
                                   (if (== count m)
                                       {0 [] buf1}
                                     {count buf1 b2}))))]
     (do-take-last buf1 buf2 m [])))
  )

(defn to-list
  """Converts `collection` to a list."""

  ([collection] (&when (list? collection))
   collection)

  ([collection]
   (lists.reverse (reverse collection))))

;; Helpers

(defn- seq-to-string
  ([entry] (&when (binary? entry))
   entry)
  ([entry]
   (chars.to-string entry)))

;; Implementations

;; all?

(defn- do-all? [[h & t] fun]
  (if (fun h)
      (do-all? t fun)
    :false))

(defn- do-all? [[] _]
  :true)

;; any?

(defn- do-any? [[h & t] fun]
  (if (fun h)
      :true
    (do-any? t fun)))

(defn- do-any? [[] _]
  :false)

;; concat

(defn- do-concat [sequential]
  (let [fun (fn [x l]
              [x & l])]
    (lists.reverse (reduce sequential
                           []
                           (fn [x acc]
                             (reduce x acc fun)))))
  )

;; drop

(defn- do-drop [[] _]
  [])

(defn- do-drop [list 0]
  list)

(defn- do-drop [[_ & t] counter] (&when (> counter 0))
  (do-drop t (dec counter)))

;; drop-while

(defn- do-drop-while [[] _]
  [])

(defn- do-drop-while [[h & t] fun]
  (if (fun h)
      (do-drop-while t fun)
    [h & t]))

;; fetch

(defn- do-fetch [[] _]
  ^error)

(defn- do-fetch [[h & _] 0]
  {^ok h})

(defn- do-fetch [[_ & t] n]
  (do-fetch t (dec n)))

;; find

(defn- do-find [[] ifnone _]
  ifnone)

(defn- do-find [[h & t] ifnone fun]
  (if (fun h)
      h
    (do-find t ifnone fun)))

;; find-value

(defn- do-find-value [[] ifnone _]
  ifnone)

(defn- do-find-value [[h & t] ifnone fun]
  (let [value (fun h)]
    (if value
        value
      (do-find-value t ifnone fun))))

;; find-index

(defn- do-find-index [[] _ _]
  :nil)

(defn- do-find-index [[h & t] counter fun]
  (if (fun h)
      counter
    (do-find-index t (inc counter) fun)))

;; into

(defn- do-into [collection collectable]
  (let [{initial fun} (clt.into collectable)]
    (into collection
          initial
          fun
          (fn [x acc]
            (fun acc {^cont x})))))

(defn- into [collection initial fun callback]
  (case
      (try (reduce collection initial callback)
        (catch
          ((kind reason)
           (let [stacktrace (erlang.get_stacktrace)]
             (fun initial ^halt)
             (erlang.raise kind reason stacktrace)))))
    (acc (fun acc ^done))))

;; take

(defn- do-take [list counter]
  (do-take list counter []))

(defn- do-take [[] _counter acc]
  (lists.reverse acc))

(defn- do-take [_list 0 acc]
  (lists.reverse acc))

(defn- do-take [[h & t] counter acc] (&when (> counter 0))
  (do-take t (dec counter) [h & acc]))

(defn- do-take-last [_buf1 _buf2 0 acc]
  acc)

(defn- do-take-last [[] [] _ acc]
  acc)

(defn- do-take-last [[] [h & t] n acc]
  (do-take-last [] t (dec n) [h & acc]))

(defn- do-take-last [[h & t] buf2 n acc]
  (do-take-last t buf2 (dec n) [h & acc]))

;; Implementations of sequential for built-in collections.

(defimpl sequential list

  (defn reduce [_ {^halt acc} _fun]
    {^halted acc})
  (defn reduce [list {^suspend acc} fun]
    {^suspended acc (fn [acc1] (reduce list acc1 fun))})
  (defn reduce [[] {^cont acc} _fun]
    {^done acc})
  (defn reduce [[h & t] {^cont acc} fun]
    (reduce t (fun h acc) fun))

  (defn member? [_list _value]
    ;; TODO add macro `__MODULE__`
    {^error ^"sequential.list"})
  (defn count [_list]
    ;; TODO add macro `__MODULE__`
    {^error ^"sequential.list"})
  )

(defimpl sequential map
  (require maps)

  (defn reduce [map acc fun]
    (sequential.reduce (maps.to_list map)
                       acc
                       fun))

  (defn member? [map {key value}]
    {^ok (match? {^ok value}
                 (maps.find key map))})

  (defn member? [_map _other]
    {^ok :false})

  (defn count [map]
    {^ok (map-size map)}))

;; TODO

;; (defprotocol seq
;;   "A protocol for sequence."

;;   ;; clojure seq protocol

;;   (defn first [self]
;;     "Returns the first item in the collection.")

;;   (defn rest [self]
;;     "Returns a possibly empty seq of the items after the first.")

;;   (defn next [self]
;;     """Returns a seq of the items after the first.
;;     If there are no more items, returns nil.""")

;;   ;; elixir enum protocol

;;   )
