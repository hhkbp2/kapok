;;

(defprotocol sequential
  "Sequential protocol used by `seq` and `stream` modules."

  (reduce [collection acc fun]
    "Reduces the collection into a value.")

  (member? [collection value]
    "Checks if a value exists within the collection.")

  (count [collection]
    "Retrieves the collection's size."))

(defprotocol collection
  "A common protocol for built-in collections."

  (== [self &rest others]
    "Checks value equality of a collection compared to other colloctions.")

  (count [self]
    "Gets number of items in a collection.")

  (conj [self elem]
    "Adds an item to a collection.")

  (empty [self]
    "Obtains an empty instance of the same type as a provided collection.")

  (seq [self]
    "Gets a sequence of a collection.")
  )


;; TODO add more docs to seq functions

(ns seq
  """Provides a set of algorithms to obtain and traverse collections according to
  the `sequential` protocol."""
  (require erlang
           lists
           maps
           sequential
           (stream.reducers :as reducers)))

(defmacro skip [acc]
  acc)

(defmacro next [_ entry acc]
  `[~entry & ~acc])

(defmacro acc [h, n, _]
  `{~h ~n})

(defmacro next-with-acc [_f entry h n _]
  `{[~entry & ~h] ~n})

(defn all?
  """Invoke the given `fun` for each item in the `collection` and returns
  `false` if at least one invocation returns `false` or `nil`. Otherwise
  returns `true`."""

  ([collection fun] (&when (list? collection))
   (do-all? collection fun))

  ([collection fun]
   (-> (sequential.reduce collection
                          {^cont :true}
                          (fn [entry _]
                            (if (fun entry)
                                {^cont :true}
                              {^halt :false})))
       (elem 1)))
  )

(defn all? [collection]
  (all? collection (fn [x] x)))

(defn any?
  """Invokes the given `fun` for each item in the `collection` and returns
  `true` if at least one invocation returns a truthy value. Returns `false`
  Otherwise."""

  ([collection fun] (&when (list? collection))
   (do-any? collection fun))

  ([collection fun]
   (-> (sequential.reduce collection
                          {^cont :false}
                          (fn [entry _]
                            (if (fun entry)
                                {^halt :true}
                              {^cont :false})))
       (elem 1)))
  )

(defn any? [collection]
  (any? collection (fn [x] x)))

(defn at [collection n &optional default]
  """Finds the element at the given index (zero-based).
  Returns `default` if index is out of bounds."""
  (case (fetch collection n)
    ({^ok e} e)
    (^error default)))

(defn chunk [collection n]
  "Shortcut to `(chunk collection n n)`."
  (chunk collection n n :nil))

(defn chunk [collection n step &optional pad] (&when (&and (> n 0)
                                                           (> step 0)))
  """Returns a collection of lists containing `n` items each, where
  each new chunk starts `step` elements into the collection.

  `step` is optional and, if not passed, defaults to `n`, i.e.
  chunks do not overlap. If the final chunk does not have `n`
  elements to fill the chunk, elements are taken as necssary
  from `pad` if it was passed. If `pad` is passed and does not
  have engouh elements to fill the chuck, then the chunk is
  returned anyway with less than `n` elements. If `pad` is not
  passed at all or is `:nil`, then the partial chunk is discarded
  from the result."""
  ;; TODO add impl
  (let [limit (erlang.max n step)
        {acc {buf i}} (reduce collection
                                 {[] {[] 0}}
                                 (reducers.chunk n step limit))]
    (if (or (nil? pad)
            (=== i 0))
        (lists.reverse acc)
      (do
       (let [buffer (lists.reverse buf (take pad (- n i)))]
         (lists.reverse [buffer & acc]))))))

(defn chunk-by [collection fun]
  "Splits `collection` on every element for which `fun` returns a new value."
  ;; TODO add impl
  (let [{acc res} (reduce collection
                          {[] :nil}
                          (reducers.chunk-by fun))]
    (case res
      ({buffer _}
       (lists.reverse [(lists.reverse buffer) & acc]))
      (:nil
       []))))

(defn concat [sequentials]
  """Given a sequential of sequentials, concatenates the sequentials into
  a single list."""
  (do-concat sequentials))

(defn concat
  "Concatenates the enumerable on the right with the enumerable on the left."
  ([left right] (&when (&and (list? left)
                             (list? right)))
   (lists.append left right))

  ([left right]
   (do-concat [left right]))
  )

(defn count
  "Returns the collection's size."
  ([collection] (&when (list? collection))
   (erlang.length collection))

  ([collection]
   (case (sequential.count collection)
     ({^ok value} (&when (integer? value))
      value)
     ({^error module}
      (-> (module.reduce collection
                         {^cont 0}
                         (fn [_ acc]
                           {^cont (inc acc)}))
          (elem 1)))))
  )

(defn dedup [collection]
  """Enumerate the collection, returning a list where all consecutive
  duplicated elements are collapsed to a single element."""
  (dedup-by collection (fn [x] x)))

(defn dedup-by [collection fun]
  """Enumerates the collection, returning a list where all consecutive
  duplicated elements are collapsed to a single element.

  The function `fun` maps every element to a term which is used to
  determine if two elements are duplicates."""
  (let [{list _} (reduce collection
                         {[] []}
                         (reducers.dedup fun))]
    (lists.reverse list)))

(defn drop
  """Drops the first `count` items from `collection`.

  If a negative value `count` is given, the last `count`
  values will be dropped. The collection is enumerated
  once to retrieve the proper index and the remaining
  calculation is performed from the end."""

  ([collection count] (&when (&and (list? collection)
                                   (>= count 0)))
   (do-drop collection count))

  ([collection count] (&when (>= count 0))
   (let [res (reduce collection
                     count
                     (fn
                       ([x acc] (&when (list? acc))
                        [x & acc])
                       ([x 0]
                        [x])
                       ([_ acc] (&when (> acc 0))
                        (dec acc))))]
     (if (list? res)
         (lists.reverse res)
       [])))

  ([collection count] (&when (< count 0))
   (-> (do-drop (reverse collection) (abs count))
       lists.reverse)))

(defn drop-while
  """Drops items at the beginning of `collection` while `fun` returns
  a truthy value."""

  ([collection fun] (&when (list? collection))
   (do-drop-while collection fun))

  ([collection fun]
   (let [{res _} (reduce collection
                         {[] :true}
                         (reducers.drop-while fun))]
     (lists.reverse res))))

(defn fetch
  """Finds the element at the given index (zero-based)."""

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (>= n 0)))
   (do-fetch collection n))

  ([collection n] (&when (&and (integer? n)
                               (>= n 0)))
   (let [r (sequential.reduce collection
             {^cont 0}
             (fn [entry acc]
               (case acc
                 (n {^halt entry})
                 (_ {^cont (inc acc)}))))]
     (case r
       ({^halt entry} {^ok entry})
       ({^done _} ^error))))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (do-fetch (reverse collection) (abs (inc n))))
  )

(defn reduce
  """Invokes `fun` for each element in the collection passing that element and the
  accumulator `acc` as arguments."""

  ([collection acc fun] (&when (list? collection))
   (lists.foldl fun acc collection))

  ([collection acc fun] (&when (map? collection))
   (maps.fold (fn [k v acc0]
                (fun {k v} acc0))
              acc
              collection))

  ([collection acc fun]
   (-> (sequential.reduce collection
                          {^cont acc}
                          (fn [x acc0]
                            {^cont (fun x acc0)}))
       (elem 1)))
  )

(defn reverse
  """Reverses the collection."""

  ([collection] (&when (list? collection))
   (lists.reverse collection))

  ([collection]
   (reverse collection [])))

(defn reverse
  """Reverses the collection and appends the tail."""

  ([collection tail] (&when (&and (list? collection)
                                  (list? tail)))
   (lists.reverse collection tail))

  ([collection tail]
   (reduce collection
           (to-list tail)
           (fn [entry acc]
             [entry & acc])))
  )

(defn take
  """Takes the first `count` items from the collection.

  `count` must be an integer. If a negative `count` is given, the last `count`
  values will be taken. For such, the collection is fully enumerated keeping up
  to `2 * count` elements in memery. Once the end of the collection is reached,
  the last `count` elements are returned."""
  ([_collection 0]
   [])

  ([[] _count]
   [])

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (> n 0)))
   (do-take collection n))

  ([collection n] (&when (&and (integer? n)
                               (> n 0)))
   (let [{_ {res _}} (sequential.reduce collection
                                        {:cont {[] n}}
                                        (fn [entry {list count}]
                                          (case count
                                            (0 {^halt {list count}})
                                            (1 {^halt {[entry & list] (dec count)}})
                                            (_ {^cont {[entry & list] (dec count)}}))))]
     (lists.reverse res)))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (let [m (abs n)
         {_ buf1 buf2} (reduce collection
                               {0 [] []}
                               (fn [entry {c b1 b2}]
                                 (let [buf1 [entry & b1]
                                       count (inc c)]
                                   (if (== count m)
                                       {0 [] buf1}
                                     {count buf1 b2}))))]
     (do-take-last buf1 buf2 m [])))
  )

(defn to-list
  """Converts `collection` to a list."""

  ([collection] (&when (list? collection))
   collection)

  ([collection]
   (lists.reverse (reverse collection))))

;; Implementations

;; all?

(defn- do-all? [[h & t] fun]
  (if (fun h)
      (do-all? t fun)
    :false))

(defn- do-all? [[] _]
  :true)

;; any?

(defn- do-any? [[h & t] fun]
  (if (fun h)
      :true
    (do-any? t fun)))

(defn- do-any? [[] _]
  :false)

;; concat

(defn- do-concat [sequential]
  (let [fun (fn [x l]
              [x & l])]
    (lists.reverse (reduce sequential
                           []
                           (fn [x acc]
                             (reduce x acc fun)))))
  )

;; drop

(defn- do-drop [[] _]
  [])

(defn- do-drop [list 0]
  list)

(defn- do-drop [[_ & t] counter] (&when (> counter 0))
  (do-drop t (dec counter)))

;; drop-while

(defn- do-drop-while [[] _]
  [])

(defn- do-drop-while [[h & t] fun]
  (if (fun h)
      (do-drop-while t fun)
    [h & t]))

;; fetch

(defn- do-fetch [[] _]
  ^error)

(defn- do-fetch [[h & _] 0]
  {^ok h})

(defn- do-fetch [[_ & t] n]
  (do-fetch t (dec n)))

;; take

(defn- do-take [list counter]
  (do-take list counter []))

(defn- do-take [[] _counter acc]
  (lists.reverse acc))

(defn- do-take [_list 0 acc]
  (lists.reverse acc))

(defn- do-take [[h & t] counter acc] (&when (> counter 0))
  (do-take t (dec counter) [h & acc]))

(defn- do-take-last [_buf1 _buf2 0 acc]
  acc)

(defn- do-take-last [[] [] _ acc]
  acc)

(defn- do-take-last [[] [h & t] n acc]
  (do-take-last [] t (dec n) [h & acc]))

(defn- do-take-last [[h & t] buf2 n acc]
  (do-take-last t buf2 (dec n) [h & acc]))

;; Implementations of sequential for built-in collections.

(defimpl sequential list

  (defn reduce [_ {^halt acc} _fun]
    {^halted acc})
  (defn reduce [list {^suspend, acc} fun]
    {^suspended acc (fn [acc1] (reduce list acc1 fun))})
  (defn reduce [[] {^cont acc} _fun]
    {^done acc})
  (defn reduce [[h & t] {^cont acc} fun]
    (reduce t (fun h acc) fun))

  (defn member? [_list, _value]
    ;; TODO add macro `__MODULE__`
    {^error ^"sequential.list"})
  (defn count [_list]
    ;; TODO add macro `__MODULE__`
    {^error ^"sequential.list"})
  )

(defimpl sequential map
  (require maps)

  (defn reduce [map acc fun]
    (sequential.reduce (maps.to_list map)
                       acc
                       fun))

  (defn member? [map {key value}]
    {^ok (match? {^ok value}
                 (maps.find key map))})

  (defn member? [_map _other]
    {^ok :false})

  (defn count [map]
    {^ok (map-size map)}))

;; TODO

;; (defprotocol seq
;;   "A protocol for sequence."

;;   ;; clojure seq protocol

;;   (defn first [self]
;;     "Returns the first item in the collection.")

;;   (defn rest [self]
;;     "Returns a possibly empty seq of the items after the first.")

;;   (defn next [self]
;;     """Returns a seq of the items after the first.
;;     If there are no more items, returns nil.""")

;;   ;; elixir enum protocol

;;   )
