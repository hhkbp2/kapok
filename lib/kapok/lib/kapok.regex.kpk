(ns kapok.regex
  """Regular expressions for Kapok built on top of Erlang's `re` module.

  As the `re` module, regex is based on PCRE
  (Perl Compatible Regular Expressions). More information can be
  found in the [`re` documentation](http://www.erlang.org/doc/man/re.html).

  Regular expressions in Kapok can be created using `(regex.compile! 2)`
  or using the constructor `(new 2)`:

      # A simple regular expression that matches foo anywhere in the string
      (new "foo")

      # A regular expression with case insensitive and unicode options
      (new "foo" "iu")

  A regex is represented internally as the `regex` struct. Therefore,
  you can use the struct/map syntax whenever there is a need to match on them.

  ## Modifiers

  The modifiers available when creating a regex are:

    * `unicode` (u) - enables unicode specific patterns like `\p` and changes
      modifiers like `\w`, `\W`, `\s` and friends to also match on unicode.
      It expects valid unicode strings to be given on match

    * `caseless` (i) - add case insensitivity

    * `dotall` (s) - causes dot to match newlines and also set newline to
      any crlf; the new line setting can be overridden by setting `(*CR)` or
      `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation

    * `multiline` (m) - causes `^` and `$` to mark the beginning and end of
      each line; use `\A` and `\z` to match the end or beginning of the string

    * `extended` (x) - whitespace characters are ignored except when escaped
      and allow `#` to delimit comments

    * `firstline` (f) - forces the unanchored pattern to match before or at the
      first newline, though the matched text may continue over the newline

    * `ungreedy` (U) - inverts the "greediness" of the regexp
      (the previous `r` option is deprecated in favor of `U`)

  The options not available are:

    * `anchored` - not available, use `^` or `\A` instead
    * `dollar_endonly` - not available, use `\z` instead
    * `no_auto_capture` - not available, use `?:` instead
    * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or
      `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the
      re documentation

  ## Captures

  Many functions in this module allows what to capture in a regex
  match via the `#capture` option. The supported values are:

    * `#all` - all captured subpatterns including the complete matching string
      (this is the default)

    * `#first` - only the first captured subpattern, which is always the
      complete matching part of the string; all explicitly captured subpatterns
      are discarded

    * `#all_but_first` - all but the first matching subpattern, i.e. all
      explicitly captured subpatterns, but not the complete matching part of
      the string

    * `#none` - do not return matching subpatterns at all

    * `#all_names` - captures all names in the regex

    * `list(binary)` - a list of named captures to capture

  """

  (require io_lib
           re))

(defns kapok.regex.compile-error
  (defexception [{#message "regex could not be compiled"}]))

(defstruct
  (#re-pattern :nil)
  (#source "")
  (#opts ""))

(defn compile
  """Compiles the regular expression.

  The given options can either be a binary with the characters
  representing the regex options, or a list of options,
  as expected by the [Erlang `re` docs](http://www.erlang.org/doc/man/re.html).

  It returns `{#ok regex}` in case of success, `{#error reason}` otherwise.

  ## Examples

      kapok> (regex.compile "foo")
      ;; TODO define the string representation of regex.
      {#ok (regex "foo")}

      kapok> (regex.compile "*foo")
      {#error {#'nothing to repeat', 0}}

  """
  ([source]
   (compile source ""))

  ([source options] (&when (binary? options))
   (case (translate-options options [])
     ({#error rest}
      {#error {#invalid_option rest}})
     (translated-options
      (compile source translated-options options))))

  ([source options] (&when (list? options))
   (compile source options ""))

  ([source opts doc-opts] (&when (binary? source))
   (case (re.compile source opts)
     ({#ok re-pattern}
      {#ok (new :re-pattern re-pattern
                :source source
                :opts doc-opts)})
     (error
      error))))

(defn compile! [source &optional (options "")]
  """Compiles the regular expression according to the given options.
  Fails with `regex.compile-error` if the regex cannot be compiled.
  """
  (case (compile source options)
    ({#ok regex}
     regex)
    ({#error {reason at}}
     (let [message (io_lib.format "~p at position ~p" [reason at])]
       (raise kapok.regex.compile-error [{#message message}])))))

;; Private Helpers

(defn- translate-options [<<(\u) (t :binary)>> acc]   ;; char 'u'
  (translate-options t [#unicode #ucp & acc]))
(defn- translate-options [<<(\i) (t :binary)>> acc]   ;; char 'i'
  (translate-options t [#caseless & acc]))
(defn- translate-options [<<(\x78) (t :binary)>> acc] ;; char 'x'
  (translate-options t [#extended & acc]))
(defn- translate-options [<<(\x66) (t :binary)>> acc] ;; char 'f'
  (translate-options t [#firstline & acc]))
(defn- translate-options [<<(\U) (t :binary)>> acc]   ;; char 'U'
  (translate-options t [#ungreedy & acc]))
(defn- translate-options [<<(\x73) (t :binary)>> acc] ;; char 's'
  (translate-options t [#dotall & acc]))
(defn- translate-options [<<(\m) (t :binary)>> acc]   ;; char 'm'
  (translate-options t [#multiline & acc]))

;; TODO Deprecated in funture
(defn- translate-options [<<(\x72) (t :binary)>> acc] ;; char 'r'
  (translate-options t [#ungreedy & acc]))

(defn- translate-options [<<>> acc]
  acc)
(defn- translate-options [rest _acc]
  {#error rest})
