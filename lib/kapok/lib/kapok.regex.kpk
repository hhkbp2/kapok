(ns kapok.regex
  """Regular expressions for Kapok built on top of Erlang's `re` module.

  As the `re` module, regex is based on PCRE
  (Perl Compatible Regular Expressions). More information can be
  found in the [`re` documentation](http://www.erlang.org/doc/man/re.html).

  Regular expressions in Kapok can be created using `(regex.compile! 2)`
  or using the constructor `(new 2)`:

      # A simple regular expression that matches foo anywhere in the string
      (new "foo")

      # A regular expression with case insensitive and unicode options
      (new "foo" "iu")

  A regex is represented internally as the `regex` struct. Therefore,
  you can use the struct/map syntax whenever there is a need to match on them.

  ## Modifiers

  The modifiers available when creating a regex are:

    * `unicode` (u) - enables unicode specific patterns like `\p` and changes
      modifiers like `\w`, `\W`, `\s` and friends to also match on unicode.
      It expects valid unicode strings to be given on match

    * `caseless` (i) - add case insensitivity

    * `dotall` (s) - causes dot to match newlines and also set newline to
      any crlf; the new line setting can be overridden by setting `(*CR)` or
      `(*LF)` or `(*CRLF)` or `(*ANY)` according to re documentation

    * `multiline` (m) - causes `^` and `$` to mark the beginning and end of
      each line; use `\A` and `\z` to match the end or beginning of the string

    * `extended` (x) - whitespace characters are ignored except when escaped
      and allow `#` to delimit comments

    * `firstline` (f) - forces the unanchored pattern to match before or at the
      first newline, though the matched text may continue over the newline

    * `ungreedy` (U) - inverts the "greediness" of the regexp
      (the previous `r` option is deprecated in favor of `U`)

  The options not available are:

    * `anchored` - not available, use `^` or `\A` instead
    * `dollar_endonly` - not available, use `\z` instead
    * `no_auto_capture` - not available, use `?:` instead
    * `newline` - not available, use `(*CR)` or `(*LF)` or `(*CRLF)` or
      `(*ANYCRLF)` or `(*ANY)` at the beginning of the regexp according to the
      re documentation

  ## Captures

  Many functions in this module allows what to capture in a regex
  match via the `#capture` option. The supported values are:

    * `#all` - all captured subpatterns including the complete matching string
      (this is the default)

    * `#first` - only the first captured subpattern, which is always the
      complete matching part of the string; all explicitly captured subpatterns
      are discarded

    * `#all_but_first` - all but the first matching subpattern, i.e. all
      explicitly captured subpatterns, but not the complete matching part of
      the string

    * `#none` - do not return matching subpatterns at all

    * `#all_names` - captures all names in the regex

    * `list(binary)` - a list of named captures to capture

  """

  (require io_lib
           re
           (kapok (alist))))

(defns kapok.regex.compile-error
  (defexception [{#message "regex could not be compiled"}]))

(defstruct
  (#re-pattern :nil)
  (#source "")
  (#opts ""))

(defn compile
  """Compiles the regular expression.

  The given options can either be a binary with the characters
  representing the regex options, or a list of options,
  as expected by the [Erlang `re` docs](http://www.erlang.org/doc/man/re.html).

  It returns `{#ok regex}` in case of success, `{#error reason}` otherwise.

  ## Examples

      kapok> (regex.compile "foo")
      ;; TODO define the string representation of regex.
      {#ok (regex "foo")}

      kapok> (regex.compile "*foo")
      {#error {#'nothing to repeat', 0}}

  """
  ([source]
   (compile source ""))

  ([source options] (&when (binary? options))
   (case (translate-options options [])
     ({#error rest}
      {#error {#invalid_option rest}})
     (translated-options
      (compile source translated-options options))))

  ([source options] (&when (list? options))
   (compile source options ""))

  ([source opts doc-opts] (&when (binary? source))
   (case (re.compile source opts)
     ({#ok re-pattern}
      {#ok (new :re-pattern re-pattern
                :source source
                :opts doc-opts)})
     (error
      error))))

(defn compile! [source &optional (options "")]
  """Compiles the regular expression according to the given options.
  Fails with `regex.compile-error` if the regex cannot be compiled.
  """
  (case (compile source options)
    ({#ok regex}
     regex)
    ({#error {reason at}}
     (let [message (io_lib.format "~p at position ~p" [reason at])]
       (raise kapok.regex.compile-error [{#message message}])))))

(defn regex? [#{#__struct__ struct}] (&when (== struct #'kapok.regex'))
  :true)
(defn regex? [_]
  :false)

(defn split
  """Splits the given target based on the given pattern and in the given number
  of parts.

  ## Options

    * `#parts` - when specified, splits the string into the given number of
      parts. If not specified, `#parts` defaults to `#infinity`, which will
      split the string into the maximum number of parts possible based on
      the given pattern.

    * `#trim` - whin `:true`, removes empty strings (`""`) from the result.

    * `#on` - specifies which captures to split the string on, and in what
      order. Defaults to `#first` which means captures inside the regex
      do not affect the splitting process.

  ## Examples

      kapok> (regex.split (regex.new "-") "a-b-c")
      ["a" "b" "c"]

      kapok> (regex.split (regex.new "-") "a-b-c" [{#parts 2}])
      ["a" "b-c"]

      kapok> (regex.split (regex.new "-") "abc")
      ["abc"]

      kapok> (regex.split (regex.new "") "abc")
      ["a" "b" "c" ""]

      kapok> (regex.split (regex.new "a(?<second>b)c") "abc")
      ["" ""]

      kapok> (regex.split (regex.new "a(?<second>b)c") "abc" [{#on [:second]}])
      ["a" "c"]

  """
  ([regex string]
   (split regex string []))

  ([#{#__struct__ #'kapok.regex'} "" opts]
   (if (alist.get opts #trim :false)
       []
     [""]))

  ([#{#__struct__ #'kapok.regex'
      #re_pattern compiled}
    string
    opts] (&when (binary? string))
   (let [on (alist.get opts #on #first)]
     (case (re.run string compiled [#global {#capture on}])
       ({#match matches}
        (do-split matches string 0
                  (parts-to-index (alist.get opts #parts #infinity))
                  (alist.get opts #trim :false)))
       (#match
        [string])
       (#nomatch
        [string]))))
  )

(defn- parts-to-index [#infinity]
  0)
(defn- parts-to-index [n] (&when (&and (integer? n)
                                       (> n 0)))
  n)

(defn- do-split [_ string offset _counter :true]
    (&when (<= (byte-size string) offset))
  [])

(defn- do-split [_ string offset 1 _trim]
  [(binary-part string offset (- (byte-size string) offset))])

(defn- do-split [[] string offset _counter _trim]
  [(binary-part string offset (- (byte-size string) offset))])

(defn- do-split [[[{pos _} & h] & t] string offset counter trim]
    (&when (< (- pos offset) 0))
  (do-split [h & t] string offset counter trim))

(defn- do-split [[[] & t] string offset counter trim]
  (do-split t string offset counter trim))

(defn- do-split [[[{pos length} & h] & t] string offset counter trim]
  (let [new-offset (+ pos length)
        keep (- pos offset)]
    (if (and (== keep 0)
             (or (== length 0)
                 trim))
        (do-split [h & t] string new-offset counter trim)
      (let [<<(_ :binary (:size offset)) (part :binary (:size keep)) (_ :binary)>> string]
        [part & (do-split [h & t] string new-offset (dec counter) trim)]))))

;; Private Helpers

(defn- translate-options [<< $u (t :binary) >> acc]
  (translate-options t [#unicode #ucp & acc]))
(defn- translate-options [<< $i (t :binary) >> acc]
  (translate-options t [#caseless & acc]))
(defn- translate-options [<< $x (t :binary) >> acc]
  (translate-options t [#extended & acc]))
(defn- translate-options [<< $f (t :binary) >> acc]
  (translate-options t [#firstline & acc]))
(defn- translate-options [<< $U (t :binary) >> acc]
  (translate-options t [#ungreedy & acc]))
(defn- translate-options [<< $s (t :binary) >> acc]
  (translate-options t [#dotall & acc]))
(defn- translate-options [<< $m (t :binary) >> acc]
  (translate-options t [#multiline & acc]))

;; TODO Deprecated in funture
(defn- translate-options [<< $r (t :binary) >> acc]
  (translate-options t [#ungreedy & acc]))

(defn- translate-options [<<>> acc]
  acc)
(defn- translate-options [rest _acc]
  {#error rest})
