;;

(defprotocol kapok.sequential
  "Sequential protocol used by `seq` and `stream` modules."

  (reduce [collection acc fun]
    "Reduces the collection into a value.")

  (member? [collection value]
    "Checks if a value exists within the collection.")

  (count [collection]
    "Retrieves the collection's size."))

(defprotocol kapok.collection
  "A common protocol for built-in collections."

  (== [self &rest others]
    "Checks value equality of a collection compared to other colloctions.")

  (count [self]
    "Gets number of items in a collection.")

  (conj [self elem]
    "Adds an item to a collection.")

  (empty [self]
    "Obtains an empty instance of the same type as a provided collection.")

  (seq [self]
    "Gets a sequence of a collection.")
  )


;; TODO add more docs to seq functions

(ns kapok.seq
  """Provides a set of algorithms to obtain and traverse collections according to
  the `sequential` protocol."""
  (require erlang
           random
           lists
           maps
           gb_sets

           (kapok (sequential
                   (stream.reducers :as reducers)
                   (collectable :as clt)
                   (string.chars :as chars)
                   dict
                   tuple))))

(defmacro skip [acc]
  acc)

(defmacro next [_ entry acc]
  `[~entry & ~acc])

(defmacro acc [h n _]
  `{~h ~n})

(defmacro next-with-acc [_f entry h n _]
  `{[~entry & ~h] ~n})

(defn all?
  """Invoke the given `fun` for each item in the `collection` and returns
  `false` if at least one invocation returns `false` or `nil`. Otherwise
  returns `true`."""

  ([collection fun] (&when (list? collection))
   (do-all? collection fun))

  ([collection fun]
   (-> (sequential.reduce collection
                          {#cont :true}
                          (fn [entry _]
                            (if (fun entry)
                                {#cont :true}
                              {#halt :false})))
       (elem 1)))
  )

(defn all? [collection]
  (all? collection (fn [x] x)))

(defn any?
  """Invokes the given `fun` for each item in the `collection` and returns
  `true` if at least one invocation returns a truthy value. Returns `false`
  Otherwise."""

  ([collection fun] (&when (list? collection))
   (do-any? collection fun))

  ([collection fun]
   (-> (sequential.reduce collection
                          {#cont :false}
                          (fn [entry _]
                            (if (fun entry)
                                {#halt :true}
                              {#cont :false})))
       (elem 1)))
  )

(defn any? [collection]
  (any? collection (fn [x] x)))

(defn at [collection n &optional default]
  """Finds the element at the given index (zero-based).
  Returns `default` if index is out of bounds."""
  (case (fetch collection n)
    ({#ok e} e)
    (#error default)))

(defn chunk [collection n]
  "Shortcut to `(chunk collection n n)`."
  (chunk collection n n :nil))

(defn chunk [collection n step &optional pad] (&when (&and (> n 0)
                                                           (> step 0)))
  """Returns a collection of lists containing `n` items each, where
  each new chunk starts `step` elements into the collection.

  `step` is optional and, if not passed, defaults to `n`, i.e.
  chunks do not overlap. If the final chunk does not have `n`
  elements to fill the chunk, elements are taken as necssary
  from `pad` if it was passed. If `pad` is passed and does not
  have engouh elements to fill the chuck, then the chunk is
  returned anyway with less than `n` elements. If `pad` is not
  passed at all or is `:nil`, then the partial chunk is discarded
  from the result."""

  (let [limit (erlang.max n step)
        {acc {buf i}} (reduce collection
                                 {[] {[] 0}}
                                 (reducers.chunk n step limit))]
    (if (or (nil? pad)
            (=== i 0))
        (lists.reverse acc)
      (do
       (let [buffer (lists.reverse buf (take pad (- n i)))]
         (lists.reverse [buffer & acc]))))))

(defn chunk-by [collection fun]
  "Splits `collection` on every element for which `fun` returns a new value."

  (let [{acc res} (reduce collection
                          {[] :nil}
                          (reducers.chunk-by fun))]
    (case res
      ({buffer _}
       (lists.reverse [(lists.reverse buffer) & acc]))
      (:nil
       []))))

(defn concat [sequentials]
  """Given a sequential of sequentials, concatenates the sequentials into
  a single list."""
  (do-concat sequentials))

(defn concat
  "Concatenates the enumerable on the right with the enumerable on the left."
  ([left right] (&when (&and (list? left)
                             (list? right)))
   (lists.append left right))

  ([left right]
   (do-concat [left right]))
  )

(defn count
  "Returns the collection's size."
  ([collection] (&when (list? collection))
   (erlang.length collection))

  ([collection]
   (case (sequential.count collection)
     ({#ok value} (&when (integer? value))
      value)
     ({#error module}
      (-> (module.reduce collection
                         {#cont 0}
                         (fn [_ acc]
                           {#cont (inc acc)}))
          (elem 1)))))
  )

(defn dedup [collection]
  """Enumerate the collection, returning a list where all consecutive
  duplicated elements are collapsed to a single element."""
  (dedup-by collection (fn [x] x)))

(defn dedup-by [collection fun]
  """Enumerates the collection, returning a list where all consecutive
  duplicated elements are collapsed to a single element.

  The function `fun` maps every element to a term which is used to
  determine if two elements are duplicates."""
  (let [{list _} (reduce collection
                         {[] []}
                         (reducers.dedup fun))]
    (lists.reverse list)))

(defn drop
  """Drops the first `count` items from `collection`.

  If a negative value `count` is given, the last `count`
  values will be dropped. The collection is enumerated
  once to retrieve the proper index and the remaining
  calculation is performed from the end."""

  ([collection count] (&when (&and (list? collection)
                                   (>= count 0)))
   (do-drop collection count))

  ([collection count] (&when (>= count 0))
   (let [res (reduce collection
                     count
                     (fn
                       ([x acc] (&when (list? acc))
                        [x & acc])
                       ([x 0]
                        [x])
                       ([_ acc] (&when (> acc 0))
                        (dec acc))))]
     (if (list? res)
         (lists.reverse res)
       [])))

  ([collection count] (&when (< count 0))
   (-> (do-drop (reverse collection) (abs count))
       lists.reverse)))

(defn drop-while
  """Drops items at the beginning of `collection` while `fun` returns
  a truthy value."""

  ([collection fun] (&when (list? collection))
   (do-drop-while collection fun))

  ([collection fun]
   (let [{res _} (reduce collection
                         {[] :true}
                         (reducers.drop-while fun))]
     (lists.reverse res))))

(defn each
  """Invokes the given `fun` for each item in the `collection`.
  Returns `#ok`."""

  ([collection fun] (&when (list? collection))
   (lists.foreach fun collection)
   #ok)

  ([collection fun]
   (reduce collection
           :nil
           (fn [entry :nil]
             (fun entry)
             :nil))
   #ok))

(defn empty?
  """Returns `:true` if the collection is empty, otherwise `:false`."""

  ([collection] (&when (list? collection))
   (== collection []))

  ([collection]
   (-> (sequential.reduce collection
                          {#cont :true}
                          (fn [_ _]
                            {#halt :false}))
       (elem 1))))

(defn fetch
  """Finds the element at the given index (zero-based)."""

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (>= n 0)))
   (do-fetch collection n))

  ([collection n] (&when (&and (integer? n)
                               (>= n 0)))
   (let [r (sequential.reduce collection
             {#cont 0}
             (fn [entry acc]
               (case acc
                 (n {#halt entry})
                 (_ {#cont (inc acc)}))))]
     (case r
       ({#halt entry} {#ok entry})
       ({#done _} #error))))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (do-fetch (reverse collection) (abs (inc n))))
  )

(defn filter
  """Filters the collection, i.e. returns only those elements
  for which `fun` returns a truthy value."""

  ([collection fun] (&when (list? collection))
   (lists.filter fun collection))

  ([collection fun]
   (-> (reduce collection [] (reducers.filter fun))
       lists.reverse)))

(defn filter-map
  """Filters the collection and maps its values in one pass."""

  ([collection filter mapper] (&when (list? collection))
   (lists.filtermap (fn [x]
                      (if (filter x)
                          {:true (mapper x)}
                        :false))
                    collection))

  ([collection filter mapper]
   (-> (reduce collection
               []
               (reducers.filter-map filter mapper))
       lists.reverse)))

(defn find
  """Returns the first item for which `fun` returns a truthy value. If no such
  item is found, returns `ifnone`."""

  ([collection fun]
   (find collection :nil fun))

  ([collection ifnone fun] (&when (list? collection))
   (do-find collection ifnone fun))

  ([collection ifnone fun]
   (-> (sequential.reduce collection
                          {#cont ifnone}
                          (fn [entry acc]
                            (if (fun entry)
                                {#halt entry}
                              {#cont acc})))
       (elem 1))))

(defn find-value
  """Similar to `(find 3)`, but returns the value of the function
  invocation instead of the element itself."""

  ([collection fun]
   (find-value collection :nil fun))

  ([collection ifnone fun] (&when (list? collection))
   (do-find-value collection ifnone fun))

  ([collection ifnone fun]
   (-> (sequential.reduce collection
                          {#cont ifnone}
                          (fn [entry acc]
                            (let [fun-entry (fun entry)]
                              (if fun-entry
                                  {#halt fun-entry}
                                {#cont acc}))))
       (elem 1))))

(defn find-index
  """Similar to `(find 3)`, but returns the index (zero-based)
  of the element instead of the element itself."""

  ([collection fun] (&when (list? collection))
   (do-find-index collection 0 fun))

  ([collection fun]
   (let [res (sequential.reduce collection
                                {#cont 0}
                                (fn [entry acc]
                                  (if (fun entry)
                                      {#halt acc}
                                    {#cont (inc acc)})))]
     (case res
       ({#halted entry} entry)
       ({#done _} :nil)))))

(defn flat-map [collection fun]
  """Returns a new collection appending the result of invoking `fun`
  on each corresponding item of `collection`."""

  (-> (reduce collection
              []
              (fn [entry acc]
                (reduce (fun entry)
                        acc
                        (fn [x y]
                          [x & y]))))
      lists.reverse))

(defn flat-map-reduce [collection acc fun]
  """Maps and reduces a collection, flattening the given results.

  It expects an accumulator and a function that receives each stream item
  and an accumulator, and must return a tuple containing a new stream
  (often a list) with the new accumulator or a tuple with `#halt` as first
  element and the accumulator as second."""

  (let [{_ {list acc2}} (sequential.reduce collection
                                           {#cont {[] acc}}
                                           (fn [entry {list0 acc0}]
                                             (case (fun entry acc0)
                                               ({#halt acc1}
                                                {#halt {list0 acc1}})
                                               ({[] acc1}
                                                {#cont {list0 acc1}})
                                               ({[entry] acc1}
                                                {#cont {[entry & list0] acc1}})
                                               ({entries acc1}
                                                {#cont {(reduce entries
                                                                list0
                                                                (fn [x y]
                                                                  [x & y]))
                                                        acc1}}))))]
    {(lists.reverse list) acc2}))

(defn intersperse [collection element]
  "Intersperses `element` between each element of the enumeration."
  (let [list (-> (reduce collection
                         []
                         (fn [x acc]
                           [x element & acc]))
               lists.reverse)]
    (case list
      ([] [])
      ([_ & t] t) ;; Head is a superfluous intersperser element
      )))

(defn into
  "Inserts the given sequential into a collectable."

  ([collection list] (&when (list? list))
   (lists.append list (to-list collection)))

  ([collection collectable] (&when (&and (map? collection)
                                         (map? collectable)))
   (maps.merge collectable collection))

  ([collection collectable] (&when (&and (list? collection)
                                         (map? collectable)))
   (maps.merge collectable (maps.from_list collection)))

  ([collection collectable] (&when (map? collectable))
   (reduce collection
           collectable
           (fn [{k v} acc]
             (maps.put k v acc))))

  ([collection collectable]
   (do-into collection collectable)))

(defn into
  """Inserts the given sequential into a collectable
  according to the transformation function."""

  ([collection list transform] (&when (&and (list? list)
                                            (function? transform 1)))
   (lists.append list (map collection transform)))

  ([collection collectable transform] (&when (function? transform 1))
   (let [{initial fun} (clt.into collectable)]
     (into collection
           initial
           fun
           (fn [x acc]
             (fun acc {#cont (transform x)}))))))

(defn join [collection &optional (joiner "")] (&when (binary? joiner))
  """Joins the given `collection` into a binary using `joiner` as a separator.
  If `joiner` is not passed at all, it defaults to the empty binary.

  All items in the collection must be convertible
  to a binary, otherwise an error is raised."""

  (let [reduced (reduce collection
                        #first
                        (fn
                          ([entry #first]
                           (seq-to-string entry))
                          ([entry acc]
                           [acc joiner & (seq-to-string entry)])))]
    (if (== reduced #first)
        ""
      (erlang.iolist_to_binary reduced))))

(defn map
  """Returns a new collection, where each item is the result
  of invoking `fun` on each corresponding item of `collection`.

  For dicts, the function expects a key-value tuple."""

  ([collection fun] (&when (list? collection))
   (lists.map fun collection))

  ([collection fun]
   (-> (reduce collection
           []
           (reducers.map fun))
       lists.reverse)))

(defn map-join
  """Maps and joins the given `collection` in one pass.
  `joiner` can be either a binary or a list and the result
  will be of the same type as `joiner`. If `joiner` is no passed at all,
  it defaults to an empty binary.

  All items in the collection must be convertible to a binary,
  otherwise an error is raised."""

  ([collection mapper]
   (map-join collection "" mapper))

  ([collection joiner mapper] (&when (binary? joiner))
   (let [reduced (reduce collection
                   #first
                   (fn
                     ([entry #first]
                      (seq-to-string entry))
                     ([entry acc]
                      (acc joiner & (seq-to-string (mapper entry))))))]
     (if (== reduced #first)
         ""
       (erlang.iolist_to_binary reduced)))))

(defn map-reduce
  """Invokes the given `fun` for each item in the `collection`
  while also keeping an accumulator. Returns a tuple where the first element
  is mapped collection and the second one is the final accumulator.

  For dicts, the first tuple element must be a `{key, value}` tuple."""
  ([collection acc fun] (&when (list? collection))
   (lists.mapfoldl fun acc collection))

  ([collection acc fun]
   (let [{list acc2} (reduce collection
                            {[] acc}
                            (fn [entry {list0 acc0}]
                              (let [{new-entry acc1} (fun entry acc0)]
                                {[new-entry & list0] acc1})))]
     {(lists.reverse list) acc2})))

(defn max [collection]
  """Returns the maximum value."""
  (reduce collection (fn [x acc] (core.max x acc))))

(defn max-by
  """Returns the maximum value as calculated by the given function."""

  ([[h & t] fun]
   (-> (reduce t
               {h (fun h)}
               (fn [entry {_ fun-max} &as old]
                 (let [fun-entry (fun entry)]
                   (if (> fun-entry fun-max)
                       {entry fun-entry}
                     old))))
       (elem 0)))

  ([[] _fun]
   ;; TODO revise to use exception
   (throw "empty error"))

  ([collection fun]
   (let [result (reduce collection
                        #first
                        (fn
                          ([entry #first]
                           {entry (fun entry)})
                          ([entry {_ fun-max} &as old]
                           (let [fun-entry (fun entry)]
                             (if (> fun-entry fun-max)
                                 {entry fun-entry}
                               old)))))]
     (case result
       (#first
        ;; TODO revise to use exception
        (throw "empty error"))
       ({entry _}
        entry)))))

(defn member?
  """Checks if `value` exists within the `collection`.

  Membership is tested with the match (`===`) operator."""

  ([collection value] (&when (list? collection))
   (lists.member value collection))

  ([collection value]
   (case (sequential.member? collection value)
     ({#ok value} (&when (boolean? value))
      value)
     ({#error module}
      (-> (module.reduce collection
                         {#cont :false}
                         (fn
                           ([v _] (&when (=== v value))
                            {#halt :true})
                           ([_ _]
                            {#cont :false})))
          (elem 1))))))

(defn min [collection]
  """Returns the minimum value as calculated by the given function."""
  (reduce collection (fn [x acc] (core.min x acc))))

(defn min-by
  """Returns the minimum value as calculated by the given function."""

  ([[h & t] fun]
   (-> (reduce t
               {h (fun h)}
               (fn [entry {_ fun-min} &as old]
                 (let [fun-entry (fun entry)]
                   (if (< fun-entry fun-min)
                       {entry fun-entry}
                     old))))
       (elem 0)))

  ([[] _fun]
   ;; TODO revise to use exception
   (throw "empty error"))

  ([collection fun]
   (let [result (reduce collection
                        #first
                        (fn
                          ([entry #first]
                           {entry (fun entry)})
                          ([entry {_ fun-min} &as old]
                           (let [fun-entry (fun entry)]
                             (if (< fun-entry fun-min)
                                 {entry fun-entry}
                                 old)))))]
     (case result
       (#first
        ;; TODO revise to use exception
        (throw "empty error"))
       ({entry _}
        entry)))))

(defn minmax [collection]
  """Returns a tuple with the minimum and maximum values."""

  (let [result (reduce collection
                       #first
                       (fn
                         ([entry #first]
                          {entry entry})
                         ([entry {min-value, max-value}]
                          {(core.min entry min-value)
                           (core.max entry max-value)})))]
    (case result
      (#first
       ;; TODO revise to use exception
       (throw "empty error"))
      (result
       result))))

(defn minmax-by [collection fun]
  """Returns a tuple with the minmum and maximum values as
  calculated by the given function."""

  (let [result (reduce collection
                 #first
                 (fn
                   ([entry #first]
                    (let [fun-entry (fun entry)]
                      {{entry fun-entry} {entry fun-entry}}))
                   ([entry {{_ fun-min} &as acc-min {_ fun-max} &as acc-max}]
                    (let [fun-entry (fun entry)
                          new-min (if (< fun-entry fun-min)
                                      {entry fun-entry}
                                    acc-min)
                          new-max (if (> fun-entry fun-max)
                                      {entry fun-entry}
                                    acc-max)]
                      {new-min new-max}))))]
    (case result
      (#first
       ;; TODO revise to use exception
       (throw "empty error"))
      ({{min-entry _} {max-entry _}}
       {min-entry max-entry}))))

(defn sum [collection]
  """Returns the sum of all values."""

  (reduce collection 0 (fn core + 2)))

(defn partition [collection fun]
  """Partitions `collection` into two collections, where the first one
  contains elements for which `fun` returns a truthy value, and
  the second one -- for which `fun` returns `:false` or `:nil`."""

  (let [{acc3 acc4} (reduce collection
                            {[] []}
                            (fn [entry {acc1 acc2}]
                              (if (fun entry)
                                  {[entry & acc1] acc2}
                                {acc1 [entry & acc2]})))]
    {(lists.reverse acc3) (lists.reverse acc4)}))

(defn group-by
  """Splits `collection` into groups based on `fun`.

  The result is a dict (by default a map) where each key is
  a group and each value is a list of elements from `collection`
  for which `fun` returned that group. Ordering is not necessarily
  preserved."""

  ([collection fun]
   (group-by collection #{} fun))

  ([collection dict fun]
   (reduce collection
           dict
           (fn [entry categories]
             (dict.update categories
                          (fun entry)
                          [entry]
                          (fn [v]
                            [entry & v]))))))

(defn reduce
  """Invokes `fun` for each element in the collection passing that element and the
  accumulator `acc` as arguments."""

  ([collection acc fun] (&when (list? collection))
   (lists.foldl fun acc collection))

  ([collection acc fun] (&when (map? collection))
   (maps.fold (fn [k v acc0]
                (fun {k v} acc0))
              acc
              collection))

  ([collection acc fun]
   (-> (sequential.reduce collection
                          {#cont acc}
                          (fn [x acc0]
                            {#cont (fun x acc0)}))
       (elem 1)))
  )

(defn reduce
  """Invokes `fun` for each element in the collection passing that element
  and the accumulator `acc` as arguments. `fun`'s return value is stored
  in `acc`. The first element of the collection is used as the initial value
  of `acc`. Returns the accumulator."""

  ([[h & t] fun]
   (reduce t h fun))

  ([[] _fun]
   ;; TODO revise to use exception
   (throw "empty list error"))

  ([collection fun]
   (let [result (-> (sequential.reduce collection
                                       {#cont #first}
                                       (fn
                                         ([x #first]
                                          {#cont {#acc x}})
                                         ([x {#acc acc}]
                                          {#cont {#acc (fun x acc)}})))
                    (elem 1))]
     (case result
       (#first
        ;; TODO revise to use exception
        (throw "empty error"))
       ({#acc acc}
        acc)))))

(defn reject
  """Returns elements of `collection` for which `fun` returns
  `:false` or `:nil`."""

  ([collection fun] (&when (list? collection))
   (lists.filter (fn [x] (not (fun x)))
                 collection))

  ([collection fun]
   (-> (reduce collection
               []
               (reducers.reject fun))
       lists.reverse)))

(defn reverse
  """Reverses the collection."""

  ([collection] (&when (list? collection))
   (lists.reverse collection))

  ([collection]
   (reverse collection [])))

(defn reverse
  """Reverses the collection and appends the tail."""

  ([collection tail] (&when (&and (list? collection)
                                  (list? tail)))
   (lists.reverse collection tail))

  ([collection tail]
   (reduce collection
           (to-list tail)
           (fn [entry acc]
             [entry & acc]))))

(defn reverse-slice [collection start count] (&when (&and (>= start 0)
                                                          (>= count 0)))
  """Reverses the collection in the range from initial position `start`
  through `count` elements. If `count` is greater than the size of
  the rest of the collection, then this function will reverse the rest
  of the collection."""
  (let [list (reverse collection)
        length (length list)
        count1 (min count (- length start))]
    (if (> count1 0)
        (reverse-slice list length (+ start count1) count1 [])
      (lists.reverse list))))

(defn random [collection]
  """Returns a random element of a collection."""

  (case (random collection 1)
    ([]
     ;; TODO revise to use exception
     (throw "empty error"))
    ([e]
     e)))

(defn random
  """Returns a random sublist of a collection."""

  ([collection count] (&when (> count 0))
   ;; TODO
   (let [sample (tuple.duplicate :nil count)
                reducer (fn [x {i sample0}]
                          (let [j (random-index i)]
                            (if (< i count)
                                (let [swapped (elem sample j)]
                                  {(inc i)
                                   (-> sample0
                                       (set-elem i swapped)
                                       (set-elem j x))})
                              (if (< j count)
                                  {(inc i)
                                   (-> sample0
                                       (set-elem j x))}))))
                {n sample1} (reduce collection {0 sample} reducer)]
     (-> sample1
         tuple.to-list
         (take (min count n)))))

  ([_collection 0]
   []))

(defn scan [seq fun]
  """Applies the given function to each element in the collection,
  storing the result in a list and passing it as the accumulator
  for the next computation."""

  (let [{res _} (reduce seq
                        {[] #first}
                        (reducers.scan-2 fun))]
    (lists.reverse res)))

(defn scan [seq acc fun]
  """Applies the given function to each element in the collection,
  storing the result in a list and passing it as the accumulator
  for the next computation. Uses the given `acc` as the staring value."""
  (let [{res _} (reduce seq
                        {[] acc}
                        (reducers.scan-3 fun))]
    (lists.reverse res)))

(defn shuffle [collection]
  """Returns a list of collection elements shuffled."""
  (let [randomized (reduce collection
                           []
                           (fn [x acc]
                             [{(rand.uniform) x} & acc]))]
    (unwrap (lists.keysort 1 randomized) [])))

(defn slice
  """Returns a subset list of the given collection. Drops elements
  until element position `start` , then takes `count` elements.

  If the count is greater than collection length, it returns as
  much as possible. If zero, then it returns `[]`."""

  ([_collection _start 0]
   [])

  ([collection start count] (&when (< start 0))
   (let [{list new-start} (traverse-and-count collection start)]
     (if (>= new-start 0)
         (slice list new-start count)
         [])))

  ([collection start count] (&when (&and (list? collection)
                                         (>= start 0)
                                         (> count 0)))
   (do-slice collection start count))

  ([collection start count] (&when (&and (>= start 0)
                                         (> count 0)))
   (let [{_ _ list} (-> (sequential.reduce
                         collection
                         {#cont {start count []}}
                         (fn
                           ([_entry {start0 count0 _list0}] (&when (> start0 0))
                            {#cont {(dec start0) count0 []}})
                           ([entry {start0 count0 list0}] (&when (> count0 1))
                            {#cont {start0 (dec count0) [entry & list0]}})
                           ([entry {start0 count0 list0}]
                            {#halt {start0 count0 [entry & list0]}})))
                        (elem 1))]
     (lists.reverse list))))

(defn sort
  """Sorts the collection according to Kapok's term orderng.

  Uses the merge sort algorithm."""

  ([collection] (&when (list? collection))
   (lists.sort collection))

  ([collection]
   (sort collection (fn core <= 2))))

(defn sort
  """Sorts the collection by the given function.

  This function uses the merge sort algorithm. The given function
  must return `:false` if the first argument is less than right one."""

  ([collection fun] (&when (list? collection))
   (lists.sort fun collection))

  ([collection fun]
   (-> (reduce collection
               []
               (fn [x y]
                 (sort-reducer x y fun)))
       (sort-terminator fun))))

(defn sort-by [collection mapper &optional (sorter (fn core <= 2))]
  """Sorts the mapped results of the `collection` according to
  the `sorter` function.

  This function maps each element of the collection using the `mapper`
  function. The collection is then sorted by the mapped elements using
  the `sorter` function, which defaults to `(core.<= 2)`.

  `(sort-by 3)` differs from `(sort 2)` in that it only calculates the
  comparison value for each element in the collection once instead of
  once for each element in each comparison. If the same function is
  being called on both element, it's also more compact to use `(sort-by 3)`."""

  (-> collection
      (map (fn [x] {x (mapper x)}))
      (sort (fn [x y] (sorter (elem x 1) (elem y 1))))
      (map (fn [x] (elem x 0)))))

(defn split
  """Splits the sequential into two collections, leaving `count`
  elements in the first one. If `count` is a negative number,
  it starts counting from the back to the beginning of the collection.

  Be aware that a negative `count` implies the collcetion
  will be enumerated twice: once to calculate the posittion, and
  a second time to do the actual splitting."""

  ([collection count] (&when (&and (list? collection)
                                   (>= count 0)))
   (do-split collection count []))

  ([collection count] (&when (>= count 0))
   (let [{_ list1 list2} (reduce collection
                                 {count [] []}
                                 (fn [entry {counter acc1 acc2}]
                                   (if (> counter 0)
                                       {(dec counter) [entry & acc1] acc2}
                                     {counter acc1 [entry & acc2]})))]
     {(lists.reverse list1) (lists.reverse list2)}))

   ([collection count] (&when (< count 0))
    (do-split-reverse (reverse collection) (abs count) [])))

(defn split-while
  """Splits `collection` in two at the position of the element for which
  `fun` returns `false` for the first time."""

  ([collection fun] (&when (list? collection))
   (do-split-while collection fun []))

  ([collection fun]
   (let [{list1 list2} (reduce collection
                               {[] []}
                               (fn
                                 ([entry {acc1 []}]
                                  (if (fun entry)
                                      {[entry & acc1] []}
                                    {acc1 [entry]}))
                                 ([entry {acc1 acc2}]
                                  {acc1 [entry & acc2]})))]
     {(lists.reverse list1) (lists.reverse list2)})))

(defn take
  """Takes the first `count` items from the collection.

  `count` must be an integer. If a negative `count` is given, the last `count`
  values will be taken. For such, the collection is fully enumerated keeping up
  to `2 * count` elements in memery. Once the end of the collection is reached,
  the last `count` elements are returned."""
  ([_collection 0]
   [])

  ([[] _count]
   [])

  ([collection n] (&when (&and (list? collection)
                               (integer? n)
                               (> n 0)))
   (do-take collection n))

  ([collection n] (&when (&and (integer? n)
                               (> n 0)))
   (let [{_ {res _}} (sequential.reduce collection
                                        {:cont {[] n}}
                                        (fn [entry {list count}]
                                          (case count
                                            (0 {#halt {list count}})
                                            (1 {#halt {[entry & list] (dec count)}})
                                            (_ {#cont {[entry & list] (dec count)}}))))]
     (lists.reverse res)))

  ([collection n] (&when (&and (integer? n)
                               (< n 0)))
   (let [m (abs n)
         {_ buf1 buf2} (reduce collection
                               {0 [] []}
                               (fn [entry {c b1 b2}]
                                 (let [buf1 [entry & b1]
                                       count (inc c)]
                                   (if (== count m)
                                       {0 [] buf1}
                                     {count buf1 b2}))))]
     (do-take-last buf1 buf2 m [])))
  )

(defn take-every
  """Returns a collection of every `nth` item in the collection,
  starting with the first element.

  The second argument specifying every `nth` item must be
  a non-negative integer."""

  ([_collection 0]
   [])

  ([[] _nth]
   [])

  ([collection nth] (&when (&and (integer? nth)
                                 (> nth 0)))
   (let [{res _} (reduce collection
                         {[] #first}
                         (reducers.take-every nth))]
     (lists.reverse res))))

(defn take-while
  """Takes the items from the beginning of `collection` while
  `fun` returns a truthy value."""

  ([collection fun] (&when (list? collection))
   (do-take-while collection fun))

  ([collection fun]
   (let [{_ res} (sequential.reduce collection
                                    {#cont []}
                                    (fn [entry acc]
                                      (if (fun entry)
                                          {#cont [entry & acc]}
                                        {#halt acc})))]
     (lists.reverse res))))

(defn to-list
  """Converts `collection` to a list."""

  ([collection] (&when (list? collection))
   collection)

  ([collection]
   (lists.reverse (reverse collection))))

(defn uniq [collection]
  """Traverse the collection, removing all duplicated elements."""

  (uniq-by collection (fn [x] x)))

(defn uniq-by
  """Traverse the collection, removing all duplicated elements."""

  ([collection fun] (&when (list? collection))
   (do-uniq collection
            ;; TODO revise to add hash set
            %{}
            fun))

  ([collection fun]
   (let [{list _} (reduce collection
                          ;; TODO revise to add hash set
                          {[] %{}}
                          (reducers.uniq fun))]
     (lists.reverse list))))

(defn usort
  """Sorts the collection, eliminating duplicate elements (one element is kept
  from each group of duplicates)."""

  ([collection] (&when (list? collection))
   (lists.sort collection))

  ([collection]
   (-> collection
       sort
       dedup)))

(defn usort-by [collection fun]
  """Sorts the collection, eliminating duplicate elements (one element is kept
  from each group of duplicates).

  The function `fun` maps every element to a term which is used to
  sort and dedup by."""

  (-> collection
      (sort-by fun)
      (dedup-by fun)))

(defn unzip [collection]
  """Opposite of `(seq.zip 2)`; takes a list of two-element tuples and returns
  a tuple with two lists, each of which is formed by the first and second element
  of each tuple, respectively.

  This function fails unless `collection` is or can be converted into a list of
  tuples with *exactly* two elements in each tuple."""

  (let [{list3 list4} (reduce collection
                              {[] []}
                              (fn [{el1 el2} {list1 list2}]
                                {[el1 & list1] [el2 & list2]}))]
    {(lists.reverse list3) (lists.reverse list4)}))

(defn zip
  """Zips corresponding elements from two collections into one list
  of tuples.

  The zipping finishes as soon as any sequential completes."""

  ([collection1 collection2] (&when (&and (list? collection1)
                                          (list? collection2)))
   (do-zip collection1 collection2))

  ([_collection1 _collection2]
   ;; TODO add impl
   (throw "unimplemented")))

(defn with-index [collection]
  """Returns the collection with each element wrapped in a tuple
  alongside its index."""

  (-> (map-reduce collection
                  0
                  (fn [x acc]
                    {{x acc} (inc acc)}))
      (elem 0))
  )


;; Helpers

(defn- traverse-and-count [collection count] (&when (list? collection))
  {collection (- (length collection) (abs count))})

(defn- traverse-and-count [collection count]
  (map-reduce collection
              (- (abs count))
              (fn [x acc]
                {x (inc acc)})))

(defn- seq-to-string
  ([entry] (&when (binary? entry))
   entry)
  ([entry]
   (chars.to-string entry)))

(defn- random-index [n]
  (dec (rand.uniform (inc n))))

;; Implementations

;; all?

(defn- do-all? [[h & t] fun]
  (if (fun h)
      (do-all? t fun)
    :false))

(defn- do-all? [[] _]
  :true)

;; any?

(defn- do-any? [[h & t] fun]
  (if (fun h)
      :true
    (do-any? t fun)))

(defn- do-any? [[] _]
  :false)

;; concat

(defn- do-concat [sequential]
  (let [fun (fn [x l]
              [x & l])]
    (lists.reverse (reduce sequential
                           []
                           (fn [x acc]
                             (reduce x acc fun)))))
  )

;; drop

(defn- do-drop [[] _]
  [])

(defn- do-drop [list 0]
  list)

(defn- do-drop [[_ & t] counter] (&when (> counter 0))
  (do-drop t (dec counter)))

;; drop-while

(defn- do-drop-while [[] _]
  [])

(defn- do-drop-while [[h & t] fun]
  (if (fun h)
      (do-drop-while t fun)
    [h & t]))

;; fetch

(defn- do-fetch [[] _]
  #error)

(defn- do-fetch [[h & _] 0]
  {#ok h})

(defn- do-fetch [[_ & t] n]
  (do-fetch t (dec n)))

;; find

(defn- do-find [[] ifnone _]
  ifnone)

(defn- do-find [[h & t] ifnone fun]
  (if (fun h)
      h
    (do-find t ifnone fun)))

;; find-value

(defn- do-find-value [[] ifnone _]
  ifnone)

(defn- do-find-value [[h & t] ifnone fun]
  (let [value (fun h)]
    (or value (do-find-value t ifnone fun))))

;; find-index

(defn- do-find-index [[] _ _]
  :nil)

(defn- do-find-index [[h & t] counter fun]
  (if (fun h)
      counter
    (do-find-index t (inc counter) fun)))

;; into

(defn- do-into [collection collectable]
  (let [{initial fun} (clt.into collectable)]
    (into collection
          initial
          fun
          (fn [x acc]
            (fun acc {#cont x})))))

(defn- into [collection initial fun callback]
  (case
      (try (reduce collection initial callback)
        (catch
          ((kind reason)
           (let [stacktrace (erlang.get_stacktrace)]
             (fun initial #halt)
             (erlang.raise kind reason stacktrace)))))
    (acc (fun acc #done))))

;; reverse-slice

(defn- reverse-slice [rest index index count acc]
  (let [{slice rest1} (head-slice rest count [])]
    (lists.reverse rest1 (lists.reverse slice acc))))

(defn- reverse-slice [[elem & rest] index start count acc]
  (reverse-slice rest (dec index) start count [elem & acc]))

(defn- head-slice [rest 0 acc]
  {acc rest})

(defn- head-slice [[elem & rest] count acc]
  (head-slice rest (dec count) [elem & acc]))

;; shuffle

(defn- unwrap [[{_ h} & t] acc]
  (unwrap t [h & acc]))

(defn- unwrap [[] acc]
  acc)

;; slice

(defn- do-slice [list start count]
  (do-slice list start count []))

(defn- do-slice [[] _start _count acc]
  (lists.reverse acc))

(defn- do-slice [_list _start 0 acc]
  (lists.reverse acc))

(defn- do-slice [[h & t] 0 count acc]
  (do-slice t 0 (dec count) [h & acc]))

(defn- do-slice [[_ & t] start count acc]
  (do-slice t (dec start) count acc))

;; sort

(defn- sort-reducer [entry {#split y x r rs bool} fun]
  (cond
    (== (fun y entry) bool) {#split entry y [x & r] rs bool}
    (== (fun x entry) bool) {#split y entry [x & r] rs bool}
    (== r []) {#split y x [entry] rs bool}
    :true {#pivot y x r rs entry bool}))

(defn- sort-reducer [entry {#pivot y x r rs s bool} fun]
  (cond
    (== (fun y entry) bool) {#pivot entry y [x & r] rs s bool}
    (== (fun x entry) bool) {#pivot y entry [x & r] rs s bool}
    (== (fun s entry) bool) {#split entry s [] [[y x & r] & rs] bool}
    :true {#split s entry [] [[y x & r] & rs] bool}))

(defn- sort-reducer [entry [x] fun]
  {#split entry x [] [] (fun x entry)})

(defn- sort-reducer [entry acc _fun]
  [entry & acc])

(defn- sort-terminator [{#split y x r rs bool} fun]
  (sort-merge [[y x & r] & rs] fun bool))

(defn- sort-terminator [{#pivot y x r rs s bool} fun]
  (sort-merge [[s] [y x & r] & rs] fun bool))

(defn- sort-terminator [acc _fun]
  acc)

(defn- sort-merge [list fun :true]
  (reverse-sort-merge list [] fun :true))

(defn- sort-merge [list fun :false]
  (sort-merge list [] fun :false))

(defn- sort-merge [[t1 [h2 & t2] & l] acc fun :true]
  (sort-merge l [(sort-merge-1 t1 h2 t2 [] fun :false) & acc] fun :true))

(defn- sort-merge [[[h2 & t2] t1 & l] acc fun :false]
  (sort-merge l [(sort-merge-1 t1 h2 t2 [] fun :false) & acc] fun :false))

(defn- sort-merge [[l] [] _fun _bool]
  l)

(defn- sort-merge [[l] acc fun bool]
  (reverse-sort-merge [(lists.reverse l []) & acc] [] fun bool))

(defn- sort-merge [[] acc fun bool]
  (reverse-sort-merge acc [] fun bool))

(defn- reverse-sort-merge [[[h2 & t2] t1 & l] acc fun :true]
  (reverse-sort-merge l
                      [(sort-merge-1 t1 h2 t2 [] fun :true) & acc]
                      fun
                      :true))

(defn- reverse-sort-merge [[t1 [h2 & t2] & l] acc fun :false]
  (reverse-sort-merge l
                      [(sort-merge-1 t1 h2 t2 [] fun :false) & acc]
                      fun
                      :false))

(defn- reverse-sort-merge [[l] acc fun bool]
  (sort-merge [(lists.reverse l []) & acc] [] fun bool))

(defn- reverse-sort-merge [[] acc fun bool]
  (sort-merge acc [] fun bool))


(defn- sort-merge-1 [[h1 & t1] h2 t2 m fun bool]
  (if (== (fun h1 h2) bool)
      (sort-merge-2 h1 t1 t2 [h2 & m] fun bool)
    (sort-merge-1 t1 h2 t2 [h1 & m] fun bool)))

(defn- sort-merge-1 [[] h2 t2 m _fun _bool]
  (lists.reverse t2 [h2 & m]))

(defn- sort-merge-2 [h1 t1 [h2 & t2] m fun bool]
  (if (== (fun h1 h2) bool)
      (sort-merge-2 h1 t1 t2 [h2 & m] fun bool)
    (sort-merge-1 t1 h2 t2 [h1 & m] fun bool)))

(defn- sort-merge-2 [h1 t1 [] m _fun _bool]
  (lists.reverse t1 [h1 & m]))

;; split

(defn- do-split [[h & t] counter acc] (&when (> counter 0))
  (do-split t (dec counter) [h & acc]))

(defn- do-split [list 0 acc]
  {(lists.reverse acc) list})

(defn- do-split [[] _ acc]
  {(lists.reverse acc) []})

(defn- do-split-reverse [[h & t] counter acc] (&when (> counter 0))
  (do-split-reverse t (dec counter) [h & acc]))

(defn- do-split-reverse [list 0 acc]
  {(lists.reverse list) acc})

(defn- do-split-reverse [[] _ acc]
  {[] acc})

;; split-while

(defn- do-split-while [[h & t] fun acc]
  (if (fun h)
      (do-split-while t fun [h & acc])
    {(lists.reverse acc) [h & t]}))

(defn- do-split-while [[] _ acc]
  {(lists.reverse acc) []})

;; take

(defn- do-take [list counter]
  (do-take list counter []))

(defn- do-take [[] _counter acc]
  (lists.reverse acc))

(defn- do-take [_list 0 acc]
  (lists.reverse acc))

(defn- do-take [[h & t] counter acc] (&when (> counter 0))
  (do-take t (dec counter) [h & acc]))

(defn- do-take-last [_buf1 _buf2 0 acc]
  acc)

(defn- do-take-last [[] [] _ acc]
  acc)

(defn- do-take-last [[] [h & t] n acc]
  (do-take-last [] t (dec n) [h & acc]))

(defn- do-take-last [[h & t] buf2 n acc]
  (do-take-last t buf2 (dec n) [h & acc]))

;; take-while

(defn- do-take-while [list fun]
  (do-take-while list fun []))

(defn- do-take-while [[h & t] fun acc]
  (if (fun h)
      (do-take-while t fun [h & acc])
    (lists.reverse acc)))

(defn- do-take-while [[] _ acc]
  (lists.reverse acc))

;; uniq-by

(defn- do-uniq [list value-set fun]
  (lists.reverse (do-uniq list [] value-set fun)))

(defn- do-uniq [[h & t] elem-list value-set fun]
  (let [value (fun h)]
    ;; TODO revise to add hash set
    (if (gb_sets.is_member value value-set)
        (do-uniq t elem-list value-set fun)
      (do-uniq t [h & elem-list] (gb_sets.add value value-set) fun))))

(defn- do-uniq [[] elem-list _value-set _fun]
  elem-list)

;; zip

(defn- do-zip [list1 list2]
  (lists.reverse (do-zip list1 list2 [])))

(defn- do-zip [[h1 & next1] [h2 & next2] acc]
  (do-zip next1 next2 [{h1 h2} & acc]))

(defn- do-zip [_ [] acc]
  acc)

(defn- do-zip [[] _ acc]
  acc)

;; Implementations of sequential for built-in collections.

(defimpl sequential list

  (defn reduce [_ {#halt acc} _fun]
    {#halted acc})
  (defn reduce [list {#suspend acc} fun]
    {#suspended acc (fn [acc1] (reduce list acc1 fun))})
  (defn reduce [[] {#cont acc} _fun]
    {#done acc})
  (defn reduce [[h & t] {#cont acc} fun]
    (reduce t (fun h acc) fun))

  (defn member? [_list _value]
    ;; TODO add macro `__MODULE__`
    {#error #'sequential.list'})
  (defn count [_list]
    ;; TODO add macro `__MODULE__`
    {#error #'sequential.list'})
  )

(defimpl sequential map
  (require maps)

  (defn reduce [map acc fun]
    (sequential.reduce (maps.to_list map)
                       acc
                       fun))

  (defn member? [map {key value}]
    {#ok (match? {#ok value}
                 (maps.find key map))})

  (defn member? [_map _other]
    {#ok :false})

  (defn count [map]
    {#ok (map-size map)}))

;; TODO

;; (defprotocol seq
;;   "A protocol for sequence."

;;   ;; clojure seq protocol

;;   (defn first [self]
;;     "Returns the first item in the collection.")

;;   (defn rest [self]
;;     "Returns a possibly empty seq of the items after the first.")

;;   (defn next [self]
;;     """Returns a seq of the items after the first.
;;     If there are no more items, returns nil.""")

;;   ;; elixir enum protocol

;;   )
