(defns kapok.stream
  """Module for creating and composing streams.

  Streams are composable, lazy sequentials. Any sequential that generates
  items one by one during traversal is called a stream. For example,
  Kapok's range is a stream:

      kapok> (let [r (range.new 1 5)]
               (seq.map r (fn [x] (* x 2))))
      [2 4 6 8 10]

  In the example above, as we mapped over the range, the elements being
  traversed were created one by one, during traversal. The `stream`
  module allows up to map the range, without triggering its traversal:

      kapok> (let [r (range.new 1 3)
                   str (stream.map r (fn [x] (* x 2)))]
               (seq.map str (fn [x] (inc x))))
      [3 5 7]

  Notice we started with a range and then we created a stream that is
  meant to multiply each item in the range by 2. At this point, no
  computation was done yet. Just when `(seq.map 2)` is called we
  traverse each item in the range, multiplying it by 2 and adding 1.
  We say the functions in `stream` are *lazy* and the functions in `seq`
  are *eager*.

  Due to their laziness, streams are useful when working with large
  (or even infinite) collections. When chaining many operations with `seq`,
  intermediate lists are created, while `stream` creates a recipe of
  computations that are executed at a later moment. Let's see another
  example:

      (-> (range.new 1 3)
          (seq.map (fn [x] (io.inspect x)))
          (seq.map (fn [x] (* x 2)))
          (seq.map (fn [x] (io.inspect x))))
      1
      2
      3
      2
      4
      6
      ;=> [2 4 6]

  Notice that we first printed each item in the liist, then multiplied each
  element by 2 and finally printed each new value. In this example, the list
  was enumerated three times. Let's see an example with streams:

      (let [stream (-> (range.new 1 3)
                       (stream.map (fn [x] (io.inspect x)))
                       (stream.map (fn [x] (* x 2)))
                       (stream.map (fn [x] (io.inspect x))))]
        (seq.to-list stream))
      1
      2
      2
      4
      3
      6
      ;;=> [2 4 6]

  Although the end result is the same, the order in which the items were
  printed changed! With streams, we print the first item and then print
  its double. In this example, the list was traversed just once!

  That's what we meant when we first said the streams are composable,
  lazy sequentials. Notice we could call `(stream.map 2)` multiple times,
  effectively composing the streams and they are lazy. The computations
  are performed only when you call a function from the `seq` module.

  ## Creating streams

  There are many functions in Kapok's stanard library that return
  streams, some example is:

      * `(io.stream 2)`       - streams input lines, one by one

  This module also provides many convenience functions for creating streams.
  like `(stream.cycle 1)`, `(stream.unfold 2)`, `(stream.resource 3)` and more.

  Note the functions in this module are guaranteed to return sequentials.
  Since sequentials can have different shapes (structs, anonymous functions,
  and so on), the functions in this module may return any of those shapes
  and that it may change at any time. For example, a function that today
  returns an anonymous function may return a struct in future releases.
  """
  ((require erlang
            lists
            maps
            (kapok (seq
                    sequential
                    sequential.list
                    (stream.reducers :as reducers)
                    system))))

  (defstruct
    (:seq :nil)
    (:funs [])
    (:accs [])
    (:done :nil))

  (defmacro- skip [acc]
    `{#cont ~acc})

  (defmacro- next [f entry acc]
    `(~f ~entry ~acc))

  (defmacro- acc [h n t]
    `[~h ~n & ~t])

  (defmacro- next-with-acc [f entry h n t]
    `(let [{reason [h & t]} (~f ~entry [~h & ~t])]
       {reason [h ~n & t]}))

  ;; Transformers

  (defn chunk [seq n]
    "Shortcut to `(chunk seq n n)`."
    (chunk seq n n :nil))

  (defn chunk [seq n step &optional pad] (&when (&and (> n 0)
                                                             (> step 0)))
    """Streams the sequential in chunks, containing `n` items each, where
    each new chunk starts `step` elements into the sequential.

    `step` is optional and, if not passed, defaults to `n`, i.e.
    chunks do not overlop. If the final chunk does not have `n`
    elements to fill the chunk, elements are taken as necessary
    from `pad` if it was passed. If `pad` is passed and does not
    have enough elements to fill the chunk, then the chunk is
    returned anyway with less than `n` elements. If `pad` is not
    passed at all or is `nil`, then the partial chunk is discarded
    from the result.

    ## Examples

        kapok> (-> (stream.chunk [1 2 3 4 5 6] 2) seq.to-list)
        [[1 2] [3 4] [5 6]]

        kapok> (-> (stream.chunk [1 2 3 4 5 6] 3 2) seq.to-list)
        [[1 2 3] [3 4 5]]

        kapok> (-> (stream.chunk [1 2 3 4 5 6] 3 2 [7]) seq.to-list)
        [[1 2 3] [3 4 5] [5 6 7]]

        kapok> (-> (stream.chunk [1 2 3 4 5 6] 3 3 []) seq.to-list)
        [[1 2 3] [4 5 6]]

    """
    (let [limit (erlang.max n step)]
      (if (nil? pad)
          (lazy seq {[] 0} (fn [f1] (reducers.chunk n step limit f1)))
        (lazy seq
              {[] 0}
              (fn [f1] (reducers.chunk n step limit f1))
              (fn [x y] (do-chunk x n pad y))))))

  (defn- do-chunk [(acc _ {_ 0} _) &as acc1 _ _ _]
    {#cont acc1})

  (defn- do-chunk [(acc h {buffer count} &as old t) n pad f1]
    (let [buffer1 (lists.reverse buffer (seq.take pad (- n count)))]
      (next-with-acc f1 buffer1 h old t)))

  (defn chunk-by [seq fun]
    """Chunks the `seq` by buffering elements for which `fun` returns
    the same value and only emit them when `fun` returns a new value
    or the `seq` finishes.

    ## Examples

        kapok> (let [s (stream.chunk-by [1 2 2 3 4 4 6 7 7]
                                        (fn [x] (== (rem x 2) 1)))]
                 (seq.to-list stream))
        [[1] [2 2] [3] [4 4 6] [7 7]]

    """
    (lazy seq
          :nil
          (fn [f1] (reducers.chunk-by fun f1))
          (fn [x y] (do-chunk-by x y))))

  (defn- do-chunk-by [(acc _ :nil _) &as acc1 _f1]
    {#cont acc1})

  (defn- do-chunk-by [(acc h {buffer _} t) f1]
    (next-with-acc f1 (lists.reverse buffer) h :nil t))

  (defn dedup [seq]
    """Creates a stream that only emits elements if they are differen from the last emitted element.

    This function only ever needs to store the last emitted element.

    ## Examples

        kapok> (-> (stream.dedup [1 2 3 3 2 1]) seq.to-list)
        [1 2 3 2 1]

    """
    (dedup-by seq (fn [x] x)))

  (defn dedup-by [seq fun] (&when (function? fun 1))
    (lazy seq :nil (fn [f1] (reducers.dedup fun f1))))

  (defn drop [seq n] (&when (>= n 0))
    (lazy seq n (fn [f1] (reducers.drop f1))))

  (defn drop [seq n] (&when (< n 0))
    (let [n1 (abs n)]
      (lazy seq
            {0 [] []}
            (fn [f1]
              (fn
                ([entry [h {count buf1 []} & t]]
                   (do-drop #cont n1 entry h count buf1 [] t))
                ([entry [h {count buf1 [next & buf2]} & t]]
                 (let [{reason [h1 & t1]} (f1 next [h & t])]
                   (do-drop reason n1 entry h1 count buf1 buf2 t1))))))))

  (defn- do-drop [reason n entry h count buf1 buf2 t]
    (let [new-buf1 [entry & buf1]
          new-count (inc count)]
      (if (== new-count n)
          {reason [h {0 [] (lists.reverse new-buf1)} & t]}
        {reason [h {count new-buf1 buf2} & t]})))

  (defn drop-while [seq fun]
    """Lazily drops elements of the enumerable while  the given
    function returns `:true`.

    ## Examples

        kapok> (let [s (stream.drop-while (range.new 1 10) (fn [x] (<= x 5)))]
                 (seq.to-list s))
        [6, 7, 8, 9, 10]

    """
    (lazy seq :true (fn [f1] (reducers.drop-while fun f1))))

  (defn each [seq fun]
    """Executes the given function for each item.

    Useful for adding side effects (like printing) to a stream.

    ## Examples

        kapok> (let [s (stream.each [1 2 3] (fn [x] (send (self) x)))]
                 (seq.to-list s))
        kapok> (receive
                 (x (&when (integer? x) x)))
        1
        kapok> (receive
                 (x (&when (integer? x) x)))
        2
        kapok> (receive
                 (x (&when (integer? x) x)))
        3

    """
    (lazy seq (fn [f1]
                (fn [x acc]
                  (fun x)
                  (f1 x acc)))))

  (defn flat-map [seq mapper]
    """Creates a stream that will apply the given function on enumeration and
    flatten the result.

    ## Examples

        kapok> (let [s (stream.flat-map [1 2 3] (fn [x] [x (* x 2)]))]
                 (seq.to-list s))
        [1 2 2 4 3 6]

    """
    (transform seq :nil (fn [val :nil] {(mapper val) :nil})))

  (defn filter [seq fun]
    """Creates a stream that filters elements according to the given function on traversal.

    ## Examples

        kapok> (let [s (stream.filter [1 2 3] (fn [x] (== (rem x 2) 0)))]
                 (seq.to-list stream))
        [2]

    """
    (lazy seq (fn [f1] (reducers.filter fun f1))))

  (defn transform [seq acc reducer]
    """Transform an existing stream.

    It expects an accumulator and a function that receive each stream item
    and an accumulator, and must return a tuple containing a new stream
    (often a list) with the new accumulator or a tuple with `#halt` as first
    element and the accumulator as second.

    Note: this function is similar to `(seq.flat-map-reduce 3)` except the
    latter returns both the flat list and accumulator, while this one returns
    only the stream.

    ## Examples

    `(stream.transform 3)` is useful as it can be used as the basis to implement
    many of the functions defined in this module. For example, we can implement
    `(stream.take seq n)` as follows:

        kapok> (let [seq (range.new 1 100)
                     n 3
                     s (stream.transform seq 0 (fn [i acc]
                                                 (if (< acc n)
                                                     {[i] (inc acc)}
                                                   {#halt acc})))]
                 (seq.to-list stream))
        [1 2 3]

    """
    (fn [x y]
      (do-transform seq acc reducer x y)))

  (defn- do-transform [sequentials user-acc user inner-acc fun]
    (let [inner (fn [x y] (do-transform-each x y fun))
          step (fn [x y] (do-transform-step x y))
          next (fn [x] (sequential.reduce sequentials x step))]
      (do-transform user-acc user fun [] next inner-acc inner)))

  (defn-
      #{:check_remote_call :false}
      do-transform [user-acc user fun next-acc next inner-acc inner]
    (case (next {#cont next-acc})
      ({#suspended [val & next-acc1] next}
       (try (user val user-acc)
           (({[] user-acc1}
             (do-transform user-acc1 user fun next-acc1 next inner-acc inner))
            ({list user-acc1} (&when (list? list))
             (do-list-transform user-acc1 user fun next-acc1 next inner-acc inner,
                                (fn [x] (sequential.list.reduce list x fun))))
            ({#halt _user_acc1}
             (next {#halt next-acc1})
             {#halted (elem inner-acc 1)})
            ({other user-acc1}
             (do-seq-transform user-acc1 user fun next-acc1 next inner-acc inner
                               (fn [x] (sequential.reduce other x inner)))))
         (catch
           ((kind reason) (let [stacktrace (system.stacktrace)]
                            (next {#halt next-acc})
                            (erlang.raise kind reason stacktrace))))))
      ({reason _}
       {reason (elem inner-acc 1)})))

  (defn-
      #{:check_remote_call :false}
      do-list-transform [user-acc user fun next-acc next inner-acc inner reduce]
    (try (reduce inner-acc)
        (({#done, acc}
          (do-transform user-acc user fun next-acc next {#cont acc} inner))
         ({#halted acc}
          (next {#halt next-acc})
          {#halted acc})
         ({#suspended acc c}
          {#suspended acc (fn [x] (do-list-transform user-acc user fun next-acc next x inner c))}))
      (catch
        ((kind reason) (let [stacktrace (system.stacktrace)]
                         (next {#halt next-acc})
                         (erlang.raise kind reason stacktrace))))))

  (defn-
      #{:check_remote_call :false}
      do-seq-transform [user-acc user fun next-acc next {op inner-acc} inner reduce]
    (try (reduce {op [#outer & inner-acc]})
        (({#halted [#outer & acc1]}
          (do-transform user-acc user fun next-acc next {#cont acc1} inner))
         ({#halted [#inner & acc1]}
          (next {#halt next-acc})
          {#halted acc1})
         ({#done [_ & acc1]}
          (do-transform user-acc user fun next-acc next {#cont acc1} inner))
         ({#suspended [_ & acc1] c}
          {#suspended acc1 (fn [x] (do-seq-transform user-acc user fun next-acc next x inner c))}))
      (catch
        ((kind reason) (let [stacktrace (system.stacktrace)]
                         (next {#halt next-acc})
                         (erlang.raise kind reason stacktrace))))))

  (defn- do-transform-each [x [#outer & acc] f]
    (case (f x acc)
      ({#halt res} {#halt [#inner & res]})
      ({op res}    {op [#outer & res]})))

  (defn- do-transform-step [x acc]
    {#suspend [x & acc]})

  ;; Helpers

  (defn- lazy [#{:__struct__ #'kapok.stream'
                 :done :nil
                 :funs funs} &as lazy
               fun]
    (maps.put #funs [fun & funs] lazy))

  (defn- lazy [seq fun]
    (new :seq seq :funs [fun]))

  (defn- lazy [#{:__struct__ #'kapok.stream'
                 :done :nil
                 :funs funs
                 :accs accs} &as lazy
               acc
               fun]
    (->> lazy
         (maps.put #funs [fun & funs])
         (maps.put #acc [acc & accs])))

  (defn- lazy [seq acc fun]
    (new :seq seq :funs [fun] :accs [acc]))

  (defn- lazy [#{:__struct__ #'kapok.stream'
                 :funs funs
                 :accs accs} &as lazy
               acc
               fun
               done]
    (->> lazy
         (maps.put #funs [fun & funs])
         (maps.put #acc [acc & accs])
         (maps.put #done done)))

  (defn- lazy [seq acc fun done]
    (new :seq seq :funs [fun] :accs [acc] :done done))
  )
