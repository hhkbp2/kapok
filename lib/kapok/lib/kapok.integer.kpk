(ns kapok.integer
  """Functions for working with integers."""
  (require erlang
           io_lib))

(defmacro odd? [n]
  """Determines if an integer is odd.

  Returns `:true` if `n` is an odd number, otherwise `:false`.

  Allowed in guard clauses."""

  `(== (bit-and ~n 1) 1))

(defmacro even? [n]
  """Determines if an integer is even.

  Returns `:true` if `n` is an even number, otherwise `:false`.

  Allowed in guard clauses."""

  `(== (bit-and ~n 1) 0))

(defn in-range [i first last]
  (and (>= i first)
       (<= i last)))

(defn digits [n &optional (base 10)] (&when (&and (integer? n)
                                                  (>= n 0)
                                                  (integer? base)
                                                  (>= base 2)))
  """Returns the ordered digits for the given non-negative integer.

  An optional base value may be provided representing the radix for
  the returned digits.

  ## Examples

      kapok> (integer.digits 101)
      [1 0 1]

      kapok> (integer.digits 58127 2)
      [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]

  """

  (do-digits n base []))

(defn undigits [digits &optional (base 10)] (&when (integer? base))
  """Returns the integer represented by the ordered digits.

  An optional base value may be provided representing the radix for the digits.

  ## Examples

      kapok> (integer.undigits [1 0 1])
      101

      kapok> (integer.undigits [1 4] 16)
      20

  """

  (do-undigits digits base 0))

(defn parse
  """Converts a binary from a text representation of an integer
  in an optional base `base` to the corresponding integer.

  If the base `base` is not given, base 10 will be used.

  If successful, returns a tuple of the form `{integer, remainder-of-binary}`.
  Otherwise `#error`.

  Raises an error if `base` is less than 2 or more than 36.

  ## Examples

      kapok> (integer.parse "34")
      {34, ""}

      kapok> (integer.parse "34.5")
      {34, ".5"}

      kapok> (integer.parse "three")
      :error

      kapok> (integer.parse "34", 10)
      {34, ""}

      kapok> (integer.parse "f4", 16)
      {244, ""}

      kapok> (integer.parse "Awww++", 36)
      {509216, "++"}

      kapok> (integer.parse "fab", 10)
      :error

      kapok> (integer.parse "a2", 38)
      ** (ArgumentError) invalid base 38

  """
  ([binary &optional (base 10)] (&when (&and (integer? base)
                                             (>= base 2)
                                             (<= base 36)))
   (parse-in-base binary base))
  ([_ base]
   ;; TODO revise to use exception
   (throw (io_lib.format "invalid base ~p" [base]))))

(defn to-string [some-integer]
  """Returns a binary which corresponding to the text representation
  of `some-integer`.

  Inlined by the compiler.

  ## Examples

      kapok> (integer.to-string 123)
      "123"

  """
  (erlang.integer_to_binary some-integer))

(defn to-string [some-integer base]
  """Returns a binary which corresponding to the text representation
  of `some-integer` in base `base`.

  Inlined by the complier.

  ## Examples

      kapok> (integer.to-string 100 16)
      "64"

  """
  (erlang.integer_to_binary some-integer base))

(defn to-char-list [number]
  """Returns a char list which corresponding to the text representation
  of the given integer.

  Inlined by the compiler.

  ## Examples

      kapok> (integer.to-char-list 7)
      #"7"

  """
  (erlang.integer_to_list number))

(defn to-char-list [number base]
  """Returns a char list which corresponding to the text representation
  of the given integer in the given base.

  Inlined by the compiler.

  ## Examples

      kapok> (integer.to-char-list 1023 16)
      #"3FF"

  """
  (erlang.integer_to_list number base))

;; Implementation

;; digits

(defn- do-digits
  ([0 _base []]
   [0])
  ([0 _base acc]
   acc)
  ([n base acc]
   (do-digits (div n base) base [(rem n base) & acc])))

;; undigits

(defn- do-undigits
  ([[] _base acc]
   acc)
  ([[digit & tail] base acc]
   (do-undigits tail base (+ (* acc base) digit))))

;; parse

(defn- parse-in-base

  ([<< ($-) (bin) >> base] (&when (binary? bin))
   (case (do-parse bin base)
     (#error
      #error)
     ({number remainder}
      {(- number) remainder})))

  ([<< ($+) (bin) >> base] (&when (binary? bin))
   (do-parse bin base))

  ([bin base] (&when (binary? bin))
   (do-parse bin base))
  )


(defn- do-parse

  ([<< (char) (bin) >> base] (&when (binary? bin))
   (if (valid-digit-in-base? char base)
       (do-parse bin base (parse-digit char base))
     #error))

  ([_ _]
   #error)

  ([<< (char) (rest) >> base acc] (&when (binary? rest))
   (if (valid-digit-in-base? char base)
       (do-parse rest base (+ (* base acc) (parse-digit char base)))
     {acc << (char) (rest) >>}))

  ([bitstring _ acc]
   {acc bitstring})
  )

(defn- parse-digit [char _]
  (case char
    (c (&when (&and (>= c $0) (<= c $9)))
     (- char $0))
    (c (&when (&and (>= c $A) (<= c $Z)))
     (+ (- char $A) 10))
    (_
     (+ (- char $a) 10))))

(defn- valid-digit-in-base? [char base]
  (if (<= base 10)
      (in-range char $0 (dec (+ $0 base)))
    (or (in-range char $0 $9)
        (in-range char $A (- (+ $A base) 11))
        (in-range char $a (- (+ $a base ) 11)))))
