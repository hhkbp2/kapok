;; Collection of reducers shared by seq and stream.
(ns stream.reducers
  (use core))

(defmacro chunk [n step limit &optional f]
  `(fn [entry (acc h {b c} t)]
     (let [buffer [entry & b]
           count (inc c)
           new (if (>= count ~limit)
                   (do
                    (let [left (- count ~step)]
                      {(seq.take buffer left) left}))
                 {buffer count})]
       (if (=== count ~n)
           (next-with-acc ~f (lists.reverse buffer) h new t)
           (skip (acc h new t))))))

(defmacro chunk-by [callback &optional f]
  `(fn
     ([entry (acc h {buffer value} t)]
      (let [new-value (~callback entry)]
        (if (== new-value value)
            (skip (acc h {[entry & buffer] value} t))
          (next-with-acc ~f (lists.reverse buffer) h {[entry] new-value} t))))
     ([entry (acc h :nil t)]
      (skip (acc h {[entry] (~callback entry)} t))))
  )

(defmacro dedup [callback &optional f]
  `(fn [entry (acc h prev t) &as acc]
     (let [value (~callback entry)]
       (case prev
         ({^value value} (skip acc))
         (_ (next-with-acc ~f entry h {^value value} t))))))


(defmacro drop-while [callback &optional f]
  `(fn [entry (acc h bool t) &as orig]
     (if (and bool
              (~callback entry))
         (skip orig)
         (next-with-acc ~f entry h :false t))))

(defmacro filter [callback &optional f]
  `(fn [entry acc]
     (if (~callback entry)
         (next ~f entry acc)
       (skip acc))))
