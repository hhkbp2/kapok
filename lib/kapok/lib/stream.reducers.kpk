;; Collection of reducers shared by seq and stream.
(ns stream.reducers
  (require gb_sets)
  (use core))

(defmacro chunk [n step limit &optional f]
  `(fn [entry (acc h {b c} t)]
     (let [buffer [entry & b]
           count (inc c)
           new (if (>= count ~limit)
                   (do
                    (let [left (- count ~step)]
                      {(seq.take buffer left) left}))
                 {buffer count})]
       (if (=== count ~n)
           (next-with-acc ~f (lists.reverse buffer) h new t)
           (skip (acc h new t))))))

(defmacro chunk-by [callback &optional f]
  `(fn
     ([entry (acc h {buffer value} t)]
      (let [new-value (~callback entry)]
        (if (== new-value value)
            (skip (acc h {[entry & buffer] value} t))
          (next-with-acc ~f (lists.reverse buffer) h {[entry] new-value} t))))
     ([entry (acc h :nil t)]
      (skip (acc h {[entry] (~callback entry)} t))))
  )

(defmacro dedup [callback &optional f]
  `(fn [entry (acc h prev t) &as acc]
     (let [value (~callback entry)]
       (case prev
         ({^value value} (skip acc))
         (_ (next-with-acc ~f entry h {^value value} t))))))


(defmacro drop-while [callback &optional f]
  `(fn [entry (acc h bool t) &as orig]
     (if (and bool
              (~callback entry))
         (skip orig)
         (next-with-acc ~f entry h :false t))))

(defmacro filter [callback &optional f]
  `(fn [entry acc]
     (if (~callback entry)
         (next ~f entry acc)
       (skip acc))))

(defmacro filter-map [filter mapper &optional f]
  `(fn [entry acc]
     (if (~filter entry)
         (next ~f (~mapper entry) acc)
       (skip acc))))

(defmacro map [callback &optional f]
  `(fn [entry acc]
     (next ~f (~callback entry) acc)))

(defmacro reject [callback &optional f]
  `(fn [entry acc]
     (if-not (~callback entry)
             (next ~f entry acc)
       (skip acc))))

(defmacro scan-2 [callback &optional f]
  `(fn
     ([entry (acc h ^first t)]
      (next-with-acc ~f entry h {^ok entry} t))
     ([entry (acc h {^ok acc} t)]
      (let [value (~callback entry acc)]
        (next-with-acc ~f value h {^ok value} t)))))

(defmacro scan-3 [callback &optional f]
  `(fn [entry (acc h acc0 t)]
     (let [value (~callback entry acc0)]
       (next-with-acc ~f value h value t))))

(defmacro take-every [nth &optional f]
  `(fn
     ([entry (acc h n t)] (&when (&or (=== n ^first)
                                      (=== n ~nth)))
      (next-with-acc ~f entry h 1 t))
     ([_entry (acc h n t)]
      (skip (acc h (inc n) t)))))

(defmacro uniq [callback &optional f]
  `(fn [entry (acc h prev t) &as acc]
     (let [value (~callback entry)]
       ;; TODO revise to use hash set
       (if (gb_sets.is_member value prev)
           (skip acc)
         (next-with-acc ~f entry h (gb_sets.add value prev) t)))))
