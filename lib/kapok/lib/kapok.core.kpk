;;; Core functions and macros for kapok lang.
;; -*- Kapok -*-

;; all functions here are imported for every ns by default.

(ns kapok.core
  (require erlang
           lists
           ordsets
           sets
           maps
           code
           kapok_scanner
           kapok_ast
           kapok_error
           kapok_utils))

;; list operators

(defalias head hd
  """Alias to `hd`.""")

(defn hd [list]
  """Returns the head of a list, that is, the first element.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (hd [1 2 3 4])
      1

  """
  (erlang.hd list))

(defalias tail tl
  """Alias to `tl`.""")

(defn tl [list]
  """Returns the tail of a list, that is, the list minus the first element.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (tl [1 2 3 #go])
      [2, 3, #go]
  """
  (erlang.tl list))

;; special forms

(defmacro define [name value]
  """Defines a macro with name `name` and return `value`."""
  `(defmacro ~name [] (&when :true)
     ""
     ~value))

;; the conditionals

(defalias false? nil?)

(defn nil?
  """Returns `:true` if `x` is nil, `:false` otherwise."""
  ([:nil] :true)
  ([[]] :true)
  ([:false] :true)
  ([_] :false))

(defn true? [x]
  """Returns `:true` if `x` is the value true, `:false` otherwise."""
  (erlang.not (false? x)))

(defmacro if [test then &optional else]
  """Evaluates test. If logical true, evaluates and yields then, otherwise,
  evaluates and yields else.
  If else is not supplied it defaults to nil.
  """
  ;; the `core` namespace may be unimported where this macro is used,
  ;; so we'd better write the calling to `true?` in dot-identifier form
  ;; to specify its namespace.
  `(case (kapok.core.true? ~test)
     (:true ~then)
     (:false ~else)))

(defmacro if-not [test then &optional else]
  """Evaluates test. If logical false, evaluates and return then expr,
  otherwise else expr.
  If else is not supplied it defaults to nil."""

  `(case (kapok.core.false? ~test)
     (:true ~then)
     (:false ~else)))

(defmacro when [test &rest body]
  """Evaluates test. If logical true, evaluates body in an implicit do."""
  `(case (kapok.core.true? ~test)
     (:true ~@body)
     (:false #ok)))

(defalias unless when-not
  """Alias to `when-not`.""")

(defmacro when-not [test &rest body]
  """Evaluates test. If logical false, evaluates body in an implicit do."""
  `(case (kapok.core.true? ~test)
     (:true #ok)
     (:false ~@body)))

;; TODO move all these functions to protocol `seq`
(defn first [list]
  (case (nil? list)
    (:true :nil)
    (:false (head list))))

(defn second [list]
  (first (tail list)))

(defn next
  ([[]] :nil)
  ([[_]] :nil)
  ([[_ & t]] t)
  ([_] :nil))

(defn rest
  ([:nil] [])
  ([[]] [])
  ([[_]] [])
  ([[_ & t]] t))

(defmacro cond [&rest clauses]
  """Takes a set of test/expr pairs. It evaluates each test one at a time.
  If a test returns logical true, cond evaluates and returns the value of
  the corresponding expr and doesn't evaluate any of the other tests or exprs.
  (cond) returns `#ok`.
  """
  (unless (nil? clauses)
    `(kapok.core.if ~(first clauses)
                    ~(case (next clauses)
                       (:nil
                        (erlang.throw "cond requires an even number of forms"))
                       (_
                        (second clauses)))
                  (kapok.core.cond ~@(rest (rest clauses))))))

;; macro

(defn gensym
  """Returns a new symbol with a unique name.
  If no prefix is supplied, the name is #:G%, where % is some unique number.
  If a prefix string is supplied, the name is #:|prefix%|,
  where % is some unique number.
  """
  ([]
   (let [name (kapok_utils.gensym)]
     {#identifier [] name}))
  ([prefix]
   (let [name (kapok_utils.gensym prefix)]
     {#identifier [] name})))

;; functions and operators

(defn apply [fun args]
  """Invokes the given `fun` with the arugments `args`.

  Inlined by the compiler.

  ## Examples

      kapok> (apply (fn [x] (* 2 x)) [2])
      4

  """
  (erlang.apply fun args))

(defn apply [module function args]
  """Invokes the given `fun` from `module` with the arguments `args`.

  Inlined by the compiler.

  ## Examples

      kapok> (apply lists reverse [1 2 3])
      [3 2 1]

  """
  (erlang.apply module function args))

(defn binary-part [binary start length]
  """Extracts the part of thee binary starting at `start` with length `length`.
  Binary are zero-indexed.

  If `start` or `length` reference in any way outside the binary, an
  `ArgumentError` exception is raised.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (binary-part "foo" 1 2)
      "oo"

  A negative `length` can be used to extract bytes that come *before* the byte
  at `start`:

      kapok> (binary-part "Hello" 5 -3)
      "llo"

  """
  (erlang.binary_part binary start length))

(defn bit-size [bitstring]
  """Returns an integer which is the size in bits of `bitstring`.

  Allowed in guard tests.  Inlined by the compiler.

  ## Examples

      kapok> (bit-size <<(433 (:size 16)) (3 (:size 3))>>)
      19

      kapok> (bit-size <<1 2 3>>)
      24

  """
  (erlang.bit_size bitstring))

(defn byte-size [bitstring]
  """Returns the number of bytes needed to contain `bitstring`.

  That is, if the number of bits in `bitstring` is not divisible by 8, the
  resulting number of bytes will be rounded up (by excess). This operation
  happens in constant time.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (byte-size <<(433 (:size 16)) (3 (:size 3))>>)
      3

      kapok> (byte-size <<1 2 3>>)
      3

  """
  (erlang.byte_size bitstring))

(defn tuple-size [tuple]
  """Returns an integer which is the number of elements in `tuple`.

  This operation happens in constant time.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (tuple-size {#a #b #c})
      3

  """
  (erlang.tuple_size tuple))

;; Guard predicates

(defn atom? [term]
  """Returns `:true` if `term` is an atom; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_atom term))

(defn binary? [term]
  """Returns `:true` if `term` is a binary; otherwise `:false`.

  A binary always contains a complete number of bytes.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (binary? "foo")
      :true

      kapok> (binary? <<(1 (:size 3))>>)
      :false
  """
  (erlang.is_binary term))

(defn bitstring? [term]
  """Returns `:true` if `term` is a bitstring (including a binary);
  otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (bitstring? "foo")
      :true

      kapok> (bitstring? <<(1 (:size 3))>>)
      :true

  """
  (erlang.is_bitstring term))

(defn boolean? [term]
  """Returns `:true` if `term` is either the atom `:true` or the atom `:false`
  (i.e., a boolean); otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_boolean term))

(defn builtin? [module function arity]
  """Returns `:true` if `(module function arity)` is a BIF implemented in C;
  otherwise `:false`.

  This BIF is useful for builders of closs-reference tools.
  """
  (erlang.is_builtin module function arity))

(defn float? [term]
  """Returns `:true` if `term` is a floating point number;
  otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_float term))

(defn function? [term]
  """Returns `:true` if `term` is a function; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_function term))

(defn function? [term, arity]
  """Returns `:true` if `term` is a function that can be applied with
  `arity` number of arguments; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (function? (fn [x] (* 2 x)) 1)
      :true

      kapok> (function? (fn [x] (* 2 x)) 2)
      :false

  """
  (erlang.is_function term arity))

(defn integer? [term]
  """Returns `:true` if `term` is an integer; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_integer term))

(defn list? [term]
  """Returns `:true` if `term` is a list with zero or more elements;
  otherwist returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_list term))

(defn map? [term]
  """Returns `:true` if `term` is a map; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_map term))

(defn number? [term]
  """Returns `:true` if `term` is an integer or a floating point number;
  otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_number term))

(defn pid? [term]
  """Returns `:true` if `term` is a pid (process identifier);
  otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_pid term))

(defn port? [term]
  """Returns `:true` if `term` is a port identifier; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_port term))

(defn reference? [term]
  """Returns `:true` if `term` is a reference; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_reference term))

(defn tuple? [term]
  """Returns `:true` if `term` is a tuple; otherwise returns `:false`.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.is_tuple term))

(defn length [list]
  """Returns the length of `list`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (length [1 2 3 4 5 6 7 8 9])
      9

  """
  (erlang.length list))

(defn make-ref []
  """Returns an almost unique reference among connected nodes.

  The returned reference will re-occur after approximately 2^82 calls;
  therefore it is unique enough for practical purposes.

  Inlined by the compiler.
  """
  (erlang.make_ref))

(defn map-size [map]
  """Returns the size of a map.

  The size of a map is the number of key-value pairs that the map contains.

  This operation happens in constant time.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (map-size #{:a "foo" :b "bar"})
      2

  """
  (erlang.map_size map))

(defn max
  """Returns the biggest of the given terms according to Erlang's term ordering.
  If the terms compare equal, the first one is returned.

  Inlined by the complier only when arity is 2.

  ## Examples

      kapok> (max 1 2)
      2

      kapok> (max #a #b)
      #b

  """
  ([x] x)
  ([x y &rest more] (lists.foldl (fn [n acc]
                                   (erlang.max acc n))
                                 x
                                 [y & more])))

(defn min
  """Returns the smallest of the given terms according to Erlang's term ordering.
  If the terms compare equal, the first one is returned.

  Inlined by the compiler.

  ## Examples

      kapok> (min 1 2)
      1

      kapok> (min #"foo" #"bar")
      #"bar"

  """
  ([x] x)
  ([x y &rest more] (lists.foldl (fn [n acc]
                                   (erlang.min acc n))
                                 x
                                 [y & more])))

;; process and message

(defn node []
  """Returns an atom representing the name of the local node.
  If the node is not alive, `#nonode@nohost` is returned instead.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.node))

(defn node [arg]
  """Returns the node where the given argument `arg` originates.
  The argument can be a pid, a reference, or a port.
  If the local node is not alive, `#nonode@nohost` is returned.

  Allowed in guard tests. Inlined by the compiler.
  """
  (erlang.node arg))

(defn self []
  """Returns the pid (process identifier) of the calling process.

  Allowed in guard tests. Inlined by thte compiler.
  """
  (erlang.self))

(defn send [dest message]
  """Sends a message to the given `dest` and returns the message.

  `dest` may be a remote or local pid, a (local) port, a locally
  registered name, or a tuple `{registered_name, node}` for a registered
  name at another node.

  Inlined by the compiler.

  ## Examples

      kapok> (send (self) #hello)
      #hello

  """
  (erlang.send dest message))

(defn spawn [fun]
  """Spawns the given function and returns its pid.

  Check the `process` and `node` namespaces for other functions
  to handle processes, including spawning functions in nodes.

  Inlined by the compiler.

  ## Examples

      (let [current (self)
            child (spawn (fn []
                           (send current {(self), (inc 2)})))]
        (receive
          ({child, 3} (io.format "Received 3 back"))))

  """
  (erlang.spawn fun))

(defn spawn [module fun args]
  """Spawns the given module and function passing the given args
  and returns its pid.

  Check the `process` and `node` namespaces for other functions
  to handle precesses, including spawning functions in nodes.

  Inlined by the compiler.

  ## Examples

      (spawn some-module function [1 2 3])

  """
  (erlang.spawn module fun args))

(defn spawn-link [fun]
  """Spawns the given function, links it to the current process and returns
  its pid.

  Check the `process` and `node` namespaces for other functions
  to handle processes, including spawning functions in nodes.

  Inlined by the compiler.

  ## Examples

      (let [current (self)
            child (spawn_link (fn []
                                (send current {(self), (inc 2)})))]
        (receive
          ({child, 3} (io.format "Received 3 back"))))

  """
  (erlang.spawn_link fun))

(defn spawn-link [module fun args]
  """Spawns the given module and function passing the given args,
  links it to the current process and returns its pid.

  Checks the `process` and `node` namespaces for other functions
  to handle processes, including spawning functions in nodes.

  Inlined by the compiler.

  ## Examples

      (spawn-link some-module function [1 2 3])

  """
  (erlang.spawn_link module fun args))

(defn spawn-monitor [fun]
  """Spawns the given module and function passing the given args,
  monitors it and returns its pid and monitoring reference.

  Check the `process` and `node` namespaces for other functions
  to handle processes, including spawning functions in nodes.

  Inlined by the compiler.

  ## Examples

      (let [current (self)]
        (spawn-monitor (fn []
                         (send current {(self), (inc 2)}))))

  """
  (erlang.spawn_monitor fun))

(defn spawn-monitor [module fun args]
  """Spawns the given module and functions passing the given args,
  monitors it and returns its pid and monitoring reference.

  Check the `process` and `node` namespaces for other functions
  to handle processes, including spawning functions in nodes.

  Inlined by the compiler.

  ## Examples

      (spawn-monitor some-module function [1 2 3])

  """
  (erlang.spawn_monitor module fun args))

(defn exit [reason]
  """Stops the execution of the calling process with the given reason.

  Since evaluating this function casuses the process to terminate,
  it has no return value.

  Inlined by the compiler.
  """
  (erlang.exit reason))

(defn throw [term]
  """A non-local return from a function.

  Inlined by the compiler.
  """
  (erlang.throw term))

;; Arithmetic Operators

(defn +
  """Returns the sum of numbers. `(+)` return 0.

  Allowed in guard tests and inlined by the compiler only when arity is 1 or 2.

  ## Examples

      kapok> (+)
      0

      kapok> (+ 1 2)
      3

  """
  ([&optional (x 0)] x)
  ([x y &rest more] (lists.foldl (fn [n acc]
                                   (erlang.+ acc n))
                                 x
                                 [y & more])))

(defn -
  """Subtracts all numbers in `rest` from `n` and returns th result.
  If no number is supplied in `rest`, returns the negation of 'n'.

  Allowed in guard tests and inlined by the compiler only when arity is 1 or 2.

  ## Examples

      kapok> (- 2)
      -2

      kapok> (- 1 2)
      -1

  """
  ([x] (erlang.- 0 x))
  ([x y &rest more] (lists.foldl (fn [n acc]
                                   (erlang.- acc n))
                                 x
                                 [y & more])))

(defn *
  """Returns the product of numbers. `(*)` returns 1.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (*)
      1

      kapok> (* 1 2)
      2

  """
  ([&optional (x 1)] x)
  ([x y &rest more] (lists.foldl (fn [n acc]
                                   (erlang.* acc n))
                                 x
                                 [y & more])))

(defn /
  """Returns numerator `n` divided by all of the denominatars in `rest`.
  If no denominator is supplied in `rest`, returns 1/numerator.

  The result is always a float. Use `div` and `rem` if you want
  an integer division or the remainder.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (/ 2)
      0.5

      kapok> (/ 2 1)
      2.0

  """
  ([x] (erlang./ 1 x))
  ([x y &rest more] (lists.foldl (fn [n acc]
                                   (erlang./ acc n))
                                 x
                                 [y & more])))

(defn div [x y]
  """Performs in integer division.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (div 5 2)
      2

  """
  (erlang.div x y))

(defn rem [x y]
  """Computes the remainder of an integer division.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (rem 5 2)
      1

  """
  (erlang.rem x y))

(defalias minus-one dec
  """Alias to `dec`.""")

(defalias plus-one inc
  """Alias to `inc`.""")

(defn dec [n]
  """Returns a number one less than the argument `n`."""
  (- n 1))

(defn inc [n]
  """Returns a number one greater than the argument `n`."""
  (+ n 1))

;; math

(defn number-to-float [n]
  """Convert the given arugment `x` from a number to a float.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (number-to-float 55)
      55.0

  """
  (erlang.float n))

(defn abs [number]
  """Returns the arithmetical absolute value of `number`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (abs -3.33)
      3.33

      kapok> (abs -3)
      3

  """
  (erlang.abs number))

(defn round [n]
  """Rounds a number to the nearest integer.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (round 5.6)
      6

      kapok> (round 5.2)
      5

      kapok> (round -9.9)
      -10

  """
  (erlang.round n))

(defn trunc [number]
  """Returns an integer by truncating `number`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (trunc 5.5)
      5

  """
  (erlang.trunc number))

;; Bitwise Operators

(defn bnot [x]
  """Calculates the bitwise NOT of the given argument.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (bnot 2)
      -3

  """
  (erlang.bnot x))

(defalias bit-not bnot
  """Alias to `bnot`.""")

(defn band [x y &rest more]
  """Calculates the bitwise AND of the given arguments.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (band 9 3)
      1

      kapok> (band 59 9 3)
      1

  """
  (lists.foldl (fn [n acc]
                 (erlang.band n acc))
               x
               [y & more]))

(defalias bit-and band
  """Alias to `band`.""")

(defn bor [x y &rest more]
  """Calculates the bitwise OR of the given arguments.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (bor 9 3)
      11

  """
  (lists.foldl (fn [n acc]
                 (erlang.bor n acc))
               x
               [y & more]))

(defalias bit-or bor
  """Alias to `bor`.""")

(defn bxor [x y &rest more]
  """Calculates the bitwise XOR of the given arguments.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (bxor 9 3)
      10

  """
  (lists.foldl (fn [n acc]
                 (erlang.bxor n acc))
               x
               [y & more]))

(defalias bit-xor bxor
  """Alias to `bxor`.""")

(defn bsl [x n]
  """Calculates the result of an arithmetic left bitshift.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (bsl 1 2)
      4

      kapok> (bsl 1 -2)
      0

      kapok> (bsl -1 2)
      -4

      kapok> (bsl -1 -2)
      -1

  """
  (erlang.bsl x n))

(defalias bit-shift-left bsl
  """Alias to `bsl`.""")

(defn bsr [x n]
  """Calculates the result of an arithmetic right bitshift.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (bsr 1 2)
      0

      kapok> (bsr 1 -2)
      4

      kapok> (bsr -1 2)
      -1

      kapok> (bsr -1 -2)
      -4

  """
  (erlang.bsr x n))

(defalias bit-shift-right bsr
  """Alias to `bsr`.""")

;; Comparators

(defn- all [_predicate _acc []]
  :true)
(defn- all [predicate acc [h & t]]
  (case (predicate h acc)
    (:true (all predicate h t))
    (:false :false)))

(defn <
  """Returns `:true` if the given arguments are in monotonically increasing
  order, otherwise `:false`.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (< 1)
      :true

      kapok> (< 1 2 2)
      :false

  """
  ([_x] :true)
  ([x y &rest more] (all (fn [n acc] (erlang.< acc n))
                         x
                         [y & more])))

(defn >
  """Returns `:true` if the given arguments are in monotonically decreasing
  order, otherwise `:false`.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (> 1)
      :true

      kapok> (> 3 2 2)
      :false

  """
  ([_x] :true)
  ([x y &rest more] (all (fn [n acc] (erlang.> acc n))
                         x
                         [y & more])))

(defn <=
  """Returns `:true` if the given arguments are in monotonically non-decreasing
  order, otherwise `:false`.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (<= 1)
      :true

      kapok> (<= 1 2 1)
      :false

  """
  ([_x] :true)
  ([x y &rest more] (all (fn [n acc] (erlang.=< acc n))
                         x
                         [y & more])))

(defn >=
  """Returns `:true` if the given arguments are in monotonically non-increasing
  order, othenwise `:false`.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (>= 1)
      :true

      kapok> (>= 3 2 3)
      :false

  """
  ([_x] :true)
  ([x y &rest more] (all (fn [n acc] (erlang.>= acc n))
                         x
                         [y & more])))

(defn ==
  """Returns `:true` if the given arguments all have the equivalent value
  (type-independent), otherwise `:false`.

  This operator considers 1 and 1.0 to be equal. For match semantics,
  use '===' instead.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Exapmles

      kapok> (== 1 2)
      :false

      kapok> (== 1 1.0)
      :true

  """
  ([_x] :true)
  ([x y &rest more] (all (fn [n acc] (erlang.== acc n))
                         x
                         [y & more])))

(defn !=
  """Returns `:true` if the given arguments all have the unequal value
  (type-independent), otherwise `:false`.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (!= 1 1.0)
      :false

      kapok> (!= 1 2)
      :true

  """
  ([_x] :true)
  ([x y &rest more]
   (let [{total set} (lists.foldl
                      (fn [n {count acc}]
                        {(inc count) (ordsets.add_element n acc)})
                      {0 (ordsets.new)}
                      [x y & more])]
     (== total (ordsets.size set)))))

(defn ===
  """Returns `:true` if the given arguments do match (identical),
  otherwise `:false`.

  This operator gives the same semantics as the one existing in
  pattern matching, i.e., `1` and `1.0` are equal, but they do not match
  (not identical).

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (=== 1 2)
      :false

      kapok> (=== 1 1.0)
      :false

  """
  ([_x] :true)
  ([x y &rest more] (all (fn [n acc] (erlang.#'=:=' acc n))
                         x
                         [y & more])))

(defn !==
  """Returns `:true` if the given arguments all do not match (not identical),
  otherwise `:false`.

  All terms in Kapok can be compared with each other.

  Allowed in guard tests and inlined by the compiler only when arity is 2.

  ## Examples

      kapok> (!== 1 2)
      :true

      kapok> (!== 1 1.0)
      :false

  """
  ([_x] :true)
  ([x y &rest more]
   (let [{total set} (lists.foldl
                      (fn [n {count acc}]
                        {(inc count) (sets.add_element n acc)})
                      {0 (sets.new)}
                      [x y & more])]
     (== total (sets.size set)))))

;; Boolean and Short-circuit Boolean Operators

(defmacro not [x]
  """Returns `:true` if `x` is logical false, otherwise `:false`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (not :false)
      :true

  """
  `(case ~x
     (bool (&when (&or (erlang.#'=:=' bool :false)
                       (erlang.#'=:=' bool :nil)))
       :true)
     (_ :false)))


(defmacro and
  """Boolean and (short-circuit).

  Evaluates the given arguments one at a time, from left to right.
  If any one returns `:false`, returns that value and doesn't evaluate
  the left arugments, otherwise it returns the value of the last argument.
  (and) returns `:true`.

  Requires all the arguments except the last to be a boolean since
  it short-curcuits.

  Allowed in guard tests and inlined by the compiler when arity is 2.

  ## Examples

      kapok> (and :true :false)
      :false

      kapok> (and :true "yay!")
      "yay!"

  """
  ([]
   :true)
  ([x &rest more]
   (case more
     ([] x)
     (_ (let [sym (gensym "and")]
          `(let [~sym ~x]
             (kapok.core.if ~sym (kapok.core.and ~@more) ~sym)))))))

(defmacro or
  """Boolean or (short-circuit).

  Evaluates the given arguments one at a time, from left to right.
  If any one returns `:false`, returns that value and doesn't evaluate
  the left arguments, otherwise it returns the value of the last argument.
  (or) return `:false`.

  Requires all the arguments except the last to be a boolean since
  it short-circuits.

  Allowed in guard tests and inlined by the compiler when arity is 2.

  ## Examples

      kapok> (or :true :false)
      :true

      kapok> (or :false 42)
      42

  """
  ([] :true)
  ([x &rest more]
   (case more
     ([] x)
     (_ (let [sym (gensym "or")]
          `(let [~sym ~x]
             (kapok.core.if ~sym ~sym (kapok.core.or ~@more))))))))

(defn xor [x y]
  """Boolean xor.

  Returns `:true` if `x` and `y` are evaluated to different logical value
  (`:true` or `:false`), otherwise returns `:false`.

  Requires all the arguments to be a boolean.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (xor :true :false)
      :true

      kapok> (xor :true :true)
      :false

  """
  (erlang.xor x y))

;; Tuple Element Operators

(defn elem [tuple index]
  """Gets the element at the zero-based `index` in `tuple`.

  Allowed in guard tests. Inlined by the compiler.

  ## Examples

      kapok> (elem {#foo #bar 3} 1)
      #bar

  """
  (erlang.element (inc index) tuple))

(defn set-elem [tuple index value]
  """Sets `value` at the given zero-based `index` in `tuple`,
  and returns that tuple.

  Inlined by the compiler.

  ## Examples

      kapok> (set-elem {#foo #bar 3} 0 #baz)
      {#baz #bar 3}

  """
  (erlang.setelement (inc index) tuple value))

;;; functions for macro programming

(defn token-meta [token]
  (kapok_scanner.token_meta token))

(defn token-symbol [token]
  (kapok_scanner.token_symbol token))

(defn meta-line [meta]
  """Returns the line number of the specified `meta`."""
  (kapok_utils.meta_line meta))

(defn meta-column [meta]
  """Returns the column number of the specifed `meta`."""
  (kapok_utils.meta_column meta))

(defn empty-doc []
  (kapok_ast.empty_doc))

(defn macro-error [file meta format &rest args]
  (kapok_error.compile_error meta file format args))

;;; special functions and macros

(defn function-exported? [module function arity]
  """Returns `:true` if `module` is loaded and contains
  a public `function` with given `arity`, otherwise `:false`.

  Note that this function does not load the module in case
  it is not loaded. Check `(code-server.ensure-loaded 1)` for more
  information.

  ## Examples

      kapok> (function-exported? seq member? 1)
      :true

  """
  (erlang.function_exported module function arity))

(defn macro-exported? [module macro arity]
  """Returns `:true` if `module` is loaded and cantains
  a public `macro` with the given `arity`, otherwise `:false`.

  Note that this function does not load the module in case
  it is not loaded. Check `(code-server.ensure-loaded 1)` for more
  information.

  ## Examples

      kapok> (macro-exported? core if 3)
      :true

  """
  (case (code.is_loaded module)
    ({#file _}
     (lists.member {macro arity}
                   (module.__info__ #macros)))
    (_
     :false)))

(defmacro attr [module attr]
  `(kapok.core.first (kapok.alist.get (~module.#module_info #attributes) ~attr)))

(defmacro attr [attr]
  `(kapok.core.attr (__MODULE__) ~attr))

(defalias get-attr attr)
(defalias get-attribute attr)

(defmacro to-string
  """Converts the argument to a string according to the
  `string.chars` protocol.

  ## Examples

      kapok> (to-string #foo)
      "foo"

  """

  ([arg] (&when (erlang.is_binary arg))
   arg)

  ([arg]
   `(kapok.string.chars.to-string ~arg)))

(defmacro to-char-list [arg]
  """Converts the argument to a char list according to the `list.chars` protocol.

  ## Examples

      kapok> (to-char-list #foo)
      #"foo"

  """

  `(kapok.list.chars.to-char-list ~arg))

(defmacro match? [{#identifier _ #_} &as _pattern _expr]
  """A convenience macro that checks if the right side (an expression) matches
  the left side (a pattern)."""
  :true)

(defmacro match? [pattern expr]
  `(case ~expr
     (~pattern :true)
     (_ :false)))


(defmacro -> [x &rest forms]
  "Threads the expr through the forms. Inserts `x` as the
  second item in the first form, making a list of it if it is not
  a list already. If there are more forms, inserts the first form as
  the second item in second form, etc."
  (case forms
    ([] x)
    (_
     (let [form (first forms)
           left (rest forms)
           y (case form
               ({#list meta []}
                (macro-error (maps.get #file _&ctx)
                             meta
                             "expected function call but got empty list"))
               ({#list _ args}
                (let [h (head args)
                      t (tail args)]
                  `(~h ~x ~@t)))
               (_
                `(~form ~x)))]
       `(-> ~y ~@left)))))

(defmacro ->> [x &rest forms]
  "Threads the expr through the forms. Inserts `x` as the
  last item in the first form, making a list of it if it is not
  a list already. If there are more forms, inserts the first form as
  the last item in second form, etc."
  (case forms
    ([] x)
    (_
     (let [form (first forms)
           left (rest forms)
           y (case form
               ({#list meta []}
                (macro-error (maps.get #file _&ctx)
                             meta
                             "expected function call but got empty list"))
               ({#list _ args}
                `(~@args ~x))
               (_
                `(~form ~x)))]
       `(->> ~y ~@left)))))
