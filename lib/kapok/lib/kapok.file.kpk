(ns kapok.file
  """This module contains functions to manipulate files.

  Some of those functions are low-level, allowing the user
  to interact with the file or IO devices, like `(open 2)`,
  `(copy 3)` and others. This module also provides higher
  level functions that work with filenames and have their naming
  based on UNIX variants. For example, one can copy a file
  via `(cp 3)` and remove files and directories recursively
  via `(rm-rf 1)`.

  ## Encoding

  In order to write and read files, one must use the functions
  In the `io` module. By default, a file is opened in binary mode
  which requires the functions `(io.binread 2)` and `(io.binwrite 2)`
  to interact with the file. A developer may pass `#utf8` as an
  option whin opening the file, then the slower `(io.read 2)` and
  `(io.write 2)` functions must be used as they are responsible for
  doing the proper conversions and data guarantees.

  Note that filenames when given as char lists in Kapok are
  always treated as UTF-8. In particular, we expect that the
  shell and the operating system are configured to use UTF8
  encoding. Binary filenames are considering raw and passed
  to the OS as is.

  ## API

  Most of the functions in this module return `#ok` or
  `{#ok, result}` in case of success, `{#error reason}`
  otherwise. Those function are also followed by a variant
  that ends with `!` which returns the result (without the
  `{#ok result}` tuple) in case of success or raises an
  exception in case it fails. For example:

      (file.read "hello.txt")
      ;;=> {#ok "World"}

      (file.read "invalid.txt")
      ;;=> {#error #enoent}

      (file.read! "hello.txt")
      ;;=> "World"

      (file.read! "invalid.txt")
      ;;=> raises error

  In general, a developer should use the former in case they want
  to react if the file does not exist. The latter should be used
  when the developer expects their software to fail in case the
  file cannot be read (i.e. it is literally an exception).

  ## Processes and raw files

  Every time a file is opened, Kapok spawns a new process. Writing
  to a file is equivalent to sending messages to that process that
  writes to the file descriptor.

  This means files can be passed between nodes and message passing
  guarantees they can write to the same file in a network.

  However, you may not always want to pay the price for this abstraction.
  In such cases, a file can be opened in `#raw` mode. the options `#read-ahead`
  and `#delayed-write` are also useful when operating large files or
  working with files in tight loops.

  Check http://www.erlang.org/doc/man/file.html#open-2 for more information
  about such options and other performance considerations.
  """

  (require kapok_utils
           calender
           file
           (kapok (file.copy-error
                   file.stat
                   io
                   path
                   seq))))

(defn regular? [path]
  """Returns `:true` if the path is a regular file.

  ## Examples

      (file.regular? "kapok.file.kpk")    ;;=> :true

  """

  (== (kapok_utils.read_file_type (io.chardata-to-string path))
      {#ok #regular}))

(defn dir? [path]
  "Returns `:true` if the path is a directory."
  (== (kapok_utils.read_file_type (io.chardata-to-string path))
      {#ok #directory}))

(defn exists? [path]
  """Returns `:true` if the given path exists.
  It can be regular file, directory, socket,
  symbolic link, named pipe or device file.

  ## Examples

      (file.exists? "test/")
      ;;=> :true

      (file.exists? "missing.txt")
      ;;=> :false

      (file.exists? "/dev/null")
      ;;=> :true

  """

  (match? {#ok _}
          (file.read_file_info (io.chardata-to-string path))))

(defn mkdir [path]
  """Tries to create the directory `path`. Missing parent directories are not created.
  Returns `#ok` if successful, or `{#error reason}` if an error occurs.

  Typical error reasons are:

    * `#eacces` - missing search or write permissions for the parent
      directories of `path`
    * `#eexist` - there is already a file or directory named `path`
    * `#enoent` - a component of `path` does not exist
    * `#enospc` - there is no space left on the device
    * `#enotdir` - a component of `path` is not a directory;
      on some platforms, `#enoent` is returned instead

  """
  (file.make_dir (io.chardata-to-string path)))

(defn mkdir! [path]
  "Same as `(mkdir 1)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (mkdir path)
    (#ok #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "make directory"}
                              {#path (io.chardata-to-string path)}]))))

(defn mkdir-p [path]
  """Tries to create the directory `path`. Missing parent directories are created.
  Returns `#ok` if successful, or `{#error reason}` if an error occurs.

  Typical error reasons are:

    * `#eacces` - missing search or write permissions for the parent
      directories of `path`
    * `#enospc` - there is no space left on the device
    * `#enotdir` - a component of `path` is not a directory

  """
  (do-mkdir-p (io.chardata-to-string path)))

(defn- do-mkdir-p ["/"]
  #ok)

(defn- do-mkdir-p [path]
  (if (dir? path)
      #ok
    (do
     (let [parent (path.dirname path)]
       (if (== parent path)
           ;; Protect against infinite loop
           {#error #einval}
         (let [_ (do-mkdir-p parent)]
           (case (file.make_dir path)
             ({#error #eexist} &as error
              (if (dir? path)
                  #ok
                error))
             (other
              other))))))))

(defn mkdir-p! [path]
  "Same as `(mkdir-p 1)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (mkdir-p path)
    (#ok #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "make directory (with -p)"}
                              {#path (io.chardata-to-string path)}]))))

(defn read [path]
  """Returns `{#ok binary}`, where `binary` is a binary data object
  that contains the contents of `path`, or `{#error reason}`
  if an error occurs.

  Typical error reasons:

    * `#enoent` - the file does not exist
    * `#eacces` - missing permission for reading the file,
                  or for searching one of the parent directories
    * `#eisdir` - the named file is a directory
    * `#enotdir` - a component of the file name is not a directory;
                   on some platforms, `#enoent` is returned instead
    * `#enomem` - there is not enough memory for the contents of the file

  You can use the Erlang stdlib `(file.format-error 1)` to get a descriptive
  string of the error.

  """
  (file.read_file (io.chardata-to-string path)))


(defn read! [path]
  (case (read path)
    ({#ok binary}
     binary)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "read file"}
                              {#path (io.chardata-to-string path)}]))))

(defn stat [path &optional (opts [])]
  """Returns information about the `path`. If it exists, it
  returns a `{#ok info}` tuple, where info is a `file.stat` struct.
  Returns `{#error reason}` with the same reasons as `(read 1)` if a failure occurs.

  ## Options

  The accepted options are:

    * `#time` - configures how the file timestamps are returned

  The values for `#time` can be:

    * `#local` - returns a `{data time}` tuple using the machine time
    * `#universal` - returns a `{data time}` tuple in UTC
    * `#posix` - returns the time as integer seconds since epoch

  """

  (case (file.read_file_info (io.chardata-to-string path) opts)
    ({#ok fileinfo}
     {#ok (file.stat.from-record fileinfo)})
    (error
     error)))

(defn stat! [path &optional (opts [])]
  """Same as `(stat 2)` but returns the `file.stat` directly and
  throws `file.error` if an error is returned.
  """
  (case (stat path opts)
    ({#ok info}
     info)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "read file stats"}
                              {#path (io.chardata-to-string path)}]))))

(defn lstat [path &optional (opts [])]
  """Returns information about the `path`. If the file is a symlink sets
  the `type` to `#symlink` and returns `file.stat` for the link. For any
  other file, returns exactly the same values as `(stat 2)`. For more details
  see http://www.erlang.org/doc/man/file.html#read_link_info-2

  ## Options

  The accepted options are:

    * `#time` - configures how the file timestamps are returned

  The values for `#time` can be:

    * `#local` - returns a `{date time}` tuple using the machine time
    * `#universal` - returns a `{data time}` tuple in UTC
    * `#posix` - returns the time as integer secords since epoch

  """
  (case (file.read_link_info (io.chardata-to-string path) opts)
    ({#ok fileinfo}
     {#ok (file.stat.from-record fileinfo)})
    (error
     error)))

(defn lstat! [path &optional (opts [])]
  """Same as `(lstat 2)` but returns the `file.stat` directly and
  throws `file.error` if an error is returned.
  """
  (case (lstat path opts)
    ({#ok info}
     info)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "read file stats"}
                              {#path (io.chardata-to-string path)}]))))

(defn write-stat [path stat &optional (opts [])]
  """Writes the given `file.stat` back to the filesystem at the given
  path. Returns `#ok` or `{#error reason}`.
  """
  (file.write_file_info (io.chardata-to-string path) (file.stat.to-record stat) opts))

(defn write-stat! [path stat &optional (opts [])]
  """Same as `(write-stat 3)` but raises an exception if it fails.
  Return `#ok` otherwise.
  """
  (case (write-stat path stat opts)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "write file stats"}
                              {#path (io.chardata-to-string path)}]))))

(defn touch [path &optional (time (calendar.local_time))]
  """Updates modification time (mtime) and access time (atime) of
  the given file. File is created if it doesn't exist.
  """
  (let [p (io.chardata-to-string path)]
    (case (file.change_time p time)
      ({#error #enoent}
       (touch-new p time))
      (other
       other))))

(defn- touch-new [path time]
  (case (write path "" [#append])
    (#ok
     (file.change_time path time))
    ({#error _reason} &as error
     error)))

(defn touch! [path &optional (time (calendar.local_time))]
  (case (touch path time)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "touch"}
                              {#path (io.chardata-to-string path)}]))))

(defn ln-s [existing new]
  """Creates a symbolic link `new` to the file or directory `existing`.

  Returns `#ok` if successful, `{#error reason}` otherwise.
  If the operating system does not support symlinks, returns
  `{#error #enotsup}`.
  """
  (file.make_symlink existing new))

(defn copy [source destination &optional (bytes-count #infinity)]
  """Copies the contents of `source` to `destination`.

  Both parameters can be a filename or an io device opened
  with `(open 2)`. `bytes-count` specifies the number of
  bytes to copy, the default being `#infinity`.

  If file `destination` already exists, it is overwritten
  by the contents in `source`.

  Returns `{#ok bytes-copied}` if successful,
  `{#error reason}` otherwise.

  Compared to the `(cp 3)`, this function is more low-level,
  allowing a copy from device to device limited by a number of
  bytes. On the other hand, `(cp 3)` performs more extensive
  checks on both source and destination and it also preserves
  the file mode after copy.

  Typical error reasons are the the same in `(open 2)`,
  `(read 1)` and `(write 3)`.
  """

  (file.copy (io.chardata-to-string source)
             (io.chardata-to-string destination)
             bytes-count))

(defn copy! [source destination &optional (bytes-count #infinity)]
  """The same as `(copy 3)` but raises an `file.copy-error` if it fails.
  Returs the `bytes-copied` otherwise.
"""
  (case (copy source destination bytes-count)
    ({#ok bytes-count}
     bytes-count)
    ({#error reason}
     (raise kapok.file.copy-error [{#reason reason}
                                   {#action "copy"}
                                   {#source (io.chardata-to-string source)}
                                   {#destination
                                    (io.chardata-to-string destination)}]))))

(defn cp [source destination &optional (callback (fn [_ _ ] :true))]
  """Copies the contents in `source` to `destination` preserving its mode.

  If a file already exists in the destination, it invokes a callback
  which should return `:true` if the existing file should be overwritten,
  `:false` otherwise. It defaults to return `:true`.

  It returns `#ok` in case of success, returns
  `{#error reason}` otherwise.

  If you want to copy contents from an io device to another device
  or do a straight copy from a source to a destination without
  preserving modes, check `(copy 3)` instead.

  Note: The command `cp` in Unix systems behaves differently depending
  if `destination` is an existing directory or not. We have chosen to
  explicitly disallow this behaviour. If `destination` is a directory,
  an error will be returned.
  """

  (let [s (io.chardata-to-string source)
        d (io.chardata-to-string destination)]
    (case (do-cp-file s d callback [])
      ({#error reason _}
       {#error reason})
      (_
       #ok))))

(defn cp! [source destination &optional (callback (fn [_ _] :true))]
  """The same as `(cp 3)`, but raises `file.copy-error` if it fails.
  Returns the list of copied files otherwise.
  """
  (case (cp source destination callback)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.copy-error [{#reason reason}
                                   {#action "copy recursively"}
                                   {#source (io.chardata-to-string source)}
                                   {#destination
                                    (io.chardata-to-string destination)}]))))

(defn cp-r [source destination &optional (callback (fn [_ _] :true))]
    (&when (function? callback))
  """Copies the contents in source to destination.

  If the `source` is a file, it copies `source` to `destination`.
  If the `source` is a directory, it copies the contents inside `source`
  into the `destination`.

  If a file already exists in the destination, it invokes a callback
  which should return `:true` if the existing file should be overwritten,
  `:false` otherwise. It defaults to return `:ture`.

  If a directory already exists in the destination where a file
  is meant to be (or otherwise), this function will fail.

  This function may fail while copying files, in such cases,
  it will leave the destination directory in dirty state,
  where already copied files won't be removed.

  It returns `{#ok files-and-directories}` in case of
  success with all files and directories copied in no specific order,
  `{#error reason file}` otherwise.

  Note: The command `cp` in Unix systems behaves differently
  depending if `destination` is an existing directory or not.
  We have chosen to explicitly disallow this behaviour.

  ## Examples

      ;; Copies "a.txt" to "b.txt"
      (file.cp-r "a.txt" "b.txt")

      ;; Copies all files in "samples" to "tmp"
      (file.cp-r "samples" "tmp")

      ;; Same as before, but asks the user how to preceed in case of conflicts
      (file.cp-r "samples" "tmp" (fn [source destination]
                                   (let [message (io_lib.format "Overwriting ~p by ~p"
                                                                [source destination])]
                                     (== (io.gets message) "y"))))

  """
  (let [s (io.chardata-to-string source)
        d (io.chardata-to-string destination)]
    (case (do-cp-r s d callback [])
      ({#error _ _} &as error
       error)
      (res
       {#ok res}))))

(defn cp-r! [source destination &optional (callback (fn [_ _] :true))]
  """The same as `(cp-r 3)`, but raises `file.copy-error` if it fails.
  Returns the list of copied files otherwise.
  """
  (case (cp-r source destination callback)
    ({#ok files}
     files)
    ({#error reason file}
     (raise kapok.file.error [{#reason reason}
                              {#action "copy recursively"}
                              {#on file}
                              {#source (io.chardata-to-string source)}
                              {#destination (io.chardata-to-string destination)}]))))

;; `src' may be a file or a directory, `dest' is definitely
;; a directory. Returns nil unless an error is found.
(defn- do-cp-r [src dest callback acc] (&when (list? acc))
  (case (kapok_utils.read_link_type src)
    ({#ok #regular}
     (do-cp-file src dest callback acc))
    ({#ok #symlink}
     (case (file.read_link src)
       ({#ok link}
        (do-cp-link link src dest callback acc))
       ({#error reason}
        {#error reason src})))
    ({#ok #directory}
     (case (file.list_dir src)
       ({#ok files}
        (case (mkdir dest)
          (success (&when (in success [#ok {#error #eexist}]))
           (seq.reduce files
                       [dest & acc]
                       (fn [x acc0]
                         (do-cp-r (path.join src x)
                                  (path.join dest x)
                                  callback
                                  acc0))))
          ({#error reason}
           {#error reason dest})))
       ({#error reason}
        {#error reason src})))
    ({#ok _}
     {#error #eio src})
    ({#error reason}
     {#error reason src})))

;; If we reach this clause, there was an error while
;; processing a file.
(defn- do-cp-r [_ _ _ acc]
  acc)


(defn- copy-file-mode! [src dest]
  (let [dest-stat (stat! dest)
        src-stat (stat! src)]
    (write-stat! dest
                 (maps.put #mode (maps.get #mode src-stat) dest-stat))))

;; Both src and dest are files.
(defn- do-cp-file [src dest callback acc]
  (case (file.copy src {dest [#exclusive]})
    ({#ok _}
     (copy-file-mode! src dest)
     [dest & acc])
    ({#error #eexist}
     (if (callback src dest)
         ;; If (rm 1) fails, (copy 2) will fail
         (let [_ (rm dest)]
           (case (copy src dest)
             ({#ok _}
              (copy-file-mode! src dest)
              [dest & acc])
             ({#error reason}
              {#error reason src})))
       acc))
    ({#error reason}
     {#error reason src})))

;; Both src and dest are files.
(defn- do-cp-link [link src dest callback acc]
  (case (file.make_symlink link dest)
    (#ok
     [dest & acc])
    ({#error #eexist}
     (if (callback src dest)
         ;; If (rm 1) fails, (file.make_symlink 2) will fail
         (let [_ (rm dest)]
           (case (file.make_symlink link dest)
             (#ok
              [dest & acc])
             ({#error reason}
              {#error reason src})))
       acc))
    ({#error reason}
     {#error reason src})))

(defn write [path content &optional (modes [])]
  """Writes `content` to the file `path`.

  The file is created if it does not exist. If it exists, the previous
  contents are overwritten. Returns `#ok` if successful, or `{#error reason}`
  if an error occurs.

  ** Warning: ** Every time this function is invoked, a file descriptor is opened
  and a new process is spawned to write to the file. For this reason, if you are
  doing multiple writes in a loop, opening the file via `(file.open 2)` and using
  the function in `io` to write to the file will yield much better performance
  then calling this function multiple times.

  Typical error reasons are:

    * `#enoent`  - a component of the file name does not exist
    * `#enotdir` - a component of the file name is not a directory;
                   on some platforms, `#enoent` is returned instead
    * `#enospc`  - there is a no space left on the device
    * `#eacces`  - missing permission for writing the file or searching one of
                   the parent directories
    * `#eisdir`  - the named file is a directory

  Check `(file.open 2)` for other available options.
  """
  (file.write_file (io.chardata-to-string path) content modes))

(defn write! [path content &optional (modes [])]
  "Same as `(write 3)` but raises an exception if it fails, returns `#ok` otherwise."
  (case (write path content modes)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "write to file"}
                              {#path (io.chardata-to-string path)}]))))

(defn rm [path]
  """Tries to delete the file `path`.

  Returns `#ok` if successful, or `{#error reason}` if an error occurs.

  Note the file is deleted even if in read-only mode.

  Typical error reasons are:

    * `#enoent`  - the file does not exist
    * `#eacces`  - missing permission for the file or one of its parents
    * `#eperm`   - the file is directory and user is no super-user
    * `#enotdir` - a component of the file name is not a directory;
                   on some platforms, `#enoent` is returned instead
    * `#einval`  - filename had an improper type, such as tuple

  ## Examples

      (file.rm "file.txt")
      ;;=> #ok

      (file.rm "tmp_dir/")
      ;;=> {#error #eperm}

  """

  (let [p (io.chardata-to-string path)]
    (case (file.delete p)
      (#ok
       #ok)
      ({#error #eacces} &as e
       (or (change-mode-windows p) e))
      ({#error _} &as e
       e))))

(defn- change-mode-windows [path]
  (if (match? {#win32 _} (os.type))
      (case (file.read_file_info path)
        ({#ok file-info} (&when (in (elem file-info 3) [#read #none]))
         (change-mode-windows path file-info))
        (_
         :nil))))

(defn- change-mode-windows [path file-info]
  (case (chmod path (+ (elem file-info 7) 0200))
    (#ok
     (file.delete path))
    ({#error _reason} &as error
     error)))

(defn rm! [path]
  "Same as `(rm 1)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (rm path)
    (#ok #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "remove file"}
                              {#path (io.chardata-to-string path)}]))))

(defn rmdir [path]
  """Tries to delete the dir at `path`.
  Returns `#ok` if successful, or `{#error reason}` if an error occurs.

  ## Examples

      (file.rmdir "tmp_dir")
      ;;=> #ok

      (file.rmdir "file.txt")
      ;;=> {#error #enotdir}

  """
  (file.del_dir (io.chardata-to-string path)))

(defn rmdir! [path]
  "Same as `(rmdir 1)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (rmdir path)
    (#ok #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "remove directory"}
                              {#path (io.chardata-to-string path)}]))))

(defn rm-rf [path]
  """Removes files and directories recursively at the given `path`.
  Symlinks are not followed but simply removed, non-existing
  files are simply ignored (i.e. doesn't make this function fail).

  Returns `{#ok files-and-directories}` with all files
  and directories removed in no specific order, `{#error reason file}`
  otherwise.

  ## Examples

      (file.rm-rf "samples")
      ;;=> {#ok ["samples", "samples/1.txt"]}

      (file.rm-rf "unknown")
      ;;=> {#ok []}

  """

  (do-rm-rf (io.chardata-to-string path) {#ok []}))

(defn- do-rm-rf [path {#ok _} &as entry]
  (case (safe-list-dir path)
    ({#ok files} (&when (list? files))
     (let [res (seq.reduce files entry (fn [file tuple]
                                         (do-rm-rf (path.join path file) tuple)))]
       (case res
         ({#ok acc}
          (case (rmdir path)
            (#ok {#ok [path & acc]})
            ({#error #enoent} res)
            ({#error reason} {#error reason path})))
         (reason
          reason))))
    ({#ok #directory}
     (do-rm-directory path entry))
    ({#ok #regular}
     (do-rm-regular path entry))
    ({#error reason} (&when (in reason [#enoent #enotdir]))
     entry)
    ({#error reason}
     {#error reason path})))

(defn- do-rm-rf [_ reason]
  reason)

(defn- do-rm-regular [path {#ok acc} &as entry]
  (case (rm path)
    (#ok {#ok [path & acc]})
    ({#error #enoent} entry)
    ({#error reason} {#error reason path})))

;; On windows, symlinks are treated as directory and must be removed
;; with `(rmdir 1)`. But on Unix, we remove them via `(rm 1)`. So we
;; first try to remove it as a directory and, if we get `#enotdir`,
;; we fallback to a file removal.
(defn- do-rm-directory [path {#ok acc} &as entry]
  (case (rmdir path)
    (#ok {#ok [path & acc]})
    ({#error #enotdir} (do-rm-regular path entry))
    ({#error #enoent} entry)
    ({#error reason} {#error reason path})))

(defn- safe-list-dir [path]
  (case (kapok_utils.read_link_type path)
    ({#ok #symlink}
     (case (kapok_utils.read_file_type path)
       ({#ok #directory} &as r
        r)
       (_
        {#ok #regular})))
    ({#ok #directory}
     (file.list_dir path))
    ({#ok _}
     {#ok #regular})
    ({#error _reason} &as e
     e)))

(defn rm-rf! [path]
  """Same as `(rm-rf 1)` but raises `file.error` in case of failures,
  otherwise the list of files or directories removed.
  """
  (case (rm-rf path)
    ({#ok files} files)
    ({#error reason _}
     (raise kapok.file.error
            [{#reason reason}
             {#action "remove files and directories recursively from"}
             {#path (io.chardata-to-string path)}]))))

(defn open
  """Opens the given `path` according to the given list of modes.

  In order to write and read files, one must use the functions
  in the `io` module. By default, a file is opened in binary mode
  which requires the functions `(io.binread 2)` and `(io.binwrite 2)`
  to interact with the file. A developer may pass `#utf8` as an option
  when opening the file and then all other functions from `io`
  are available, since they work directly with Unicode data.

  The allowed modes:

    * `#read` - the file, which must exist, is opened for reading.

    * `#write` - the file is opened for writing. It is created if
      it does not exist.

      If the file does not exists, and if write is not combined with read,
      the file will be truncated.

    * `#append` - the file will be opned for writing, and it will be created
      if it does not exist. Every write operation to a file opened with
      `#append` will take place at the end of the file.

    * `#exclusive` - the file, when opened for writing, is created if it does
      not exist. If the file exists, open will return `{#error #eexist}`.

    * `#char_list` - when this term is given, read operations on the file will
      return char list rather than binaries.

    * `#compressed` - makes it possible to read or write gzip compressed files.

      The `#compressed` option must be combined with either read or write,
      but not both. Note that the file size obtained with `(stat 1)` will most
      probably not match the number of bytes that can be read from
      a compressed file.

    * `#utf8` - this option denotes how data is actually stored in the disk
      file and makes the file perform automatic translation of characters to
      and from utf-8.

      If data is sent to a file in a format that cannot be converted to the
      utf-8 or if data is read by a function that returns data in a format that
      cannot cope with the character range of the data, an error occurs and the
      file will be closed.

  Check http://www.erlang.org/doc/man/file.html#open-2 for more information about
  other options like `:read_ahead` and `:delayed_write`.

  This function returns:

    * `{#ok io-device}` - the file has been opened in the requested mode.

      `io-device` is actually the pid of the process which handles the file.
      This process is linked to the process which originally opened the file.
      If any process to which the `io-device` is linked terminates, the file
      will be closed and the process itself will be terminated.

      An `io-device` returned from this call can be used as an argument to the
      `io` module functions.

    * `{#error reason}` - the file could not be opened.

  ## Examples

      (let [{#ok file}  (file.open "foo.tar.gz" [#read #compressed])]
        (io.read file, :line)
        (file.close file))

  """
  ([path]
   (open path []))

  ([path modes] (&when (list? modes))
   (file.open (io.chardata-to-string path) (open-defaults modes :true)))

  ([path function] (&when (function? function))
   (open path [] function)))

(defn open [path modes function]
  """Similar to `(open 2)` but expects a function as last argument.

  The file is opened, given to the function as argument and
  automatically closed after the function returns, regardless
  if there was an error when executing the function.

  It returns `{#ok function-result}` in case of success,
  `{#error reason}` otherwise.

  This function expects the file to be closed with success,
  which is usually the case unless the `#delay_write` option
  is given. For this reason, we do not recommend passing
  `#delay_write` to this function.

  ## Examples

      (file.open "file.txt" [#read #write] (fn [file]
                                             (io.read file #line)))

  """
  (case (open path modes)
    ({#ok device}
     (try {#ok (function device)}
       (after
        (let [#ok (close device)]
          :true))))
    (other
     other)))

(defn open! [path &optional (modes [])]
  """Same as `(open 2)` but raises an error if file could not be opened.

  Returns the `io-device` otherwise.
  """
  (case (open path modes)
    ({#ok device}
     device)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "open"}
                              {#path (io.chardata-to-string path)}]))))

(defn open! [path modes function]
  """Same as `(open 3)` but raises an error if file could not be opened.

  Returns the function result otherwise.
  """
  (case (open path modes function)
    ({#ok device}
     device)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "open"}
                              {#path (io.chardata-to-string path)}]))))

(defn cwd []
  """Gets the current working directory.

  In rare circumstances, this function can fail on Unix. It may happen
  if read permission does not exist for the parent directories of the
  current directory. For this reason, returns `{#ok cwd}` in case
  of success, `{#error reason}` otherwise.
  """
  (case (file.get_cwd)
    ({#ok base}
     {#ok (io.chardata-to-string (fix-drive-letter base))})
    ({#error _} &as error
     error)))

(defn- fix-drive-letter [[l \: \/ & rest] &as original]
    (&when (&and (>= l \A) (<= l \Z)))
  (case (os.type)
    ({#win32 _}
     [(- (+ (l \a)) \A) \: \/ & rest])
    (_
     original)))

(defn- fix-drive-letter [original]
  original)

(defn cwd! []
  "The same as `(cwd 0)`, but raises an exception if it fails."
  (case (cwd)
    ({#ok cwd}
     cwd)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "get current working directory"}]))))

(defn cd [path]
  """Sets the current working directory.

  Returns `#ok` if successful, `{#error reason}` otherwise.
  """
  (file.set_cwd (io.chardata-to-string path)))

(defn cd! [path]
  "The same as `(cd 1)`, but raises an exception if it fails."
  (case (cd path)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "set current working directory to"}
                              {#path (io.chardata-to-string path)}]))))

(defn cd! [path function]
  """Changes the current directory to the given `path`,
  executes the given function and then revert back
  to the previous path regardless if there is an exception.

  Raises an error if retrieving or changing the current
  directory fails.
  """
  (let [old (cwd!)]
    (cd! path)
    (try (function)
      (after
       (cd! old)))))

(defn ls [&optional (path ".")]
  """Returns list of files in the given directory.

  It returns `{#ok files}` in case of success,
  `{#error reason}` otherwise.
  """
  (case (file.list_dir (io.chardata-to-string path))
    ({#ok file-list}
     {#ok (seq.map file-list (fn [x] (io.chardata-to-string x)))})
    ({#error _} &as error
     error)))

(defn ls! [&optional (path ".")]
  """The same as `(ls 1)` but raises `file.error` in case of an error."""
  (case (ls path)
    ({#ok value}
     value)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "list directory"}
                              {#path (io.chardata-to-string path)}]))))

(defn close [io-device]
  """Closes the file referenced by `io-device`. It mostly returns `#ok`, except
  for some severe errors such as out of memory.

  Note that if the option `#delay_write` was used when opening the file,
  `(close 1)` might return an old write error and not even try to close the file.
  See `(open 2)`.
  """
  (file.close io-device))

(defn chmod [path mode]
  """Changes the `mode` for a given `file`.

  Returns `#ok` on success, or `{#error reason}` on failure.

  ## Permissions

    * 0400 - read permission: owner
    * 0200 - write permission: owner
    * 0100 - execute permission: owner

    * 0040 - read permission: group
    * 0020 - write permission: group
    * 0001 - execute permission: group

    * 0004 - read permission: other
    * 0002 - write permission: other
    * 0001 - execute permission: other

  For example, setting the mode 0755 gives it
  write, read and execute permission to the owner
  and both read and execute permission to group and others.
  """
  (file.change_mode (io.chardata-to-string path) mode))

(defn chmod! [path mode]
  "Same as `(chmod 2)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (chmod path mode)
    (#ok #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "change mode for"}
                              {#path (io.chardata-to-string path)}]))))

(defn chgrp [path gid]
  """Changes the user group given by the group id `gid`
  for a given `path`. Returns `#ok` on success, or
  `{#error reason}` on failure.
  """
  (file.change_group (io.chardata-to-string path) gid))

(defn chgrp! [path gid]
  "Same as `(chgrp 2)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (chgrp path gid)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "change group for"}
                              {#path (io.chardata-to-string path)}]))))

(defn chown [path uid]
  """Changes the owner given by the user id `uid`
  for a given `path`. Returns `#ok` on success,
  or `{#error reason}` on failure.
  """
  (file.change_owner (io.chardata-to-string path) uid))

(defn chown! [path uid]
  "Same as `(chown 2)`, but raises an exception in case of failure. Otherwise `#ok`."
  (case (chown path uid)
    (#ok
     #ok)
    ({#error reason}
     (raise kapok.file.error [{#reason reason}
                              {#action "change owner for"}
                              {#path (io.chardata-to-string path)}]))))

;; Helpers

(attribute read-ahead (* 64 1204))

(defn- open-defaults [[#char_list & t] _add-binary]
  (open-defaults t :false))

(defn- open-defaults [[#utf8 & t] add-binary]
  (open-defaults [{#encoding #utf8} & t] add-binary))

(defn- open-defaults [[#read_ahead & t] add-binary]
  (open-defaults [{#read_ahead (attr #'read-ahead')} & t] add-binary))

(defn- open-defaults [[h & t] add-binary]
  [h & (open-defaults t add-binary)])

(defn- open-defaults [[] :true]
  [#binary])
(defn- open-defaults [[] :false]
  [])
