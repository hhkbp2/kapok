(ns kapok.io
  """Functions handling IO.

  Many functions in this module expect an IO device as an argument.
  An IO device must be a pid or an atom representing a process.
  For convenience, Kapok provides `#stdio` and `#stderr` as
  shortcuts to Erlang's `#standard_io` and `#standard_error`.

  The majority of the functions expect char data, i.e. strings or
  lists of characters and strings. In case another type is given,
  it will do a conversion to string via the `string.chars` protocol.

  The functions starting with `bin*` expect iodata as an  argument,
  i.e. binaries or lists of bytes and binaries.

  ## IO devices

  An IO device may be an atom or a pid. In case it is an atom,
  the atom must be the name of a registered process. However,
  there are three exceptions for this rule:

    * `#stardard_io` - when the `#standard_io` atom is given,
      it is treated as a shortcut for `process.group_leader`

    * `#stdio` - is a shortcut for `#standard_io`

    * `#stderr` - is a shortcut for `#standard_error`

  """

  (require io
           file)
  (use (erlang :only (group_leader)))
  )

(defmacro is_iodata [data]
  `(&or (list? ~data)
        (binary? ~data)))

(defn read
  """Reads `count` characters from the IO device, a whole
  `#line` or the whole device with `#all`.

  It returns:

    * `data` - the input characters

    * `#eof` - end of file was encountered

    * `{#error reason}` - other (rare) error condition;
      for instance, `{#error #estale}` if reading from an NFS volume

  If `#all` is given, `#eof` is never returned, but an
  empty string in case the device has reached EOF.
  """

  ([chars-or-line]
   (read (group_leader) chars-or-line))

  ([device #all]
   (do-read-all (map-dev device) ""))

  ([device #line]
   (io.get_line (map-dev device) #""))

  ([device count] (&when (>= count 0))
   (io.get_chars (map-dev device) #"" count))
  )

(defn- do-read-all [mapped-dev acc]
  (case (io.get_line mapped-dev "")
    (line (&when (binary? line))
     (do-read-all mapped-dev <<(acc) (line)>>))
    (#eof acc)
    (other other)))

(defn binread
  """Reads `count` characters from the IO device, a whole
  `#line`  or the whole device with `#all`.

  It returns:

    * `data` - the input characters

    * `#eof` - end of file was encountered

    * `{#error reason}` - other (rare) error condition;
      for instance, `{#error #estale}` if reading from an
      NFS volume

  If `#all` is given, `#eof` is never returned, but an
  empty string in case the device has reache EOF.

  Note: do not use this function on IO devices in unicode mode
  as it will return the wroing result.
  """

  ([chars-or-line]
   (binread (group_leader) chars-or-line))

  ([device #all]
   (do-binread-all (map-dev device) ""))

  ([device #line]
   (case (file.read_line (map-dev device))
     ({#ok data} data)
     (other other)))

  ([device count] (&when (>= count 0))
   (case (file.read (map-dev device) count)
     ({#ok data} data)
     (other other))))

(defn- do-binread-all [mapped-dev acc]
  (case (file.read_line mapped-dev)
    ({#ok data}
     (do-binread-all mapped-dev <<(acc) (data)>>))
    (#eof acc)
    (other other)))

(defn write
  """Writes the given argument to the given device.

  By default the device is the standard output.
  It returns `#ok` if it succeeds.

  ## Examples

      (io.write "sample")
      ;;=> "sample"

      (io.write #stderr "error")
      ;;=> "error"

  """
  ([item]
   (write (group_leader) item))

  ([device item]
   (io.put_chars (map-dev device) (to-chardata item)))
  )

;; Map the Kapok names for standard io and error to Erlang names
(defn- map-dev [#stdio]
  #standard_io)
(defn- map-dev [#stderr]
  #standard_error)
(defn- map-dev [other] (&when (&or (atom? other)
                                   (pid? other)
                                   (tuple? other)))
  other)

(defn- to-chardata [list] (&when (list? list))
  list)
(defn- to-chardata [other]
  (to-string other))
