(ns kapok.io
  """Functions handling IO.

  Many functions in this module expect an IO device as an argument.
  An IO device must be a pid or an atom representing a process.
  For convenience, Kapok provides `#stdio` and `#stderr` as
  shortcuts to Erlang's `#standard_io` and `#standard_error`.

  The majority of the functions expect char data, i.e. strings or
  lists of characters and strings. In case another type is given,
  it will do a conversion to string via the `string.chars` protocol.

  The functions starting with `bin*` expect iodata as an  argument,
  i.e. binaries or lists of bytes and binaries.

  ## IO devices

  An IO device may be an atom or a pid. In case it is an atom,
  the atom must be the name of a registered process. However,
  there are three exceptions for this rule:

    * `#stardard_io` - when the `#standard_io` atom is given,
      it is treated as a shortcut for `process.group_leader`

    * `#stdio` - is a shortcut for `#standard_io`

    * `#stderr` - is a shortcut for `#standard_error`

  """

  (require io
           file
           erlang
           unicode)
  (use (erlang :only (group_leader)))
  )

(defmacro iodata? [data]
  `(&or (list? ~data)
        (binary? ~data)))

(defn read
  """Reads `count` characters from the IO device, a whole
  `#line` or the whole device with `#all`.

  It returns:

    * `data` - the input characters

    * `#eof` - end of file was encountered

    * `{#error reason}` - other (rare) error condition;
      for instance, `{#error #estale}` if reading from an NFS volume

  If `#all` is given, `#eof` is never returned, but an
  empty string in case the device has reached EOF.
  """

  ([chars-or-line]
   (read (group_leader) chars-or-line))

  ([device #all]
   (do-read-all (map-dev device) ""))

  ([device #line]
   (io.get_line (map-dev device) #""))

  ([device count] (&when (>= count 0))
   (io.get_chars (map-dev device) #"" count))
  )

(defn- do-read-all [mapped-dev acc]
  (case (io.get_line mapped-dev "")
    (line (&when (binary? line))
     (do-read-all mapped-dev <<(acc) (line)>>))
    (#eof acc)
    (other other)))

(defn binread
  """Reads `count` characters from the IO device, a whole
  `#line`  or the whole device with `#all`.

  It returns:

    * `data` - the input characters

    * `#eof` - end of file was encountered

    * `{#error reason}` - other (rare) error condition;
      for instance, `{#error #estale}` if reading from an
      NFS volume

  If `#all` is given, `#eof` is never returned, but an
  empty string in case the device has reache EOF.

  Note: do not use this function on IO devices in unicode mode
  as it will return the wroing result.
  """

  ([chars-or-line]
   (binread (group_leader) chars-or-line))

  ([device #all]
   (do-binread-all (map-dev device) ""))

  ([device #line]
   (case (file.read_line (map-dev device))
     ({#ok data} data)
     (other other)))

  ([device count] (&when (>= count 0))
   (case (file.read (map-dev device) count)
     ({#ok data} data)
     (other other))))

(defn- do-binread-all [mapped-dev acc]
  (case (file.read_line mapped-dev)
    ({#ok data}
     (do-binread-all mapped-dev <<(acc) (data)>>))
    (#eof acc)
    (other other)))

(defn write
  """Writes the given argument to the given device.

  By default the device is the standard output.
  It returns `#ok` if it succeeds.

  ## Examples

      (io.write "sample")
      ;;=> "sample"

      (io.write #stderr "error")
      ;;=> "error"

  """
  ([item]
   (write (group_leader) item))

  ([device item]
   (io.put_chars (map-dev device) (to-chardata item))))

;; Map the Kapok names for standard io and error to Erlang names
(defn- map-dev [#stdio]
  #standard_io)
(defn- map-dev [#stderr]
  #standard_error)
(defn- map-dev [other] (&when (&or (atom? other)
                                   (pid? other)
                                   (tuple? other)))
  other)

(defn- to-chardata [list] (&when (list? list))
  list)
(defn- to-chardata [other]
  (to-string other))

(defn binwrite
  """Writes the given argument to the given device
  as a binary, no unicode conversion happens.

  Check `(write 2)` for more information.

  Note: do not use this function on IO devices in unicode mode
  as it will return the wroing result.
  """

  ([item] (&when (iodata? item))
   (binwrite (group_leader) item))

  ([device item] (&when (iodata? item))
   (file.write (map-dev device) item)))

(defn puts
  """Writes the argument to the device, similar to `(write 2)`,
  but adds a newline at the end. The argument is expected
  to be a chardata.
  """
  ([item]
   (puts (group_leader) item))

  ([device item]
   (let [erl-dev (map-dev device)]
     (io.put_chars erl-dev [(to-chardata item) $\n]))))

;; TODO impl the missing functions and uncomment the following block
;; (defn inspect [item &optional (opts [])]
;;   """Inspects and writes the given argument to the device.

;;   It enables pretty printing by default with width of
;;   80 characters. The width can be changed by explicitly
;;   passing the `#width` option.

;;   ## Examples

;;       (io.inspect (process.list) [{#width 40}])

;;   """
;;   (inspect (group_leader) item opts))

;; (defn inspect [device item opts] (&when (list? opts))
;;   """Inspects the item with options using the given device."""
;;   (let [opts (struct inspect.opts opts)
;;         iodata (inspect.algebra.form
;;                 (inspect.algebra.to-doc item opts)
;;                 (get opts.width))]
;;     (puts device iodata)
;;     item))


(defn getn [device prompt count]
  """Gets a number of bytes from the io device. If the
  io device is a unicode device, `count` implies
  the number of unicode codepoints to be retrieved.
  Otherwise, `count` is the number of raw bytes to be retrieved.
  """

  (io.get_chars (map-dev device) (to-chardata prompt) count))

(defn gets
  """Reads a line from the IO device. It returns:

    * `data` - the characters in the line terminated
      by a LF (or end of line)

    * `#eof` - end of file was encountered

    * `{#error reason}` - other (rare) error condition;
      for instance, `{#error #estale}` if reading from an
      NFS volume
  """
  ([prompt]
   (gets (group_leader) prompt))

  ([device prompt]
   (io.get_line (map-dev device) (to-chardata prompt))))

(defn chardata-to-string
  """Converts chardata (a list of integers representing codepoints,
  lists and strings) into a string.

  In case the conversion fails, it raises a error.
  If a string is given, returns the string itself.

  ## Examples

      kapok> (io.chardata-to-string [0x00E6, 0x00DF])
      "æß"

      kapok> (io.chardata_to_string [0x0061, "bc"])
      "abc"

  """

  ([string] (&when (binary? string))
   string)

  ([list] (&when (list? list))
   (case (unicode.characters_to_binary list)
     (result (&when (binary? result))
      result)
     ({#error _encoded _rest}
      ;; TODO revise to use exception
      (throw "unicode conversion error"))
     ({#incomplete _encoded _rest}
      ;; TODO revise to use exception
      (throw "unicode conversion incomplete error")))))

(defn iodata-to-binary [item]
  """Converts iodata (a list of integers representing bytes, lists
  and binaries) into a binary.

  Notice that this function treats lists of integers as raw bytes
  and does not perform any kind of encoding conversion. If you want
  to convert from a char list to a string (UTF-8 encoded), please
  use `(chardata-to-string 1)` instead.

  If this function receives a binary, the same binary is returned.

  Inlined by the compiler.

  ## Examples

      kapok> (let [bin1 <<(1) (2) (3)>>
                   bin2 <<(4) (5)>>
                   bin3 <<(6)>>]
               (io.iodata-to-binary [bin1 1 [2 3 bin2] 4 & bin3]))
      <<1 2 3 1 2 3 4 5 4 6>>

      kapok> (let [bin <<(1) (2) (3)>>]
               (io.iodata-to-binary bin))
      <<1 2 3>>

  """
  (erlang.iolist_to_binary item))

(defn iodata-length [item]
  """Returns the size of an iodata.

  Inlined by the compiler.

  ## Examples

      kapok> (io.iodata-length [1 2 & <<(3) (4)>>])
      4

  """
  (erlang.iolist_size item))
