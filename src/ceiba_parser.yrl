%%
Header "%% THIS FILE IS AUTO-GENERATED BY YECC. "
"%% DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING.".

Nonterminals
    grammar
    expression expression_list expressions
    binary
    quote backquote unquote unquote_splicing
    value comma_value value_list values
    open_paren close_paren open_bracket close_bracket list
    open_curly close_curly tuple
    paired_comma_values paired_value_list paired_values unpaired_values open_bang_curly map
    open_percent_curly set
    .

Terminals
    identifier number binary_string list_string atom
    '(' ')' '[' ']' '{' '%{' '#{' '}'  '<<' '>>' ','
    '~@' '`' '\'' '~' %'&'
    .

Rootsymbol grammar.

%% MAIN FLOW OF EXPRESSIONS

grammar -> expressions : '$1'.
grammar -> '$empty' : nil.

% expression as represented in list format
expression -> value : '$1'.

expression_list -> expression : ['$1'].
expression_list -> expression_list expression : ['$2' | '$1'].

expressions -> expression_list : lists:reverse('$1').

%% Binary
%% TODO
%%binary_args ->
binary      -> '<<' '>>' : build_binary('$1', []).
%%binary    -> '<<' binary_args '>>'

%% Macro syntaxs
quote       -> '\'' value : build_quote('$1', '$2').
backquote   -> '`' value : build_backquote('$1', '$2').
unquote     -> '~' value : build_unquote('$1', '$2').
unquote_splicing -> '~@' list : build_unquote_splicing('$1', '$2').

%% Value

value       -> number : '$1'.
value       -> binary_string : '$1'.
value       -> list_string : '$1'.
value       -> binary : '$1'.
value       -> identifier : '$1'.
value       -> atom : '$1'.
value       -> list : '$1'.
value       -> tuple : '$1'.
value       -> map : '$1'.
value       -> set : '$1'.
value       -> quote : '$1'.
value       -> backquote : '$1'.
value       -> unquote: '$1'.
value       -> unquote_splicing : '$1'.

%% Containers

comma_value -> value : '$1'.
comma_value -> ',' value : '$2'.

value_list  -> value :  ['$1'].
value_list  -> value_list comma_value : ['$2' | '$1'].

values      -> value_list : lists:reverse('$1').

%% List
open_paren  -> '(' : '$1'.
close_paren -> ')' : '$1'.
open_bracket  -> '[' : '$1'.
close_bracket -> ']' : '$1'.

list -> open_bracket close_bracket : build_list('$1', []).
list -> open_bracket values close_bracket : build_list('$1', '$2').
list -> open_paren close_paren : build_list('$1', []).
list -> open_paren values close_paren: build_list('$1', '$2').

%% Tuple
open_curly   -> '{' : '$1'.
close_curly  -> '}' : '$1'.

tuple -> open_curly close_curly : build_tuple('$1', []).
tuple -> open_curly values close_curly: build_tuple('$1', '$2').

%% Map

paired_comma_values -> comma_value comma_value : ['$1', '$2'].

paired_value_list -> value comma_value : ['$1', '$2'].
paired_value_list -> paired_value_list paired_comma_values : lists:append('$2', '$1').

paired_values   -> paired_value_list : lists:reverse('$1').

unpaired_values -> value : ['$1'].
unpaired_values -> paired_comma_values comma_value : ['$2' | '$1'].

open_bang_curly -> '#{' : '$1'.

map -> open_bang_curly close_curly : build_map('$1', []).
map -> open_bang_curly paired_values close_curly : build_map('$1', '$2').
map -> open_bang_curly unpaired_values close_curly : throw_unpaired_map('$1', '$2').

%% Set

open_percent_curly -> '%{' : '$1'.

set -> open_percent_curly close_curly : build_set('$1', []).
set -> open_percent_curly values close_curly : build_set('$1', '$2').


Erlang code.

-import(ceiba_scanner, [token_location/1, token_line/1]).

build_binary(Marker, Args) ->
    {binary, token_location(Marker), Args}.

build_quote(Marker, Args) ->
    {quote, token_location(Marker), Args}.

build_backquote(Marker, Args) ->
    {backquote, token_location(Marker), Args}.

build_unquote(Marker, Args) ->
    {unquote, token_location(Marker), Args}.

build_unquote_splicing(Marker, Args) ->
    {unquote_splicing, token_location(Marker), Args}.

build_list(Marker, Args) ->
    {list, token_location(Marker), Args}.

build_tuple(Marker, Args) ->
    {tuple, token_location(Marker), Args}.

build_map(Marker, Args) ->
    {map, token_location(Marker), Args}.

build_set(Marker, Args) ->
    {set, token_location(Marker), Args}.

%% Errors
throw(Line, Error, Token) ->
    throw({error, {Line, [Error, Token]}}).

throw_unpaired_map(Marker, Args) ->
    throw(token_line(Marker), "unpaired values in map", Args).
